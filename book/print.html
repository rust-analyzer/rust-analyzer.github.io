<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-analyzer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-analyzer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust-analyzer/tree/master/docs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-analyzer"><a class="header" href="#rust-analyzer">rust-analyzer</a></h1>
<p>rust-analyzer is a language server that provides IDE functionality for
writing Rust programs. You can use it with any editor that supports
the <a href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a> (VS
Code, Vim, Emacs, Zed, etc).</p>
<p>rust-analyzer features include go-to-definition, find-all-references,
refactorings and code completion. rust-analyzer also supports
integrated formatting (with rustfmt) and integrated diagnostics (with
rustc and clippy).</p>
<p>Internally, rust-analyzer is structured as a set of libraries for
analyzing Rust code. See
<a href="https://rust-analyzer.github.io/book/contributing/architecture.html">Architecture</a>
for more details.</p>
<p>To improve this document, send a pull request:
<a href="https://github.com/rust-lang/rust-analyzer/blob/master/docs/book/README.md">https://github.com/rust-lang/rust-analyzer</a></p>
<p>The manual is written in markdown and includes
some extra files which are generated from the source code. Run
<code>cargo test</code> and <code>cargo xtask codegen</code> to create these.</p>
<p>If you have questions about using rust-analyzer, please ask them in the
<a href="https://users.rust-lang.org/c/ide/14">"IDEs and Editors"</a> topic of Rust
users forum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>To use rust-analyzer, you need a <code>rust-analyzer</code> binary, a text editor
that supports LSP, and the source code of the Rust standard library.</p>
<p>If you're <a href="./vs_code.html">using VS Code</a>, the extension bundles a
copy of the <code>rust-analyzer</code> binary. For other editors, you'll need to
<a href="./rust_analyzer_binary.html">install the binary</a> and <a href="./other_editors.html">configure your
editor</a>.</p>
<h2 id="rust-standard-library"><a class="header" href="#rust-standard-library">Rust Standard Library</a></h2>
<p>rust-analyzer will attempt to install the standard library source code
automatically. You can also install it manually with <code>rustup</code>.</p>
<pre><code>$ rustup component add rust-src
</code></pre>
<p>Only the latest stable standard library source is officially supported
for use with rust-analyzer. If you are using an older toolchain or have
an override set, rust-analyzer may fail to understand the Rust source.
You will either need to update your toolchain or use an older version of
rust-analyzer that is compatible with your toolchain.</p>
<p>If you are using an override in your project, you can still force
rust-analyzer to use the stable toolchain via the environment variable
<code>RUSTUP_TOOLCHAIN</code>. For example, with VS Code or coc-rust-analyzer:</p>
<pre><code class="language-json">{ "rust-analyzer.server.extraEnv": { "RUSTUP_TOOLCHAIN": "stable" } }
</code></pre>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>There is a package named <code>ra_ap_rust_analyzer</code> available on
<a href="https://crates.io/crates/ra_ap_rust-analyzer">crates.io</a>, for people
who want to use rust-analyzer programmatically.</p>
<p>For more details, see <a href="https://github.com/rust-lang/rust-analyzer/blob/master/.github/workflows/autopublish.yaml">the publish
workflow</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h1>
<p>This is the best supported editor at the moment. The rust-analyzer
plugin for VS Code is maintained <a href="https://github.com/rust-lang/rust-analyzer/tree/master/editors/code">in
tree</a>.</p>
<p>You can install the latest release of the plugin from <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">the
marketplace</a>.</p>
<p>Note that the plugin may cause conflicts with the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">previous official
Rust
plugin</a>.
The latter is no longer maintained and should be uninstalled.</p>
<p>The server binary is stored in the extension install directory, which
starts with <code>rust-lang.rust-analyzer-</code> and is located under:</p>
<ul>
<li>
<p>Linux: <code>~/.vscode/extensions</code></p>
</li>
<li>
<p>Linux (Remote, such as WSL): <code>~/.vscode-server/extensions</code></p>
</li>
<li>
<p>macOS: <code>~/.vscode/extensions</code></p>
</li>
<li>
<p>Windows: <code>%USERPROFILE%\.vscode\extensions</code></p>
</li>
</ul>
<p>As an exception, on NixOS, the extension makes a copy of the server and
stores it under
<code>~/.config/Code/User/globalStorage/rust-lang.rust-analyzer</code>.</p>
<p>Note that we only support the two most recent versions of VS Code.</p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>The extension will be updated automatically as new versions become
available. It will ask your permission to download the matching language
server version binary if needed.</p>
<h4 id="nightly"><a class="header" href="#nightly">Nightly</a></h4>
<p>We ship nightly releases for VS Code. To help us out by testing the
newest code, you can enable pre-release versions in the Code extension
page.</p>
<h3 id="manual-installation"><a class="header" href="#manual-installation">Manual installation</a></h3>
<p>Alternatively, download a VSIX corresponding to your platform from the
<a href="https://github.com/rust-lang/rust-analyzer/releases">releases</a> page.</p>
<p>Install the extension with the <code>Extensions: Install from VSIX</code> command
within VS Code, or from the command line via:</p>
<pre><code>$ code --install-extension /path/to/rust-analyzer.vsix
</code></pre>
<p>If you are running an unsupported platform, you can install
<code>rust-analyzer-no-server.vsix</code> and compile or obtain a server binary.
Copy the server anywhere, then add the path to your settings.json, for
example:</p>
<pre><code class="language-json">{ "rust-analyzer.server.path": "~/.local/bin/rust-analyzer-linux" }
</code></pre>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building From Source</a></h3>
<p>Both the server and the Code plugin can be installed from source:</p>
<pre><code>$ git clone https://github.com/rust-lang/rust-analyzer.git &amp;&amp; cd rust-analyzer
$ cargo xtask install
</code></pre>
<p>You’ll need Cargo, nodejs (matching a supported version of VS Code) and
npm for this.</p>
<p>Note that installing via <code>xtask install</code> does not work for VS Code
Remote, instead you’ll need to install the <code>.vsix</code> manually.</p>
<p>If you’re not using Code, you can compile and install only the LSP
server:</p>
<pre><code>$ cargo xtask install --server
</code></pre>
<p>Make sure that <code>.cargo/bin</code> is in <code>$PATH</code> and precedes paths where
<code>rust-analyzer</code> may also be installed. Specifically, <code>rustup</code> includes a
proxy called <code>rust-analyzer</code>, which can cause problems if you’re
planning to use a source build or even a downloaded binary.</p>
<h2 id="vs-code-or-vscodium-in-flatpak"><a class="header" href="#vs-code-or-vscodium-in-flatpak">VS Code or VSCodium in Flatpak</a></h2>
<p>Setting up <code>rust-analyzer</code> with a Flatpak version of Code is not trivial
because of the Flatpak sandbox. While the sandbox can be disabled for
some directories, <code>/usr/bin</code> will always be mounted under
<code>/run/host/usr/bin</code>. This prevents access to the system’s C compiler, a
system-wide installation of Rust, or any other libraries you might want
to link to. Some compilers and libraries can be acquired as Flatpak
SDKs, such as <code>org.freedesktop.Sdk.Extension.rust-stable</code> or
<code>org.freedesktop.Sdk.Extension.llvm15</code>.</p>
<p>If you use a Flatpak SDK for Rust, it must be in your <code>PATH</code>:</p>
<ul>
<li>install the SDK extensions with <code>flatpak install org.freedesktop.Sdk.Extension.{llvm15,rust-stable}//23.08</code></li>
<li>enable SDK extensions in the editor with the environment variable <code>FLATPAK_ENABLE_SDK_EXT=llvm15,rust-stable</code> (this can be done using flatseal or <code>flatpak override</code>)</li>
</ul>
<p>If you want to use Flatpak in combination with <code>rustup</code>, the following
steps might help:</p>
<ul>
<li>
<p>both Rust and <code>rustup</code> have to be installed using
<a href="https://rustup.rs">https://rustup.rs</a>. Distro packages <em>will not</em> work.</p>
</li>
<li>
<p>you need to launch Code, open a terminal and run <code>echo $PATH</code></p>
</li>
<li>
<p>using
<a href="https://flathub.org/apps/details/com.github.tchx84.Flatseal">Flatseal</a>,
you must add an environment variable called <code>PATH</code>. Set its value to
the output from above, appending <code>:~/.cargo/bin</code>, where <code>~</code> is the
path to your home directory. You must replace <code>~</code>, as it won’t be
expanded otherwise.</p>
</li>
<li>
<p>while Flatseal is open, you must enable access to "All user files"</p>
</li>
</ul>
<p>A C compiler should already be available via <code>org.freedesktop.Sdk</code>. Any
other tools or libraries you will need to acquire from Flatpak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-analyzer-binary"><a class="header" href="#rust-analyzer-binary">rust-analyzer Binary</a></h1>
<p>Text editors require the <code>rust-analyzer</code> binary to be in
<code>$PATH</code>. You can download pre-built binaries from the
<a href="https://github.com/rust-lang/rust-analyzer/releases">releases</a> page.
You will need to uncompress and rename the binary for your platform,
e.g. from <code>rust-analyzer-aarch64-apple-darwin.gz</code> on Mac OS to
<code>rust-analyzer</code>, make it executable, then move it into a directory in
your <code>$PATH</code>.</p>
<p>On Linux to install the <code>rust-analyzer</code> binary into <code>~/.local/bin</code>,
these commands should work:</p>
<pre><code>$ mkdir -p ~/.local/bin
$ curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - &gt; ~/.local/bin/rust-analyzer
$ chmod +x ~/.local/bin/rust-analyzer
</code></pre>
<p>Make sure that <code>~/.local/bin</code> is listed in the <code>$PATH</code> variable and use
the appropriate URL if you’re not on a <code>x86-64</code> system.</p>
<p>You don’t have to use <code>~/.local/bin</code>, any other path like <code>~/.cargo/bin</code>
or <code>/usr/local/bin</code> will work just as well.</p>
<p>Alternatively, you can install it from source using the command below.
You’ll need the latest stable version of the Rust toolchain.</p>
<pre><code>$ git clone https://github.com/rust-lang/rust-analyzer.git &amp;&amp; cd rust-analyzer
$ cargo xtask install --server
</code></pre>
<p>If your editor can’t find the binary even though the binary is on your
<code>$PATH</code>, the likely explanation is that it doesn’t see the same <code>$PATH</code>
as the shell, see <a href="https://github.com/rust-lang/rust-analyzer/issues/1811">this
issue</a>. On Unix,
running the editor from a shell or changing the <code>.desktop</code> file to set
the environment should help.</p>
<h3 id="rustup"><a class="header" href="#rustup">rustup</a></h3>
<p><code>rust-analyzer</code> is available in <code>rustup</code>:</p>
<pre><code>$ rustup component add rust-analyzer
</code></pre>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<p>The <code>rust-analyzer</code> binary can be installed from the repos or AUR (Arch
User Repository):</p>
<ul>
<li>
<p><a href="https://www.archlinux.org/packages/extra/x86_64/rust-analyzer/"><code>rust-analyzer</code></a>
(built from latest tagged source)</p>
</li>
<li>
<p><a href="https://aur.archlinux.org/packages/rust-analyzer-git"><code>rust-analyzer-git</code></a>
(latest Git version)</p>
</li>
</ul>
<p>Install it with pacman, for example:</p>
<pre><code>$ pacman -S rust-analyzer
</code></pre>
<h3 id="gentoo-linux"><a class="header" href="#gentoo-linux">Gentoo Linux</a></h3>
<p><code>rust-analyzer</code> is installed when the <code>rust-analyzer</code> use flag is set for dev-lang/rust or dev-lang/rust-bin. You also need to set the <code>rust-src</code> use flag.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>The <code>rust-analyzer</code> binary can be installed via
<a href="https://brew.sh/">Homebrew</a>.</p>
<pre><code>$ brew install rust-analyzer
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>It is recommended to install the latest Microsoft Visual C++ Redistributable prior to installation.
Download links can be found
<a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-editors"><a class="header" href="#other-editors">Other Editors</a></h1>
<p>rust-analyzer works with any editor that supports the <a href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a>.</p>
<p>This page assumes that you have already <a href="./rust_analyzer_binary.html">installed the rust-analyzer
binary</a>.</p>
<ul>
<li><a href="other_editors.html#emacs">Emacs</a>
<ul>
<li><a href="other_editors.html#eglot">Eglot</a></li>
<li><a href="other_editors.html#lsp-mode">LSP Mode</a></li>
</ul>
</li>
<li><a href="other_editors.html#vimneovim">Vim/Neovim</a>
<ul>
<li><a href="other_editors.html#coc-rust-analyzer">coc-rust-analyzer</a></li>
<li><a href="other_editors.html#languageclient-neovim">LanguageClient-neovim</a></li>
<li><a href="other_editors.html#youcompleteme">YouCompleteMe</a></li>
<li><a href="other_editors.html#ale">ALE</a></li>
<li><a href="other_editors.html#nvim-lsp">nvim-lsp</a></li>
<li><a href="other_editors.html#vim-lsp">vim-lsp</a></li>
</ul>
</li>
<li><a href="other_editors.html#sublime-text">Sublime Text</a>
<ul>
<li><a href="other_editors.html#sublime-text-4">Sublime Text 4:</a></li>
<li><a href="other_editors.html#sublime-text-3">Sublime Text 3:</a></li>
</ul>
</li>
<li><a href="other_editors.html#gnome-builder">GNOME Builder</a></li>
<li><a href="other_editors.html#eclipse-ide">Eclipse IDE</a></li>
<li><a href="other_editors.html#kate-text-editor">Kate Text Editor</a></li>
<li><a href="other_editors.html#juci">juCi++</a></li>
<li><a href="other_editors.html#kakoune">Kakoune</a></li>
<li><a href="other_editors.html#helix">Helix</a></li>
<li><a href="other_editors.html#visual-studio-2022">Visual Studio 2022</a>
<ul>
<li><a href="other_editors.html#vs-rustanalyzer">VS RustAnalyzer</a></li>
<li><a href="other_editors.html#sourcegear-rust">SourceGear Rust</a></li>
</ul>
</li>
<li><a href="other_editors.html#lapce">Lapce</a></li>
<li><a href="other_editors.html#zed">Zed</a></li>
</ul>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>To use <code>rust-analyzer</code>, you need to install and enable one of the two
popular LSP client implementations for Emacs,
<a href="https://github.com/joaotavora/eglot">Eglot</a> or <a href="https://github.com/emacs-lsp/lsp-mode">LSP
Mode</a>. Both enable
<code>rust-analyzer</code> by default in Rust buffers if it is available.</p>
<h3 id="eglot"><a class="header" href="#eglot">Eglot</a></h3>
<p>Eglot is the more minimalistic and lightweight LSP client for Emacs,
integrates well with existing Emacs functionality and is built into
Emacs starting from release 29.</p>
<p>After installing Eglot, e.g. via <code>M-x package-install</code> (not needed from
Emacs 29), you can enable it via the <code>M-x eglot</code> command or load it
automatically in <code>rust-mode</code> via</p>
<pre><code>(add-hook 'rust-mode-hook 'eglot-ensure)
</code></pre>
<p>To enable clippy, you will need to configure the initialization options
to pass the <code>check.command</code> setting.</p>
<pre><code>(add-to-list 'eglot-server-programs
             '((rust-ts-mode rust-mode) .
               ("rust-analyzer" :initializationOptions (:check (:command "clippy")))))
</code></pre>
<p>For more detailed instructions and options see the <a href="https://joaotavora.github.io/eglot">Eglot
manual</a> (also available from Emacs
via <code>M-x info</code>) and the <a href="https://github.com/joaotavora/eglot/blob/master/README.md">Eglot
readme</a>.</p>
<p>Eglot does not support the rust-analyzer extensions to the
language-server protocol and does not aim to do so in the future. The
<a href="https://github.com/nemethf/eglot-x#rust-analyzer-extensions">eglot-x</a>
package adds experimental support for those LSP extensions.</p>
<h3 id="lsp-mode"><a class="header" href="#lsp-mode">LSP Mode</a></h3>
<p>LSP-mode is the original LSP-client for emacs. Compared to Eglot it has
a larger codebase and supports more features, like LSP protocol
extensions. With extension packages like <a href="https://github.com/emacs-lsp/lsp-mode">LSP
UI</a> it offers a lot of visual
eyecandy. Further it integrates well with <a href="https://github.com/emacs-lsp/dap-mode">DAP
mode</a> for support of the Debug
Adapter Protocol.</p>
<p>You can install LSP-mode via <code>M-x package-install</code> and then run it via
the <code>M-x lsp</code> command or load it automatically in rust buffers with</p>
<pre><code>(add-hook 'rust-mode-hook 'lsp-deferred)
</code></pre>
<p>For more information on how to set up LSP mode and its extension package
see the instructions in the <a href="https://emacs-lsp.github.io/lsp-mode/page/installation">LSP mode
manual</a>. Also
see the <a href="https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/">rust-analyzer
section</a>
for <code>rust-analyzer</code> specific options and commands, which you can
optionally bind to keys.</p>
<p>Note the excellent
<a href="https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/">guide</a> from
<a href="https://github.com/rksm">@rksm</a> on how to set-up Emacs for Rust
development with LSP mode and several other packages.</p>
<h2 id="vimneovim"><a class="header" href="#vimneovim">Vim/Neovim</a></h2>
<p>There are several LSP client implementations for Vim or Neovim:</p>
<h3 id="coc-rust-analyzer"><a class="header" href="#coc-rust-analyzer">coc-rust-analyzer</a></h3>
<ol>
<li>
<p>Install coc.nvim by following the instructions at
<a href="https://github.com/neoclide/coc.nvim">coc.nvim</a> (Node.js required)</p>
</li>
<li>
<p>Run <code>:CocInstall coc-rust-analyzer</code> to install
<a href="https://github.com/fannheyward/coc-rust-analyzer">coc-rust-analyzer</a>,
this extension implements <em>most</em> of the features supported in the
VSCode extension:</p>
<ul>
<li>
<p>automatically install and upgrade stable/nightly releases</p>
</li>
<li>
<p>same configurations as VSCode extension,
<code>rust-analyzer.server.path</code>, <code>rust-analyzer.cargo.features</code> etc.</p>
</li>
<li>
<p>same commands too, <code>rust-analyzer.analyzerStatus</code>,
<code>rust-analyzer.ssr</code> etc.</p>
</li>
<li>
<p>inlay hints for variables and method chaining, <em>Neovim Only</em></p>
</li>
</ul>
</li>
</ol>
<p>Note: coc-rust-analyzer is capable of installing or updating the
rust-analyzer binary on its own.</p>
<p>Note: for code actions, use <code>coc-codeaction-cursor</code> and
<code>coc-codeaction-selected</code>; <code>coc-codeaction</code> and <code>coc-codeaction-line</code>
are unlikely to be useful.</p>
<h3 id="languageclient-neovim"><a class="header" href="#languageclient-neovim">LanguageClient-neovim</a></h3>
<ol>
<li>
<p>Install LanguageClient-neovim by following the instructions
<a href="https://github.com/autozimu/LanguageClient-neovim">here</a></p>
<ul>
<li>The GitHub project wiki has extra tips on configuration</li>
</ul>
</li>
<li>
<p>Configure by adding this to your Vim/Neovim config file (replacing
the existing Rust-specific line if it exists):</p>
<pre><code>let g:LanguageClient_serverCommands = {
\ 'rust': ['rust-analyzer'],
\ }
</code></pre>
</li>
</ol>
<h3 id="youcompleteme"><a class="header" href="#youcompleteme">YouCompleteMe</a></h3>
<p>Install YouCompleteMe by following the instructions
<a href="https://github.com/ycm-core/YouCompleteMe#installation">here</a>.</p>
<p>rust-analyzer is the default in ycm, it should work out of the box.</p>
<h3 id="ale"><a class="header" href="#ale">ALE</a></h3>
<p>To use the LSP server in <a href="https://github.com/dense-analysis/ale">ale</a>:</p>
<pre><code>let g:ale_linters = {'rust': ['analyzer']}
</code></pre>
<h3 id="nvim-lsp"><a class="header" href="#nvim-lsp">nvim-lsp</a></h3>
<p>Neovim 0.5 has built-in language server support. For a quick start
configuration of rust-analyzer, use
<a href="https://github.com/neovim/nvim-lspconfig#rust_analyzer">neovim/nvim-lspconfig</a>.
Once <code>neovim/nvim-lspconfig</code> is installed, use
<code>lua require'lspconfig'.rust_analyzer.setup({})</code> in your <code>init.vim</code>.</p>
<p>You can also pass LSP settings to the server:</p>
<pre><code class="language-lua">lua &lt;&lt; EOF
local lspconfig = require'lspconfig'

local on_attach = function(client)
    require'completion'.on_attach(client)
end

lspconfig.rust_analyzer.setup({
    on_attach = on_attach,
    settings = {
        ["rust-analyzer"] = {
            imports = {
                granularity = {
                    group = "module",
                },
                prefix = "self",
            },
            cargo = {
                buildScripts = {
                    enable = true,
                },
            },
            procMacro = {
                enable = true
            },
        }
    }
})
EOF
</code></pre>
<p>If you're running Neovim 0.10 or later, you can enable inlay hints via <code>on_attach</code>:</p>
<pre><code class="language-lua">lspconfig.rust_analyzer.setup({
    on_attach = function(client, bufnr)
        vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })
    end
})
</code></pre>
<p>Note that the hints are only visible after <code>rust-analyzer</code> has finished loading <strong>and</strong> you have to
edit the file to trigger a re-render.</p>
<p>See <a href="https://sharksforarms.dev/posts/neovim-rust/">https://sharksforarms.dev/posts/neovim-rust/</a> for more tips on
getting started.</p>
<p>Check out <a href="https://github.com/mrcjkb/rustaceanvim">https://github.com/mrcjkb/rustaceanvim</a> for a batteries
included rust-analyzer setup for Neovim.</p>
<h3 id="vim-lsp"><a class="header" href="#vim-lsp">vim-lsp</a></h3>
<p>vim-lsp is installed by following <a href="https://github.com/prabirshrestha/vim-lsp">the plugin
instructions</a>. It can be as
simple as adding this line to your <code>.vimrc</code>:</p>
<pre><code>Plug 'prabirshrestha/vim-lsp'
</code></pre>
<p>Next you need to register the <code>rust-analyzer</code> binary. If it is avim.lspvailable
in <code>$PATH</code>, you may want to add this to your <code>.vimrc</code>:</p>
<pre><code>if executable('rust-analyzer')
  au User lsp_setup call lsp#register_server({
        \   'name': 'Rust Language Server',
        \   'cmd': {server_info-&gt;['rust-analyzer']},
        \   'whitelist': ['rust'],
        \ })
endif
</code></pre>
<p>There is no dedicated UI for the server configuration, so you would need
to send any options as a value of the <code>initialization_options</code> field, as
described in the <a href="other_editors.html#configuration">Configuration</a> section. Here is an
example of how to enable the proc-macro support:</p>
<pre><code>if executable('rust-analyzer')
  au User lsp_setup call lsp#register_server({
        \   'name': 'Rust Language Server',
        \   'cmd': {server_info-&gt;['rust-analyzer']},
        \   'whitelist': ['rust'],
        \   'initialization_options': {
        \     'cargo': {
        \       'buildScripts': {
        \         'enable': v:true,
        \       },
        \     },
        \     'procMacro': {
        \       'enable': v:true,
        \     },
        \   },
        \ })
endif
</code></pre>
<h2 id="sublime-text"><a class="header" href="#sublime-text">Sublime Text</a></h2>
<h3 id="sublime-text-4"><a class="header" href="#sublime-text-4">Sublime Text 4:</a></h3>
<ul>
<li>Follow the instructions in
<a href="https://github.com/sublimelsp/LSP-rust-analyzer">LSP-rust-analyzer</a>.</li>
</ul>
<p>Install
<a href="https://packagecontrol.io/packages/LSP-file-watcher-chokidar">LSP-file-watcher-chokidar</a>
to enable file watching (<code>workspace/didChangeWatchedFiles</code>).</p>
<h3 id="sublime-text-3"><a class="header" href="#sublime-text-3">Sublime Text 3:</a></h3>
<ul>
<li>
<p>Install the <a href="https://packagecontrol.io/packages/LSP">LSP package</a>.</p>
</li>
<li>
<p>From the command palette, run <code>LSP: Enable Language Server Globally</code>
and select <code>rust-analyzer</code>.</p>
</li>
</ul>
<p>If it worked, you should see "rust-analyzer, Line X, Column Y" on the
left side of the status bar, and after waiting a bit, functionalities
like tooltips on hovering over variables should become available.</p>
<p>If you get an error saying <code>No such file or directory: 'rust-analyzer'</code>,
see the <a href="./rust_analyzer_binary.html">rust-analyzer binary installation</a> section.</p>
<h2 id="gnome-builder"><a class="header" href="#gnome-builder">GNOME Builder</a></h2>
<p>GNOME Builder 3.37.1 and newer has native <code>rust-analyzer</code> support. If
the LSP binary is not available, GNOME Builder can install it when
opening a Rust file.</p>
<h2 id="eclipse-ide"><a class="header" href="#eclipse-ide">Eclipse IDE</a></h2>
<p>Support for Rust development in the Eclipse IDE is provided by <a href="https://github.com/eclipse/corrosion">Eclipse
Corrosion</a>. If available in PATH
or in some standard location, <code>rust-analyzer</code> is detected and powers
editing of Rust files without further configuration. If <code>rust-analyzer</code>
is not detected, Corrosion will prompt you for configuration of your
Rust toolchain and language server with a link to the <em>Window &gt;
Preferences &gt; Rust</em> preference page; from here a button allows to
download and configure <code>rust-analyzer</code>, but you can also reference
another installation. You’ll need to close and reopen all .rs and Cargo
files, or to restart the IDE, for this change to take effect.</p>
<h2 id="kate-text-editor"><a class="header" href="#kate-text-editor">Kate Text Editor</a></h2>
<p>Support for the language server protocol is built into Kate through the
LSP plugin, which is included by default. It is preconfigured to use
rust-analyzer for Rust sources since Kate 21.12.</p>
<p>To change rust-analyzer config options, start from the following example
and put it into Kate’s "User Server Settings" tab (located under the LSP
Client settings):</p>
<pre><code class="language-json">{
    "servers": {
        "rust": {
            "initializationOptions": {
                "cachePriming": {
                    "enable": false
                },
                "check": {
                    "allTargets": false
                },
                "checkOnSave": false
            }
        }
    }
}
</code></pre>
<p>Then click on apply, and restart the LSP server for your rust project.</p>
<h2 id="juci"><a class="header" href="#juci">juCi++</a></h2>
<p><a href="https://gitlab.com/cppit/jucipp">juCi++</a> has built-in support for the
language server protocol, and since version 1.7.0 offers installation of
both Rust and rust-analyzer when opening a Rust file.</p>
<h2 id="kakoune"><a class="header" href="#kakoune">Kakoune</a></h2>
<p><a href="https://kakoune.org/">Kakoune</a> supports LSP with the help of
<a href="https://github.com/kak-lsp/kak-lsp"><code>kak-lsp</code></a>. Follow the
<a href="https://github.com/kak-lsp/kak-lsp#installation">instructions</a> to
install <code>kak-lsp</code>. To configure <code>kak-lsp</code>, refer to the <a href="https://github.com/kak-lsp/kak-lsp#configuring-kak-lsp">configuration
section</a> which
is basically about copying the <a href="https://github.com/kak-lsp/kak-lsp/blob/master/kak-lsp.toml">configuration
file</a> in
the right place (latest versions should use <code>rust-analyzer</code> by default).</p>
<p>Finally, you need to configure Kakoune to talk to <code>kak-lsp</code> (see <a href="https://github.com/kak-lsp/kak-lsp#usage">Usage
section</a>). A basic
configuration will only get you LSP but you can also activate inlay
diagnostics and auto-formatting on save. The following might help you
get all of this.</p>
<pre><code>eval %sh{kak-lsp --kakoune -s $kak_session}  # Not needed if you load it with plug.kak.
hook global WinSetOption filetype=rust %{
    # Enable LSP
    lsp-enable-window

    # Auto-formatting on save
    hook window BufWritePre .* lsp-formatting-sync

    # Configure inlay hints (only on save)
    hook window -group rust-inlay-hints BufWritePost .* rust-analyzer-inlay-hints
    hook -once -always window WinSetOption filetype=.* %{
        remove-hooks window rust-inlay-hints
    }
}
</code></pre>
<h2 id="helix"><a class="header" href="#helix">Helix</a></h2>
<p><a href="https://docs.helix-editor.com/">Helix</a> supports LSP by default.
However, it won’t install <code>rust-analyzer</code> automatically. You can follow
instructions for <a href="./rust_analyzer_binary.html">installing the rust-analyzer
binary</a>.</p>
<h2 id="visual-studio-2022"><a class="header" href="#visual-studio-2022">Visual Studio 2022</a></h2>
<p>There are multiple rust-analyzer extensions for Visual Studio 2022 on
Windows:</p>
<h3 id="vs-rustanalyzer"><a class="header" href="#vs-rustanalyzer">VS RustAnalyzer</a></h3>
<p>(License: GPL)</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=cchharris.vsrustanalyzer">Visual Studio
Marketplace</a></p>
<p><a href="https://github.com/cchharris/VS-RustAnalyzer">GitHub</a></p>
<h3 id="sourcegear-rust"><a class="header" href="#sourcegear-rust">SourceGear Rust</a></h3>
<p>(License: closed source)</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=SourceGear.SourceGearRust">Visual Studio
Marketplace</a></p>
<p><a href="https://github.com/sourcegear/rust-vs-extension">GitHub (docs, issues,
discussions)</a></p>
<ul>
<li>
<p>Free (no-cost)</p>
</li>
<li>
<p>Supports all editions of Visual Studio 2022 on Windows: Community,
Professional, or Enterprise</p>
</li>
</ul>
<h2 id="lapce"><a class="header" href="#lapce">Lapce</a></h2>
<p><a href="https://lapce.dev/">Lapce</a> has a Rust plugin which you can install
directly. Unfortunately, it downloads an old version of <code>rust-analyzer</code>,
but you can set the server path under Settings.</p>
<h2 id="zed"><a class="header" href="#zed">Zed</a></h2>
<p><a href="https://zed.dev">Zed</a> has native <code>rust-analyzer</code> support. If the
rust-analyzer binary is not available, Zed can install it when opening
a Rust file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>First, search the <a href="faq.html">troubleshooting FAQ</a>. If your problem appears
there (and the proposed solution works for you), great! Otherwise, read on.</p>
<p>Start with looking at the rust-analyzer version. Try <strong>rust-analyzer:
Show RA Version</strong> in VS Code (using <strong>Command Palette</strong> feature
typically activated by Ctrl+Shift+P) or <code>rust-analyzer --version</code> in the
command line. If the date is more than a week ago, it’s better to update
rust-analyzer version.</p>
<p>The next thing to check would be panic messages in rust-analyzer’s log.
Log messages are printed to stderr, in VS Code you can see them in the
<code>Output &gt; Rust Analyzer Language Server</code> tab of the panel. To see more
logs, set the <code>RA_LOG=info</code> environment variable, this can be done
either by setting the environment variable manually or by using
<code>rust-analyzer.server.extraEnv</code>, note that both of these approaches
require the server to be restarted.</p>
<p>To fully capture LSP messages between the editor and the server, run
the <code>rust-analyzer: Toggle LSP Logs</code> command and check <code>Output &gt; Rust Analyzer Language Server Trace</code>.</p>
<p>The root cause for many "nothing works" problems is that rust-analyzer
fails to understand the project structure. To debug that, first note the
<code>rust-analyzer</code> section in the status bar. If it has an error icon and
red, that’s the problem (hover will have somewhat helpful error
message). <strong>rust-analyzer: Status</strong> prints dependency information for
the current file. Finally, <code>RA_LOG=project_model=debug</code> enables verbose
logs during project loading.</p>
<p>If rust-analyzer outright crashes, try running
<code>rust-analyzer analysis-stats /path/to/project/directory/</code> on the
command line. This command type checks the whole project in batch mode
bypassing LSP machinery.</p>
<p>When filing issues, it is useful (but not necessary) to try to minimize
examples. An ideal bug reproduction looks like this:</p>
<pre><code class="language-shell">$ git clone https://github.com/username/repo.git &amp;&amp; cd repo &amp;&amp; git switch --detach commit-hash
$ rust-analyzer --version
rust-analyzer dd12184e4 2021-05-08 dev
$ rust-analyzer analysis-stats .
💀 💀 💀
</code></pre>
<p>It is especially useful when the <code>repo</code> doesn’t use external crates or
the standard library.</p>
<p>If you want to go as far as to modify the source code to debug the
problem, be sure to take a look at the <a href="contributing/index.html">contribution guide</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-faq"><a class="header" href="#troubleshooting-faq">Troubleshooting FAQ</a></h1>
<h3 id="i-see-a-warning-variable-none-should-have-snake_case-name-eg-none"><a class="header" href="#i-see-a-warning-variable-none-should-have-snake_case-name-eg-none">I see a warning "Variable <code>None</code> should have snake_case name, e.g. <code>none</code>"</a></h3>
<p>rust-analyzer fails to resolve <code>None</code>, and thinks you are binding to a variable
named <code>None</code>. That's usually a sign of a corrupted sysroot. Try removing and re-installing
it: <code>rustup component remove rust-src</code> then <code>rustup component install rust-src</code>.</p>
<h3 id="rust-analyzer-and-cargo-compete-over-the-build-lock"><a class="header" href="#rust-analyzer-and-cargo-compete-over-the-build-lock">Rust Analyzer and Cargo compete over the build lock</a></h3>
<p>Rust Analyzer invokes Cargo in the background, and it can thus block manually executed
<code>cargo</code> commands from making progress (or vice-versa). In some cases, this can also cause
unnecessary recompilations caused by cache thrashing. To avoid this, you can configure
Rust Analyzer to use a <a href="./configuration.html#cargo.targetDir">different target directory</a>.
This will allow both the IDE and Cargo to make progress independently, at the cost of
increased disk space usage caused by the duplicated artifact directories.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p><strong>Source:</strong>
<a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/rust-analyzer/src/config.rs">config.rs</a></p>
<p>The <a href="./installation.html">Installation</a> section contains details on
configuration for some of the editors. In general <code>rust-analyzer</code> is
configured via LSP messages, which means that it’s up to the editor to
decide on the exact format and location of configuration files.</p>
<p>Some clients, such as <a href="./vs_code.html">VS Code</a> or <a href="./other_editors.html#coc-rust-analyzer">COC plugin in
Vim</a> provide <code>rust-analyzer</code> specific configuration
UIs. Others may require you to know a bit more about the interaction
with <code>rust-analyzer</code>.</p>
<p>For the latter category, it might help to know that the initial
configuration is specified as a value of the <code>initializationOptions</code>
field of the <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#initialize"><code>InitializeParams</code> message, in the LSP
protocol</a>.
The spec says that the field type is <code>any?</code>, but <code>rust-analyzer</code> is
looking for a JSON object that is constructed using settings from the
list below. Name of the setting, ignoring the <code>rust-analyzer.</code> prefix,
is used as a path, and value of the setting becomes the JSON property
value.</p>
<p>For example, a very common configuration is to enable proc-macro
support, can be achieved by sending this JSON:</p>
<pre><code>{
  "cargo": {
    "buildScripts": {
      "enable": true,
    },
  },
  "procMacro": {
    "enable": true,
  }
}
</code></pre>
<p>Please consult your editor’s documentation to learn more about how to
configure <a href="https://microsoft.github.io/language-server-protocol/">LSP
servers</a>.</p>
<p>To verify which configuration is actually used by <code>rust-analyzer</code>, set
<code>RA_LOG</code> environment variable to <code>rust_analyzer=info</code> and look for
config-related messages. Logs should show both the JSON that
<code>rust-analyzer</code> sees as well as the updated config.</p>
<p>(Work in progress:) It is also possible to place configuration in a
<code>rust-analyzer.toml</code> file. It should be located in the project root or in your
user configuration directory (e.g. <code>~/.config/rust-analyzer/</code>). This is a work in
progress, many configuration options aren't supported yet.</p>
<p>This is the list of config options <code>rust-analyzer</code> supports:</p>
<h2 id="assist.emitMustUse"><a class="header" href="#assist.emitMustUse">rust-analyzer.assist.emitMustUse</a></h2>
<p>Default: <code>false</code></p>
<p>Insert #[must_use] when generating <code>as_</code> methods for enum variants.</p>
<h2 id="assist.expressionFillDefault"><a class="header" href="#assist.expressionFillDefault">rust-analyzer.assist.expressionFillDefault</a></h2>
<p>Default: <code>"todo"</code></p>
<p>Placeholder expression to use for missing expressions in assists.</p>
<h2 id="assist.preferSelf"><a class="header" href="#assist.preferSelf">rust-analyzer.assist.preferSelf</a></h2>
<p>Default: <code>false</code></p>
<p>Prefer to use <code>Self</code> over the type name when inserting a type (e.g. in "fill match arms" assist).</p>
<h2 id="assist.termSearch.borrowcheck"><a class="header" href="#assist.termSearch.borrowcheck">rust-analyzer.assist.termSearch.borrowcheck</a></h2>
<p>Default: <code>true</code></p>
<p>Enable borrow checking for term search code assists. If set to false, also there will be
more suggestions, but some of them may not borrow-check.</p>
<h2 id="assist.termSearch.fuel"><a class="header" href="#assist.termSearch.fuel">rust-analyzer.assist.termSearch.fuel</a></h2>
<p>Default: <code>1800</code></p>
<p>Term search fuel in "units of work" for assists (Defaults to 1800).</p>
<h2 id="cachePriming.enable"><a class="header" href="#cachePriming.enable">rust-analyzer.cachePriming.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Warm up caches on project load.</p>
<h2 id="cachePriming.numThreads"><a class="header" href="#cachePriming.numThreads">rust-analyzer.cachePriming.numThreads</a></h2>
<p>Default: <code>"physical"</code></p>
<p>How many worker threads to handle priming caches. The default <code>0</code> means to pick
automatically.</p>
<h2 id="cargo.allTargets"><a class="header" href="#cargo.allTargets">rust-analyzer.cargo.allTargets</a></h2>
<p>Default: <code>true</code></p>
<p>Pass <code>--all-targets</code> to cargo invocation.</p>
<h2 id="cargo.autoreload"><a class="header" href="#cargo.autoreload">rust-analyzer.cargo.autoreload</a></h2>
<p>Default: <code>true</code></p>
<p>Automatically refresh project info via <code>cargo metadata</code> on
<code>Cargo.toml</code> or <code>.cargo/config.toml</code> changes.</p>
<h2 id="cargo.buildScripts.enable"><a class="header" href="#cargo.buildScripts.enable">rust-analyzer.cargo.buildScripts.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Run build scripts (<code>build.rs</code>) for more precise code analysis.</p>
<h2 id="cargo.buildScripts.invocationStrategy"><a class="header" href="#cargo.buildScripts.invocationStrategy">rust-analyzer.cargo.buildScripts.invocationStrategy</a></h2>
<p>Default: <code>"per_workspace"</code></p>
<p>Specifies the invocation strategy to use when running the build scripts command.
If <code>per_workspace</code> is set, the command will be executed for each Rust workspace with the
workspace as the working directory.
If <code>once</code> is set, the command will be executed once with the opened project as the
working directory.
This config only has an effect when <code>#rust-analyzer.cargo.buildScripts.overrideCommand#</code>
is set.</p>
<h2 id="cargo.buildScripts.overrideCommand"><a class="header" href="#cargo.buildScripts.overrideCommand">rust-analyzer.cargo.buildScripts.overrideCommand</a></h2>
<p>Default: <code>null</code></p>
<p>Override the command rust-analyzer uses to run build scripts and
build procedural macros. The command is required to output json
and should therefore include <code>--message-format=json</code> or a similar
option.</p>
<p>If there are multiple linked projects/workspaces, this command is invoked for
each of them, with the working directory being the workspace root
(i.e., the folder containing the <code>Cargo.toml</code>). This can be overwritten
by changing <code>#rust-analyzer.cargo.buildScripts.invocationStrategy#</code>.</p>
<p>By default, a cargo invocation will be constructed for the configured
targets and features, with the following base command line:</p>
<pre><code class="language-bash">cargo check --quiet --workspace --message-format=json --all-targets --keep-going
</code></pre>
<p>Note: The option must be specified as an array of command line arguments, with
the first argument being the name of the command to run.</p>
<h2 id="cargo.buildScripts.rebuildOnSave"><a class="header" href="#cargo.buildScripts.rebuildOnSave">rust-analyzer.cargo.buildScripts.rebuildOnSave</a></h2>
<p>Default: <code>true</code></p>
<p>Rerun proc-macros building/build-scripts running when proc-macro
or build-script sources change and are saved.</p>
<h2 id="cargo.buildScripts.useRustcWrapper"><a class="header" href="#cargo.buildScripts.useRustcWrapper">rust-analyzer.cargo.buildScripts.useRustcWrapper</a></h2>
<p>Default: <code>true</code></p>
<p>Use <code>RUSTC_WRAPPER=rust-analyzer</code> when running build scripts to
avoid checking unnecessary things.</p>
<h2 id="cargo.cfgs"><a class="header" href="#cargo.cfgs">rust-analyzer.cargo.cfgs</a></h2>
<p>Default:</p>
<pre><code class="language-json">[
  "debug_assertions",
  "miri"
]
</code></pre>
<p>List of cfg options to enable with the given values.</p>
<p>To enable a name without a value, use <code>"key"</code>.
To enable a name with a value, use <code>"key=value"</code>.
To disable, prefix the entry with a <code>!</code>.</p>
<h2 id="cargo.extraArgs"><a class="header" href="#cargo.extraArgs">rust-analyzer.cargo.extraArgs</a></h2>
<p>Default: <code>[]</code></p>
<p>Extra arguments that are passed to every cargo invocation.</p>
<h2 id="cargo.extraEnv"><a class="header" href="#cargo.extraEnv">rust-analyzer.cargo.extraEnv</a></h2>
<p>Default: <code>{}</code></p>
<p>Extra environment variables that will be set when running cargo, rustc
or other commands within the workspace. Useful for setting RUSTFLAGS.</p>
<h2 id="cargo.features"><a class="header" href="#cargo.features">rust-analyzer.cargo.features</a></h2>
<p>Default: <code>[]</code></p>
<p>List of features to activate.</p>
<p>Set this to <code>"all"</code> to pass <code>--all-features</code> to cargo.</p>
<h2 id="cargo.noDefaultFeatures"><a class="header" href="#cargo.noDefaultFeatures">rust-analyzer.cargo.noDefaultFeatures</a></h2>
<p>Default: <code>false</code></p>
<p>Whether to pass <code>--no-default-features</code> to cargo.</p>
<h2 id="cargo.noDeps"><a class="header" href="#cargo.noDeps">rust-analyzer.cargo.noDeps</a></h2>
<p>Default: <code>false</code></p>
<p>Whether to skip fetching dependencies. If set to "true", the analysis is performed
entirely offline, and Cargo metadata for dependencies is not fetched.</p>
<h2 id="cargo.sysroot"><a class="header" href="#cargo.sysroot">rust-analyzer.cargo.sysroot</a></h2>
<p>Default: <code>"discover"</code></p>
<p>Relative path to the sysroot, or "discover" to try to automatically find it via
"rustc --print sysroot".</p>
<p>Unsetting this disables sysroot loading.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<h2 id="cargo.sysrootSrc"><a class="header" href="#cargo.sysrootSrc">rust-analyzer.cargo.sysrootSrc</a></h2>
<p>Default: <code>null</code></p>
<p>Relative path to the sysroot library sources. If left unset, this will default to
<code>{cargo.sysroot}/lib/rustlib/src/rust/library</code>.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<h2 id="cargo.target"><a class="header" href="#cargo.target">rust-analyzer.cargo.target</a></h2>
<p>Default: <code>null</code></p>
<p>Compilation target override (target tuple).</p>
<h2 id="cargo.targetDir"><a class="header" href="#cargo.targetDir">rust-analyzer.cargo.targetDir</a></h2>
<p>Default: <code>null</code></p>
<p>Optional path to a rust-analyzer specific target directory.
This prevents rust-analyzer's <code>cargo check</code> and initial build-script and proc-macro
building from locking the <code>Cargo.lock</code> at the expense of duplicating build artifacts.</p>
<p>Set to <code>true</code> to use a subdirectory of the existing target directory or
set to a path relative to the workspace to use that path.</p>
<h2 id="cfg.setTest"><a class="header" href="#cfg.setTest">rust-analyzer.cfg.setTest</a></h2>
<p>Default: <code>true</code></p>
<p>Set <code>cfg(test)</code> for local crates. Defaults to true.</p>
<h2 id="checkOnSave"><a class="header" href="#checkOnSave">rust-analyzer.checkOnSave</a></h2>
<p>Default: <code>true</code></p>
<p>Run the check command for diagnostics on save.</p>
<h2 id="check.allTargets"><a class="header" href="#check.allTargets">rust-analyzer.check.allTargets</a></h2>
<p>Default: <code>null</code></p>
<p>Check all targets and tests (<code>--all-targets</code>). Defaults to
<code>#rust-analyzer.cargo.allTargets#</code>.</p>
<h2 id="check.command"><a class="header" href="#check.command">rust-analyzer.check.command</a></h2>
<p>Default: <code>"check"</code></p>
<p>Cargo command to use for <code>cargo check</code>.</p>
<h2 id="check.extraArgs"><a class="header" href="#check.extraArgs">rust-analyzer.check.extraArgs</a></h2>
<p>Default: <code>[]</code></p>
<p>Extra arguments for <code>cargo check</code>.</p>
<h2 id="check.extraEnv"><a class="header" href="#check.extraEnv">rust-analyzer.check.extraEnv</a></h2>
<p>Default: <code>{}</code></p>
<p>Extra environment variables that will be set when running <code>cargo check</code>.
Extends <code>#rust-analyzer.cargo.extraEnv#</code>.</p>
<h2 id="check.features"><a class="header" href="#check.features">rust-analyzer.check.features</a></h2>
<p>Default: <code>null</code></p>
<p>List of features to activate. Defaults to
<code>#rust-analyzer.cargo.features#</code>.</p>
<p>Set to <code>"all"</code> to pass <code>--all-features</code> to Cargo.</p>
<h2 id="check.ignore"><a class="header" href="#check.ignore">rust-analyzer.check.ignore</a></h2>
<p>Default: <code>[]</code></p>
<p>List of <code>cargo check</code> (or other command specified in <code>check.command</code>) diagnostics to ignore.</p>
<p>For example for <code>cargo check</code>: <code>dead_code</code>, <code>unused_imports</code>, <code>unused_variables</code>,...</p>
<h2 id="check.invocationStrategy"><a class="header" href="#check.invocationStrategy">rust-analyzer.check.invocationStrategy</a></h2>
<p>Default: <code>"per_workspace"</code></p>
<p>Specifies the invocation strategy to use when running the check command.
If <code>per_workspace</code> is set, the command will be executed for each workspace.
If <code>once</code> is set, the command will be executed once.
This config only has an effect when <code>#rust-analyzer.check.overrideCommand#</code>
is set.</p>
<h2 id="check.noDefaultFeatures"><a class="header" href="#check.noDefaultFeatures">rust-analyzer.check.noDefaultFeatures</a></h2>
<p>Default: <code>null</code></p>
<p>Whether to pass <code>--no-default-features</code> to Cargo. Defaults to
<code>#rust-analyzer.cargo.noDefaultFeatures#</code>.</p>
<h2 id="check.overrideCommand"><a class="header" href="#check.overrideCommand">rust-analyzer.check.overrideCommand</a></h2>
<p>Default: <code>null</code></p>
<p>Override the command rust-analyzer uses instead of <code>cargo check</code> for
diagnostics on save. The command is required to output json and
should therefore include <code>--message-format=json</code> or a similar option
(if your client supports the <code>colorDiagnosticOutput</code> experimental
capability, you can use <code>--message-format=json-diagnostic-rendered-ansi</code>).</p>
<p>If you're changing this because you're using some tool wrapping
Cargo, you might also want to change
<code>#rust-analyzer.cargo.buildScripts.overrideCommand#</code>.</p>
<p>If there are multiple linked projects/workspaces, this command is invoked for
each of them, with the working directory being the workspace root
(i.e., the folder containing the <code>Cargo.toml</code>). This can be overwritten
by changing <code>#rust-analyzer.check.invocationStrategy#</code>.</p>
<p>If <code>$saved_file</code> is part of the command, rust-analyzer will pass
the absolute path of the saved file to the provided command. This is
intended to be used with non-Cargo build systems.
Note that <code>$saved_file</code> is experimental and may be removed in the future.</p>
<p>An example command would be:</p>
<pre><code class="language-bash">cargo check --workspace --message-format=json --all-targets
</code></pre>
<p>Note: The option must be specified as an array of command line arguments, with
the first argument being the name of the command to run.</p>
<h2 id="check.targets"><a class="header" href="#check.targets">rust-analyzer.check.targets</a></h2>
<p>Default: <code>null</code></p>
<p>Check for specific targets. Defaults to <code>#rust-analyzer.cargo.target#</code> if empty.</p>
<p>Can be a single target, e.g. <code>"x86_64-unknown-linux-gnu"</code> or a list of targets, e.g.
<code>["aarch64-apple-darwin", "x86_64-apple-darwin"]</code>.</p>
<p>Aliased as <code>"checkOnSave.targets"</code>.</p>
<h2 id="check.workspace"><a class="header" href="#check.workspace">rust-analyzer.check.workspace</a></h2>
<p>Default: <code>true</code></p>
<p>Whether <code>--workspace</code> should be passed to <code>cargo check</code>.
If false, <code>-p &lt;package&gt;</code> will be passed instead if applicable. In case it is not, no
check will be performed.</p>
<h2 id="completion.addSemicolonToUnit"><a class="header" href="#completion.addSemicolonToUnit">rust-analyzer.completion.addSemicolonToUnit</a></h2>
<p>Default: <code>true</code></p>
<p>Automatically add a semicolon when completing unit-returning functions.</p>
<p>In <code>match</code> arms it completes a comma instead.</p>
<h2 id="completion.autoAwait.enable"><a class="header" href="#completion.autoAwait.enable">rust-analyzer.completion.autoAwait.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show method calls and field accesses completions with <code>await</code> prefixed to them when
completing on a future.</p>
<h2 id="completion.autoIter.enable"><a class="header" href="#completion.autoIter.enable">rust-analyzer.completion.autoIter.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show method call completions with <code>iter()</code> or <code>into_iter()</code> prefixed to them when
completing on a type that has them.</p>
<h2 id="completion.autoimport.enable"><a class="header" href="#completion.autoimport.enable">rust-analyzer.completion.autoimport.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show completions that automatically add imports when completed.</p>
<p>Note that your client must specify the <code>additionalTextEdits</code> LSP client capability to
truly have this feature enabled.</p>
<h2 id="completion.autoimport.exclude"><a class="header" href="#completion.autoimport.exclude">rust-analyzer.completion.autoimport.exclude</a></h2>
<p>Default:</p>
<pre><code class="language-json">[
  {
    "path": "core::borrow::Borrow",
    "type": "methods"
  },
  {
    "path": "core::borrow::BorrowMut",
    "type": "methods"
  }
]
</code></pre>
<p>A list of full paths to items to exclude from auto-importing completions.</p>
<p>Traits in this list won't have their methods suggested in completions unless the trait
is in scope.</p>
<p>You can either specify a string path which defaults to type "always" or use the more
verbose form <code>{ "path": "path::to::item", type: "always" }</code>.</p>
<p>For traits the type "methods" can be used to only exclude the methods but not the trait
itself.</p>
<p>This setting also inherits <code>#rust-analyzer.completion.excludeTraits#</code>.</p>
<h2 id="completion.autoself.enable"><a class="header" href="#completion.autoself.enable">rust-analyzer.completion.autoself.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show method calls and field access completions with <code>self</code> prefixed to them when
inside a method.</p>
<h2 id="completion.callable.snippets"><a class="header" href="#completion.callable.snippets">rust-analyzer.completion.callable.snippets</a></h2>
<p>Default: <code>"fill_arguments"</code></p>
<p>Add parenthesis and argument snippets when completing function.</p>
<h2 id="completion.excludeTraits"><a class="header" href="#completion.excludeTraits">rust-analyzer.completion.excludeTraits</a></h2>
<p>Default: <code>[]</code></p>
<p>A list of full paths to traits whose methods to exclude from completion.</p>
<p>Methods from these traits won't be completed, even if the trait is in scope. However,
they will still be suggested on expressions whose type is <code>dyn Trait</code>, <code>impl Trait</code> or
<code>T where T: Trait</code>.</p>
<p>Note that the trait themselves can still be completed.</p>
<h2 id="completion.fullFunctionSignatures.enable"><a class="header" href="#completion.fullFunctionSignatures.enable">rust-analyzer.completion.fullFunctionSignatures.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show full function / method signatures in completion docs.</p>
<h2 id="completion.hideDeprecated"><a class="header" href="#completion.hideDeprecated">rust-analyzer.completion.hideDeprecated</a></h2>
<p>Default: <code>false</code></p>
<p>Omit deprecated items from completions. By default they are marked as deprecated but not
hidden.</p>
<h2 id="completion.limit"><a class="header" href="#completion.limit">rust-analyzer.completion.limit</a></h2>
<p>Default: <code>null</code></p>
<p>Maximum number of completions to return. If <code>None</code>, the limit is infinite.</p>
<h2 id="completion.postfix.enable"><a class="header" href="#completion.postfix.enable">rust-analyzer.completion.postfix.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show postfix snippets like <code>dbg</code>, <code>if</code>, <code>not</code>, etc.</p>
<h2 id="completion.privateEditable.enable"><a class="header" href="#completion.privateEditable.enable">rust-analyzer.completion.privateEditable.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show completions of private items and fields that are defined in the current workspace
even if they are not visible at the current position.</p>
<h2 id="completion.snippets.custom"><a class="header" href="#completion.snippets.custom">rust-analyzer.completion.snippets.custom</a></h2>
<p>Default:</p>
<pre><code class="language-json">{
  "Ok": {
    "postfix": "ok",
    "body": "Ok(${receiver})",
    "description": "Wrap the expression in a `Result::Ok`",
    "scope": "expr"
  },
  "Box::pin": {
    "postfix": "pinbox",
    "body": "Box::pin(${receiver})",
    "requires": "std::boxed::Box",
    "description": "Put the expression into a pinned `Box`",
    "scope": "expr"
  },
  "Arc::new": {
    "postfix": "arc",
    "body": "Arc::new(${receiver})",
    "requires": "std::sync::Arc",
    "description": "Put the expression into an `Arc`",
    "scope": "expr"
  },
  "Some": {
    "postfix": "some",
    "body": "Some(${receiver})",
    "description": "Wrap the expression in an `Option::Some`",
    "scope": "expr"
  },
  "Err": {
    "postfix": "err",
    "body": "Err(${receiver})",
    "description": "Wrap the expression in a `Result::Err`",
    "scope": "expr"
  },
  "Rc::new": {
    "postfix": "rc",
    "body": "Rc::new(${receiver})",
    "requires": "std::rc::Rc",
    "description": "Put the expression into an `Rc`",
    "scope": "expr"
  }
}
</code></pre>
<p>Custom completion snippets.</p>
<h2 id="completion.termSearch.enable"><a class="header" href="#completion.termSearch.enable">rust-analyzer.completion.termSearch.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Enable term search based snippets like <code>Some(foo.bar().baz())</code>.</p>
<h2 id="completion.termSearch.fuel"><a class="header" href="#completion.termSearch.fuel">rust-analyzer.completion.termSearch.fuel</a></h2>
<p>Default: <code>1000</code></p>
<p>Term search fuel in "units of work" for autocompletion (Defaults to 1000).</p>
<h2 id="diagnostics.disabled"><a class="header" href="#diagnostics.disabled">rust-analyzer.diagnostics.disabled</a></h2>
<p>Default: <code>[]</code></p>
<p>List of rust-analyzer diagnostics to disable.</p>
<h2 id="diagnostics.enable"><a class="header" href="#diagnostics.enable">rust-analyzer.diagnostics.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show native rust-analyzer diagnostics.</p>
<h2 id="diagnostics.experimental.enable"><a class="header" href="#diagnostics.experimental.enable">rust-analyzer.diagnostics.experimental.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show experimental rust-analyzer diagnostics that might have more false positives than
usual.</p>
<h2 id="diagnostics.remapPrefix"><a class="header" href="#diagnostics.remapPrefix">rust-analyzer.diagnostics.remapPrefix</a></h2>
<p>Default: <code>{}</code></p>
<p>Map of prefixes to be substituted when parsing diagnostic file paths. This should be the
reverse mapping of what is passed to <code>rustc</code> as <code>--remap-path-prefix</code>.</p>
<h2 id="diagnostics.styleLints.enable"><a class="header" href="#diagnostics.styleLints.enable">rust-analyzer.diagnostics.styleLints.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Run additional style lints.</p>
<h2 id="diagnostics.warningsAsHint"><a class="header" href="#diagnostics.warningsAsHint">rust-analyzer.diagnostics.warningsAsHint</a></h2>
<p>Default: <code>[]</code></p>
<p>List of warnings that should be displayed with hint severity.</p>
<p>The warnings will be indicated by faded text or three dots in code and will not show up
in the <code>Problems Panel</code>.</p>
<h2 id="diagnostics.warningsAsInfo"><a class="header" href="#diagnostics.warningsAsInfo">rust-analyzer.diagnostics.warningsAsInfo</a></h2>
<p>Default: <code>[]</code></p>
<p>List of warnings that should be displayed with info severity.</p>
<p>The warnings will be indicated by a blue squiggly underline in code and a blue icon in
the <code>Problems Panel</code>.</p>
<h2 id="document.symbol.search.excludeLocals"><a class="header" href="#document.symbol.search.excludeLocals">rust-analyzer.document.symbol.search.excludeLocals</a></h2>
<p>Default: <code>true</code></p>
<p>Exclude all locals from document symbol search.</p>
<h2 id="files.exclude"><a class="header" href="#files.exclude">rust-analyzer.files.exclude</a></h2>
<p>Default: <code>[]</code></p>
<p>List of files to ignore</p>
<p>These paths (file/directories) will be ignored by rust-analyzer. They are relative to
the workspace root, and globs are not supported. You may also need to add the folders to
Code's <code>files.watcherExclude</code>.</p>
<h2 id="files.watcher"><a class="header" href="#files.watcher">rust-analyzer.files.watcher</a></h2>
<p>Default: <code>"client"</code></p>
<p>Controls file watching implementation.</p>
<h2 id="gotoImplementations.filterAdjacentDerives"><a class="header" href="#gotoImplementations.filterAdjacentDerives">rust-analyzer.gotoImplementations.filterAdjacentDerives</a></h2>
<p>Default: <code>false</code></p>
<p>If this is <code>true</code>, when "Goto Implementations" and in "Implementations" lens, are triggered on a <code>struct</code> or <code>enum</code> or <code>union</code>, we filter out trait implementations that originate from <code>derive</code>s above the type.</p>
<h2 id="highlightRelated.branchExitPoints.enable"><a class="header" href="#highlightRelated.branchExitPoints.enable">rust-analyzer.highlightRelated.branchExitPoints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight related return values while the cursor is on any <code>match</code>, <code>if</code>, or match arm
arrow (<code>=&gt;</code>).</p>
<h2 id="highlightRelated.breakPoints.enable"><a class="header" href="#highlightRelated.breakPoints.enable">rust-analyzer.highlightRelated.breakPoints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight related references while the cursor is on <code>break</code>, <code>loop</code>, <code>while</code>, or <code>for</code>
keywords.</p>
<h2 id="highlightRelated.closureCaptures.enable"><a class="header" href="#highlightRelated.closureCaptures.enable">rust-analyzer.highlightRelated.closureCaptures.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight all captures of a closure while the cursor is on the <code>|</code> or move keyword of a closure.</p>
<h2 id="highlightRelated.exitPoints.enable"><a class="header" href="#highlightRelated.exitPoints.enable">rust-analyzer.highlightRelated.exitPoints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight all exit points while the cursor is on any <code>return</code>, <code>?</code>, <code>fn</code>, or return type
arrow (<code>-&gt;</code>).</p>
<h2 id="highlightRelated.references.enable"><a class="header" href="#highlightRelated.references.enable">rust-analyzer.highlightRelated.references.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight related references while the cursor is on any identifier.</p>
<h2 id="highlightRelated.yieldPoints.enable"><a class="header" href="#highlightRelated.yieldPoints.enable">rust-analyzer.highlightRelated.yieldPoints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Highlight all break points for a loop or block context while the cursor is on any
<code>async</code> or <code>await</code> keywords.</p>
<h2 id="hover.actions.debug.enable"><a class="header" href="#hover.actions.debug.enable">rust-analyzer.hover.actions.debug.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Debug</code> action. Only applies when <code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<h2 id="hover.actions.enable"><a class="header" href="#hover.actions.enable">rust-analyzer.hover.actions.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show HoverActions in Rust files.</p>
<h2 id="hover.actions.gotoTypeDef.enable"><a class="header" href="#hover.actions.gotoTypeDef.enable">rust-analyzer.hover.actions.gotoTypeDef.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Go to Type Definition</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<h2 id="hover.actions.implementations.enable"><a class="header" href="#hover.actions.implementations.enable">rust-analyzer.hover.actions.implementations.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Implementations</code> action. Only applies when <code>#rust-analyzer.hover.actions.enable#</code>
is set.</p>
<h2 id="hover.actions.references.enable"><a class="header" href="#hover.actions.references.enable">rust-analyzer.hover.actions.references.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show <code>References</code> action. Only applies when <code>#rust-analyzer.hover.actions.enable#</code> is
set.</p>
<h2 id="hover.actions.run.enable"><a class="header" href="#hover.actions.run.enable">rust-analyzer.hover.actions.run.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Run</code> action. Only applies when <code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<h2 id="hover.actions.updateTest.enable"><a class="header" href="#hover.actions.updateTest.enable">rust-analyzer.hover.actions.updateTest.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Update Test</code> action. Only applies when <code>#rust-analyzer.hover.actions.enable#</code> and
<code>#rust-analyzer.hover.actions.run.enable#</code> are set.</p>
<h2 id="hover.documentation.enable"><a class="header" href="#hover.documentation.enable">rust-analyzer.hover.documentation.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show documentation on hover.</p>
<h2 id="hover.documentation.keywords.enable"><a class="header" href="#hover.documentation.keywords.enable">rust-analyzer.hover.documentation.keywords.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show keyword hover popups. Only applies when
<code>#rust-analyzer.hover.documentation.enable#</code> is set.</p>
<h2 id="hover.dropGlue.enable"><a class="header" href="#hover.dropGlue.enable">rust-analyzer.hover.dropGlue.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show drop glue information on hover.</p>
<h2 id="hover.links.enable"><a class="header" href="#hover.links.enable">rust-analyzer.hover.links.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Use markdown syntax for links on hover.</p>
<h2 id="hover.maxSubstitutionLength"><a class="header" href="#hover.maxSubstitutionLength">rust-analyzer.hover.maxSubstitutionLength</a></h2>
<p>Default: <code>20</code></p>
<p>Show what types are used as generic arguments in calls etc. on hover, and limit the max
length to show such types, beyond which they will be shown with ellipsis.</p>
<p>This can take three values: <code>null</code> means "unlimited", the string <code>"hide"</code> means to not
show generic substitutions at all, and a number means to limit them to X characters.</p>
<p>The default is 20 characters.</p>
<h2 id="hover.memoryLayout.alignment"><a class="header" href="#hover.memoryLayout.alignment">rust-analyzer.hover.memoryLayout.alignment</a></h2>
<p>Default: <code>"hexadecimal"</code></p>
<p>How to render the align information in a memory layout hover.</p>
<h2 id="hover.memoryLayout.enable"><a class="header" href="#hover.memoryLayout.enable">rust-analyzer.hover.memoryLayout.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show memory layout data on hover.</p>
<h2 id="hover.memoryLayout.niches"><a class="header" href="#hover.memoryLayout.niches">rust-analyzer.hover.memoryLayout.niches</a></h2>
<p>Default: <code>false</code></p>
<p>How to render the niche information in a memory layout hover.</p>
<h2 id="hover.memoryLayout.offset"><a class="header" href="#hover.memoryLayout.offset">rust-analyzer.hover.memoryLayout.offset</a></h2>
<p>Default: <code>"hexadecimal"</code></p>
<p>How to render the offset information in a memory layout hover.</p>
<h2 id="hover.memoryLayout.padding"><a class="header" href="#hover.memoryLayout.padding">rust-analyzer.hover.memoryLayout.padding</a></h2>
<p>Default: <code>null</code></p>
<p>How to render the padding information in a memory layout hover.</p>
<h2 id="hover.memoryLayout.size"><a class="header" href="#hover.memoryLayout.size">rust-analyzer.hover.memoryLayout.size</a></h2>
<p>Default: <code>"both"</code></p>
<p>How to render the size information in a memory layout hover.</p>
<h2 id="hover.show.enumVariants"><a class="header" href="#hover.show.enumVariants">rust-analyzer.hover.show.enumVariants</a></h2>
<p>Default: <code>5</code></p>
<p>How many variants of an enum to display when hovering on. Show none if empty.</p>
<h2 id="hover.show.fields"><a class="header" href="#hover.show.fields">rust-analyzer.hover.show.fields</a></h2>
<p>Default: <code>5</code></p>
<p>How many fields of a struct, variant or union to display when hovering on. Show none if
empty.</p>
<h2 id="hover.show.traitAssocItems"><a class="header" href="#hover.show.traitAssocItems">rust-analyzer.hover.show.traitAssocItems</a></h2>
<p>Default: <code>null</code></p>
<p>How many associated items of a trait to display when hovering a trait.</p>
<h2 id="imports.granularity.enforce"><a class="header" href="#imports.granularity.enforce">rust-analyzer.imports.granularity.enforce</a></h2>
<p>Default: <code>false</code></p>
<p>Enforce the import granularity setting for all files. If set to false rust-analyzer will
try to keep import styles consistent per file.</p>
<h2 id="imports.granularity.group"><a class="header" href="#imports.granularity.group">rust-analyzer.imports.granularity.group</a></h2>
<p>Default: <code>"crate"</code></p>
<p>How imports should be grouped into use statements.</p>
<h2 id="imports.group.enable"><a class="header" href="#imports.group.enable">rust-analyzer.imports.group.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Group inserted imports by the <a href="https://rust-analyzer.github.io/book/features.html#auto-import">following
order</a>. Groups are
separated by newlines.</p>
<h2 id="imports.merge.glob"><a class="header" href="#imports.merge.glob">rust-analyzer.imports.merge.glob</a></h2>
<p>Default: <code>true</code></p>
<p>Allow import insertion to merge new imports into single path glob imports like <code>use std::fmt::*;</code>.</p>
<h2 id="imports.preferNoStd"><a class="header" href="#imports.preferNoStd">rust-analyzer.imports.preferNoStd</a></h2>
<p>Default: <code>false</code></p>
<p>Prefer to unconditionally use imports of the core and alloc crate, over the std crate.</p>
<h2 id="imports.preferPrelude"><a class="header" href="#imports.preferPrelude">rust-analyzer.imports.preferPrelude</a></h2>
<p>Default: <code>false</code></p>
<p>Prefer import paths containing a <code>prelude</code> module.</p>
<h2 id="imports.prefix"><a class="header" href="#imports.prefix">rust-analyzer.imports.prefix</a></h2>
<p>Default: <code>"crate"</code></p>
<p>The path structure for newly inserted paths to use.</p>
<h2 id="imports.prefixExternPrelude"><a class="header" href="#imports.prefixExternPrelude">rust-analyzer.imports.prefixExternPrelude</a></h2>
<p>Default: <code>false</code></p>
<p>Prefix external (including std, core) crate imports with <code>::</code>.</p>
<p>E.g. <code>use ::std::io::Read;</code>.</p>
<h2 id="inlayHints.bindingModeHints.enable"><a class="header" href="#inlayHints.bindingModeHints.enable">rust-analyzer.inlayHints.bindingModeHints.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show inlay type hints for binding modes.</p>
<h2 id="inlayHints.chainingHints.enable"><a class="header" href="#inlayHints.chainingHints.enable">rust-analyzer.inlayHints.chainingHints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show inlay type hints for method chains.</p>
<h2 id="inlayHints.closingBraceHints.enable"><a class="header" href="#inlayHints.closingBraceHints.enable">rust-analyzer.inlayHints.closingBraceHints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show inlay hints after a closing <code>}</code> to indicate what item it belongs to.</p>
<h2 id="inlayHints.closingBraceHints.minLines"><a class="header" href="#inlayHints.closingBraceHints.minLines">rust-analyzer.inlayHints.closingBraceHints.minLines</a></h2>
<p>Default: <code>25</code></p>
<p>Minimum number of lines required before the <code>}</code> until the hint is shown (set to 0 or 1
to always show them).</p>
<h2 id="inlayHints.closureCaptureHints.enable"><a class="header" href="#inlayHints.closureCaptureHints.enable">rust-analyzer.inlayHints.closureCaptureHints.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show inlay hints for closure captures.</p>
<h2 id="inlayHints.closureReturnTypeHints.enable"><a class="header" href="#inlayHints.closureReturnTypeHints.enable">rust-analyzer.inlayHints.closureReturnTypeHints.enable</a></h2>
<p>Default: <code>"never"</code></p>
<p>Show inlay type hints for return types of closures.</p>
<h2 id="inlayHints.closureStyle"><a class="header" href="#inlayHints.closureStyle">rust-analyzer.inlayHints.closureStyle</a></h2>
<p>Default: <code>"impl_fn"</code></p>
<p>Closure notation in type and chaining inlay hints.</p>
<h2 id="inlayHints.discriminantHints.enable"><a class="header" href="#inlayHints.discriminantHints.enable">rust-analyzer.inlayHints.discriminantHints.enable</a></h2>
<p>Default: <code>"never"</code></p>
<p>Show enum variant discriminant hints.</p>
<h2 id="inlayHints.expressionAdjustmentHints.disableReborrows"><a class="header" href="#inlayHints.expressionAdjustmentHints.disableReborrows">rust-analyzer.inlayHints.expressionAdjustmentHints.disableReborrows</a></h2>
<p>Default: <code>true</code></p>
<p>Disable reborrows in expression adjustments inlay hints.</p>
<p>Reborrows are a pair of a builtin deref then borrow, i.e. <code>&amp;*</code>. They are inserted by the compiler but are mostly useless to the programmer.</p>
<p>Note: if the deref is not builtin (an overloaded deref), or the borrow is <code>&amp;raw const</code>/<code>&amp;raw mut</code>, they are not removed.</p>
<h2 id="inlayHints.expressionAdjustmentHints.enable"><a class="header" href="#inlayHints.expressionAdjustmentHints.enable">rust-analyzer.inlayHints.expressionAdjustmentHints.enable</a></h2>
<p>Default: <code>"never"</code></p>
<p>Show inlay hints for type adjustments.</p>
<h2 id="inlayHints.expressionAdjustmentHints.hideOutsideUnsafe"><a class="header" href="#inlayHints.expressionAdjustmentHints.hideOutsideUnsafe">rust-analyzer.inlayHints.expressionAdjustmentHints.hideOutsideUnsafe</a></h2>
<p>Default: <code>false</code></p>
<p>Hide inlay hints for type adjustments outside of <code>unsafe</code> blocks.</p>
<h2 id="inlayHints.expressionAdjustmentHints.mode"><a class="header" href="#inlayHints.expressionAdjustmentHints.mode">rust-analyzer.inlayHints.expressionAdjustmentHints.mode</a></h2>
<p>Default: <code>"prefix"</code></p>
<p>Show inlay hints as postfix ops (<code>.*</code> instead of <code>*</code>, etc).</p>
<h2 id="inlayHints.genericParameterHints.const.enable"><a class="header" href="#inlayHints.genericParameterHints.const.enable">rust-analyzer.inlayHints.genericParameterHints.const.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show const generic parameter name inlay hints.</p>
<h2 id="inlayHints.genericParameterHints.lifetime.enable"><a class="header" href="#inlayHints.genericParameterHints.lifetime.enable">rust-analyzer.inlayHints.genericParameterHints.lifetime.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show generic lifetime parameter name inlay hints.</p>
<h2 id="inlayHints.genericParameterHints.type.enable"><a class="header" href="#inlayHints.genericParameterHints.type.enable">rust-analyzer.inlayHints.genericParameterHints.type.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show generic type parameter name inlay hints.</p>
<h2 id="inlayHints.implicitDrops.enable"><a class="header" href="#inlayHints.implicitDrops.enable">rust-analyzer.inlayHints.implicitDrops.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show implicit drop hints.</p>
<h2 id="inlayHints.implicitSizedBoundHints.enable"><a class="header" href="#inlayHints.implicitSizedBoundHints.enable">rust-analyzer.inlayHints.implicitSizedBoundHints.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show inlay hints for the implied type parameter <code>Sized</code> bound.</p>
<h2 id="inlayHints.lifetimeElisionHints.enable"><a class="header" href="#inlayHints.lifetimeElisionHints.enable">rust-analyzer.inlayHints.lifetimeElisionHints.enable</a></h2>
<p>Default: <code>"never"</code></p>
<p>Show inlay type hints for elided lifetimes in function signatures.</p>
<h2 id="inlayHints.lifetimeElisionHints.useParameterNames"><a class="header" href="#inlayHints.lifetimeElisionHints.useParameterNames">rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames</a></h2>
<p>Default: <code>false</code></p>
<p>Prefer using parameter names as the name for elided lifetime hints if possible.</p>
<h2 id="inlayHints.maxLength"><a class="header" href="#inlayHints.maxLength">rust-analyzer.inlayHints.maxLength</a></h2>
<p>Default: <code>25</code></p>
<p>Maximum length for inlay hints. Set to null to have an unlimited length.</p>
<p><strong>Note:</strong> This is mostly a hint, and we don't guarantee to strictly follow the limit.</p>
<h2 id="inlayHints.parameterHints.enable"><a class="header" href="#inlayHints.parameterHints.enable">rust-analyzer.inlayHints.parameterHints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show function parameter name inlay hints at the call site.</p>
<h2 id="inlayHints.rangeExclusiveHints.enable"><a class="header" href="#inlayHints.rangeExclusiveHints.enable">rust-analyzer.inlayHints.rangeExclusiveHints.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show exclusive range inlay hints.</p>
<h2 id="inlayHints.reborrowHints.enable"><a class="header" href="#inlayHints.reborrowHints.enable">rust-analyzer.inlayHints.reborrowHints.enable</a></h2>
<p>Default: <code>"never"</code></p>
<p>Show inlay hints for compiler inserted reborrows.</p>
<p>This setting is deprecated in favor of
#rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.</p>
<h2 id="inlayHints.renderColons"><a class="header" href="#inlayHints.renderColons">rust-analyzer.inlayHints.renderColons</a></h2>
<p>Default: <code>true</code></p>
<p>Whether to render leading colons for type hints, and trailing colons for parameter hints.</p>
<h2 id="inlayHints.typeHints.enable"><a class="header" href="#inlayHints.typeHints.enable">rust-analyzer.inlayHints.typeHints.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show inlay type hints for variables.</p>
<h2 id="inlayHints.typeHints.hideClosureInitialization"><a class="header" href="#inlayHints.typeHints.hideClosureInitialization">rust-analyzer.inlayHints.typeHints.hideClosureInitialization</a></h2>
<p>Default: <code>false</code></p>
<p>Hide inlay type hints for <code>let</code> statements that initialize to a closure.</p>
<p>Only applies to closures with blocks, same as
<code>#rust-analyzer.inlayHints.closureReturnTypeHints.enable#</code>.</p>
<h2 id="inlayHints.typeHints.hideClosureParameter"><a class="header" href="#inlayHints.typeHints.hideClosureParameter">rust-analyzer.inlayHints.typeHints.hideClosureParameter</a></h2>
<p>Default: <code>false</code></p>
<p>Hide inlay parameter type hints for closures.</p>
<h2 id="inlayHints.typeHints.hideNamedConstructor"><a class="header" href="#inlayHints.typeHints.hideNamedConstructor">rust-analyzer.inlayHints.typeHints.hideNamedConstructor</a></h2>
<p>Default: <code>false</code></p>
<p>Hide inlay type hints for constructors.</p>
<h2 id="interpret.tests"><a class="header" href="#interpret.tests">rust-analyzer.interpret.tests</a></h2>
<p>Default: <code>false</code></p>
<p>Enable the experimental support for interpreting tests.</p>
<h2 id="joinLines.joinAssignments"><a class="header" href="#joinLines.joinAssignments">rust-analyzer.joinLines.joinAssignments</a></h2>
<p>Default: <code>true</code></p>
<p>Join lines merges consecutive declaration and initialization of an assignment.</p>
<h2 id="joinLines.joinElseIf"><a class="header" href="#joinLines.joinElseIf">rust-analyzer.joinLines.joinElseIf</a></h2>
<p>Default: <code>true</code></p>
<p>Join lines inserts else between consecutive ifs.</p>
<h2 id="joinLines.removeTrailingComma"><a class="header" href="#joinLines.removeTrailingComma">rust-analyzer.joinLines.removeTrailingComma</a></h2>
<p>Default: <code>true</code></p>
<p>Join lines removes trailing commas.</p>
<h2 id="joinLines.unwrapTrivialBlock"><a class="header" href="#joinLines.unwrapTrivialBlock">rust-analyzer.joinLines.unwrapTrivialBlock</a></h2>
<p>Default: <code>true</code></p>
<p>Join lines unwraps trivial blocks.</p>
<h2 id="lens.debug.enable"><a class="header" href="#lens.debug.enable">rust-analyzer.lens.debug.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Debug</code> lens. Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.enable"><a class="header" href="#lens.enable">rust-analyzer.lens.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show CodeLens in Rust files.</p>
<h2 id="lens.implementations.enable"><a class="header" href="#lens.implementations.enable">rust-analyzer.lens.implementations.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Implementations</code> lens. Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.location"><a class="header" href="#lens.location">rust-analyzer.lens.location</a></h2>
<p>Default: <code>"above_name"</code></p>
<p>Where to render annotations.</p>
<h2 id="lens.references.adt.enable"><a class="header" href="#lens.references.adt.enable">rust-analyzer.lens.references.adt.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show <code>References</code> lens for Struct, Enum, and Union. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.references.enumVariant.enable"><a class="header" href="#lens.references.enumVariant.enable">rust-analyzer.lens.references.enumVariant.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show <code>References</code> lens for Enum Variants. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.references.method.enable"><a class="header" href="#lens.references.method.enable">rust-analyzer.lens.references.method.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show <code>Method References</code> lens. Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.references.trait.enable"><a class="header" href="#lens.references.trait.enable">rust-analyzer.lens.references.trait.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Show <code>References</code> lens for Trait. Only applies when <code>#rust-analyzer.lens.enable#</code> is
set.</p>
<h2 id="lens.run.enable"><a class="header" href="#lens.run.enable">rust-analyzer.lens.run.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Run</code> lens. Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<h2 id="lens.updateTest.enable"><a class="header" href="#lens.updateTest.enable">rust-analyzer.lens.updateTest.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>Update Test</code> lens. Only applies when <code>#rust-analyzer.lens.enable#</code> and
<code>#rust-analyzer.lens.run.enable#</code> are set.</p>
<h2 id="linkedProjects"><a class="header" href="#linkedProjects">rust-analyzer.linkedProjects</a></h2>
<p>Default: <code>[]</code></p>
<p>Disable project auto-discovery in favor of explicitly specified set of projects.</p>
<p>Elements must be paths pointing to <code>Cargo.toml</code>, <code>rust-project.json</code>, <code>.rs</code> files (which
will be treated as standalone files) or JSON objects in <code>rust-project.json</code> format.</p>
<h2 id="lru.capacity"><a class="header" href="#lru.capacity">rust-analyzer.lru.capacity</a></h2>
<p>Default: <code>null</code></p>
<p>Number of syntax trees rust-analyzer keeps in memory. Defaults to 128.</p>
<h2 id="lru.query.capacities"><a class="header" href="#lru.query.capacities">rust-analyzer.lru.query.capacities</a></h2>
<p>Default: <code>{}</code></p>
<p>The LRU capacity of the specified queries.</p>
<h2 id="notifications.cargoTomlNotFound"><a class="header" href="#notifications.cargoTomlNotFound">rust-analyzer.notifications.cargoTomlNotFound</a></h2>
<p>Default: <code>true</code></p>
<p>Show <code>can't find Cargo.toml</code> error message.</p>
<h2 id="numThreads"><a class="header" href="#numThreads">rust-analyzer.numThreads</a></h2>
<p>Default: <code>null</code></p>
<p>The number of worker threads in the main loop. The default <code>null</code> means to pick
automatically.</p>
<h2 id="procMacro.attributes.enable"><a class="header" href="#procMacro.attributes.enable">rust-analyzer.procMacro.attributes.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Expand attribute macros. Requires <code>#rust-analyzer.procMacro.enable#</code> to be set.</p>
<h2 id="procMacro.enable"><a class="header" href="#procMacro.enable">rust-analyzer.procMacro.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Enable support for procedural macros, implies <code>#rust-analyzer.cargo.buildScripts.enable#</code>.</p>
<h2 id="procMacro.ignored"><a class="header" href="#procMacro.ignored">rust-analyzer.procMacro.ignored</a></h2>
<p>Default: <code>{}</code></p>
<p>These proc-macros will be ignored when trying to expand them.</p>
<p>This config takes a map of crate names with the exported proc-macro names to ignore as values.</p>
<h2 id="procMacro.server"><a class="header" href="#procMacro.server">rust-analyzer.procMacro.server</a></h2>
<p>Default: <code>null</code></p>
<p>Internal config, path to proc-macro server executable.</p>
<h2 id="profiling.memoryProfile"><a class="header" href="#profiling.memoryProfile">rust-analyzer.profiling.memoryProfile</a></h2>
<p>Default: <code>null</code></p>
<p>The path where to save memory profiling output.</p>
<p><strong>Note:</strong> Memory profiling is not enabled by default in rust-analyzer builds, you need to build
from source for it.</p>
<h2 id="references.excludeImports"><a class="header" href="#references.excludeImports">rust-analyzer.references.excludeImports</a></h2>
<p>Default: <code>false</code></p>
<p>Exclude imports from find-all-references.</p>
<h2 id="references.excludeTests"><a class="header" href="#references.excludeTests">rust-analyzer.references.excludeTests</a></h2>
<p>Default: <code>false</code></p>
<p>Exclude tests from find-all-references and call-hierarchy.</p>
<h2 id="runnables.command"><a class="header" href="#runnables.command">rust-analyzer.runnables.command</a></h2>
<p>Default: <code>null</code></p>
<p>Command to be executed instead of 'cargo' for runnables.</p>
<h2 id="runnables.extraArgs"><a class="header" href="#runnables.extraArgs">rust-analyzer.runnables.extraArgs</a></h2>
<p>Default: <code>[]</code></p>
<p>Additional arguments to be passed to cargo for runnables such as
tests or binaries. For example, it may be <code>--release</code>.</p>
<h2 id="runnables.extraTestBinaryArgs"><a class="header" href="#runnables.extraTestBinaryArgs">rust-analyzer.runnables.extraTestBinaryArgs</a></h2>
<p>Default:</p>
<pre><code class="language-json">[
  "--nocapture"
]
</code></pre>
<p>Additional arguments to be passed through Cargo to launched tests, benchmarks, or
doc-tests.</p>
<p>Unless the launched target uses a
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field">custom test harness</a>,
they will end up being interpreted as options to
<a href="https://doc.rust-lang.org/rustc/tests/index.html#cli-arguments"><code>rustc</code>’s built-in test harness (“libtest”)</a>.</p>
<h2 id="rustc.source"><a class="header" href="#rustc.source">rust-analyzer.rustc.source</a></h2>
<p>Default: <code>null</code></p>
<p>Path to the Cargo.toml of the rust compiler workspace, for usage in rustc_private
projects, or "discover" to try to automatically find it if the <code>rustc-dev</code> component
is installed.</p>
<p>Any project which uses rust-analyzer with the rustcPrivate
crates must set <code>[package.metadata.rust-analyzer] rustc_private=true</code> to use it.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<h2 id="rustfmt.extraArgs"><a class="header" href="#rustfmt.extraArgs">rust-analyzer.rustfmt.extraArgs</a></h2>
<p>Default: <code>[]</code></p>
<p>Additional arguments to <code>rustfmt</code>.</p>
<h2 id="rustfmt.overrideCommand"><a class="header" href="#rustfmt.overrideCommand">rust-analyzer.rustfmt.overrideCommand</a></h2>
<p>Default: <code>null</code></p>
<p>Advanced option, fully override the command rust-analyzer uses for
formatting. This should be the equivalent of <code>rustfmt</code> here, and
not that of <code>cargo fmt</code>. The file contents will be passed on the
standard input and the formatted result will be read from the
standard output.</p>
<p>Note: The option must be specified as an array of command line arguments, with
the first argument being the name of the command to run.</p>
<h2 id="rustfmt.rangeFormatting.enable"><a class="header" href="#rustfmt.rangeFormatting.enable">rust-analyzer.rustfmt.rangeFormatting.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Enables the use of rustfmt's unstable range formatting command for the
<code>textDocument/rangeFormatting</code> request. The rustfmt option is unstable and only
available on a nightly build.</p>
<h2 id="semanticHighlighting.comments.enable"><a class="header" href="#semanticHighlighting.comments.enable">rust-analyzer.semanticHighlighting.comments.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Use semantic tokens for comments.</p>
<p>In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
By disabling semantic tokens for comments, other grammars can be used to highlight
their contents.</p>
<h2 id="semanticHighlighting.doc.comment.inject.enable"><a class="header" href="#semanticHighlighting.doc.comment.inject.enable">rust-analyzer.semanticHighlighting.doc.comment.inject.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Inject additional highlighting into doc comments.</p>
<p>When enabled, rust-analyzer will highlight rust source in doc comments as well as intra
doc links.</p>
<h2 id="semanticHighlighting.nonStandardTokens"><a class="header" href="#semanticHighlighting.nonStandardTokens">rust-analyzer.semanticHighlighting.nonStandardTokens</a></h2>
<p>Default: <code>true</code></p>
<p>Emit non-standard tokens and modifiers</p>
<p>When enabled, rust-analyzer will emit tokens and modifiers that are not part of the
standard set of semantic tokens.</p>
<h2 id="semanticHighlighting.operator.enable"><a class="header" href="#semanticHighlighting.operator.enable">rust-analyzer.semanticHighlighting.operator.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Use semantic tokens for operators.</p>
<p>When disabled, rust-analyzer will emit semantic tokens only for operator tokens when
they are tagged with modifiers.</p>
<h2 id="semanticHighlighting.operator.specialization.enable"><a class="header" href="#semanticHighlighting.operator.specialization.enable">rust-analyzer.semanticHighlighting.operator.specialization.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Use specialized semantic tokens for operators.</p>
<p>When enabled, rust-analyzer will emit special token types for operator tokens instead
of the generic <code>operator</code> token type.</p>
<h2 id="semanticHighlighting.punctuation.enable"><a class="header" href="#semanticHighlighting.punctuation.enable">rust-analyzer.semanticHighlighting.punctuation.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Use semantic tokens for punctuation.</p>
<p>When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when
they are tagged with modifiers or have a special role.</p>
<h2 id="semanticHighlighting.punctuation.separate.macro.bang"><a class="header" href="#semanticHighlighting.punctuation.separate.macro.bang">rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang</a></h2>
<p>Default: <code>false</code></p>
<p>When enabled, rust-analyzer will emit a punctuation semantic token for the <code>!</code> of macro
calls.</p>
<h2 id="semanticHighlighting.punctuation.specialization.enable"><a class="header" href="#semanticHighlighting.punctuation.specialization.enable">rust-analyzer.semanticHighlighting.punctuation.specialization.enable</a></h2>
<p>Default: <code>false</code></p>
<p>Use specialized semantic tokens for punctuation.</p>
<p>When enabled, rust-analyzer will emit special token types for punctuation tokens instead
of the generic <code>punctuation</code> token type.</p>
<h2 id="semanticHighlighting.strings.enable"><a class="header" href="#semanticHighlighting.strings.enable">rust-analyzer.semanticHighlighting.strings.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Use semantic tokens for strings.</p>
<p>In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
By disabling semantic tokens for strings, other grammars can be used to highlight
their contents.</p>
<h2 id="signatureInfo.detail"><a class="header" href="#signatureInfo.detail">rust-analyzer.signatureInfo.detail</a></h2>
<p>Default: <code>"full"</code></p>
<p>Show full signature of the callable. Only shows parameters if disabled.</p>
<h2 id="signatureInfo.documentation.enable"><a class="header" href="#signatureInfo.documentation.enable">rust-analyzer.signatureInfo.documentation.enable</a></h2>
<p>Default: <code>true</code></p>
<p>Show documentation.</p>
<h2 id="typing.triggerChars"><a class="header" href="#typing.triggerChars">rust-analyzer.typing.triggerChars</a></h2>
<p>Default: <code>"=."</code></p>
<p>Specify the characters allowed to invoke special on typing triggers.</p>
<ul>
<li>typing <code>=</code> after <code>let</code> tries to smartly add <code>;</code> if <code>=</code> is followed by an existing
expression</li>
<li>typing <code>=</code> between two expressions adds <code>;</code> when in statement position</li>
<li>typing <code>=</code> to turn an assignment into an equality comparison removes <code>;</code> when in
expression position</li>
<li>typing <code>.</code> in a chain method call auto-indents</li>
<li>typing <code>{</code> or <code>(</code> in front of an expression inserts a closing <code>}</code> or <code>)</code> after the
expression</li>
<li>typing <code>{</code> in a use item adds a closing <code>}</code> in the right place</li>
<li>typing <code>&gt;</code> to complete a return type <code>-&gt;</code> will insert a whitespace after it</li>
<li>typing <code>&lt;</code> in a path or type position inserts a closing <code>&gt;</code> after the path or type.</li>
</ul>
<h2 id="vfs.extraIncludes"><a class="header" href="#vfs.extraIncludes">rust-analyzer.vfs.extraIncludes</a></h2>
<p>Default: <code>[]</code></p>
<p>Additional paths to include in the VFS. Generally for code that is
generated or otherwise managed by a build system outside of Cargo,
though Cargo might be the eventual consumer.</p>
<h2 id="workspace.discoverConfig"><a class="header" href="#workspace.discoverConfig">rust-analyzer.workspace.discoverConfig</a></h2>
<p>Default: <code>null</code></p>
<p>Enables automatic discovery of projects using [<code>DiscoverWorkspaceConfig::command</code>].</p>
<p>[<code>DiscoverWorkspaceConfig</code>] also requires setting <code>progress_label</code> and <code>files_to_watch</code>.
<code>progress_label</code> is used for the title in progress indicators, whereas <code>files_to_watch</code>
is used to determine which build system-specific files should be watched in order to
reload rust-analyzer.</p>
<p>Below is an example of a valid configuration:</p>
<pre><code class="language-json">"rust-analyzer.workspace.discoverConfig": {
    "command": [
        "rust-project",
        "develop-json"
    ],
    "progressLabel": "rust-analyzer",
    "filesToWatch": [
        "BUCK"
    ]
}
</code></pre>
<h2 id="on-discoverworkspaceconfigcommand"><a class="header" href="#on-discoverworkspaceconfigcommand">On <code>DiscoverWorkspaceConfig::command</code></a></h2>
<p><strong>Warning</strong>: This format is provisional and subject to change.</p>
<p>[<code>DiscoverWorkspaceConfig::command</code>] <em>must</em> return a JSON object corresponding to
<code>DiscoverProjectData::Finished</code>:</p>
<pre><code class="language-norun">#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "kind")]
#[serde(rename_all = "snake_case")]
enum DiscoverProjectData {
    Finished { buildfile: Utf8PathBuf, project: ProjectJsonData },
    Error { error: String, source: Option&lt;String&gt; },
    Progress { message: String },
}
</code></pre>
<p>As JSON, <code>DiscoverProjectData::Finished</code> is:</p>
<pre><code class="language-json">{
    // the internally-tagged representation of the enum.
    "kind": "finished",
    // the file used by a non-Cargo build system to define
    // a package or target.
    "buildfile": "rust-analyzer/BUILD",
    // the contents of a rust-project.json, elided for brevity
    "project": {
        "sysroot": "foo",
        "crates": []
    }
}
</code></pre>
<p>It is encouraged, but not required, to use the other variants on <code>DiscoverProjectData</code>
to provide a more polished end-user experience.</p>
<p><code>DiscoverWorkspaceConfig::command</code> may <em>optionally</em> include an <code>{arg}</code>, which will be
substituted with the JSON-serialized form of the following enum:</p>
<pre><code class="language-norun">#[derive(PartialEq, Clone, Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum DiscoverArgument {
   Path(AbsPathBuf),
   Buildfile(AbsPathBuf),
}
</code></pre>
<p>The JSON representation of <code>DiscoverArgument::Path</code> is:</p>
<pre><code class="language-json">{
    "path": "src/main.rs"
}
</code></pre>
<p>Similarly, the JSON representation of <code>DiscoverArgument::Buildfile</code> is:</p>
<pre><code class="language-json">{
    "buildfile": "BUILD"
}
</code></pre>
<p><code>DiscoverArgument::Path</code> is used to find and generate a <code>rust-project.json</code>, and
therefore, a workspace, whereas <code>DiscoverArgument::buildfile</code> is used to to update an
existing workspace. As a reference for implementors, buck2's <code>rust-project</code> will likely
be useful: https://github.com/facebook/buck2/tree/main/integrations/rust-project.</p>
<h2 id="workspace.symbol.search.excludeImports"><a class="header" href="#workspace.symbol.search.excludeImports">rust-analyzer.workspace.symbol.search.excludeImports</a></h2>
<p>Default: <code>false</code></p>
<p>Exclude all imports from workspace symbol search.</p>
<p>In addition to regular imports (which are always excluded),
this option removes public imports (better known as re-exports)
and removes imports that rename the imported symbol.</p>
<h2 id="workspace.symbol.search.kind"><a class="header" href="#workspace.symbol.search.kind">rust-analyzer.workspace.symbol.search.kind</a></h2>
<p>Default: <code>"only_types"</code></p>
<p>Workspace symbol search kind.</p>
<h2 id="workspace.symbol.search.limit"><a class="header" href="#workspace.symbol.search.limit">rust-analyzer.workspace.symbol.search.limit</a></h2>
<p>Default: <code>128</code></p>
<p>Limits the number of items returned from a workspace symbol search (Defaults to 128).
Some clients like vs-code issue new searches on result filtering and don't require all results to be returned in the initial search.
Other clients requires all results upfront and might require a higher limit.</p>
<h2 id="workspace.symbol.search.scope"><a class="header" href="#workspace.symbol.search.scope">rust-analyzer.workspace.symbol.search.scope</a></h2>
<p>Default: <code>"workspace"</code></p>
<p>Workspace symbol search scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-cargo-based-projects"><a class="header" href="#non-cargo-based-projects">Non-Cargo Based Projects</a></h1>
<p>rust-analyzer does not require Cargo. However, if you use some other
build system, you’ll have to describe the structure of your project for
rust-analyzer in the <code>rust-project.json</code> format:</p>
<pre><code class="language-typescript">interface ProjectJson {
    /// Path to the sysroot directory.
    ///
    /// The sysroot is where rustc looks for the
    /// crates that are built-in to rust, such as
    /// std.
    ///
    /// https://doc.rust-lang.org/rustc/command-line-arguments.html#--sysroot-override-the-system-root
    ///
    /// To see the current value of sysroot, you
    /// can query rustc:
    ///
    /// ```
    /// $ rustc --print sysroot
    /// /Users/yourname/.rustup/toolchains/stable-x86_64-apple-darwin
    /// ```
    sysroot?: string;
    /// Path to the directory with *source code* of
    /// sysroot crates.
    ///
    /// By default, this is `lib/rustlib/src/rust/library`
    /// relative to the sysroot.
    ///
    /// It should point to the directory where std,
    /// core, and friends can be found:
    ///
    /// https://github.com/rust-lang/rust/tree/master/library.
    ///
    /// If provided, rust-analyzer automatically adds
    /// dependencies on sysroot crates. Conversely,
    /// if you omit this path, you can specify sysroot
    /// dependencies yourself and, for example, have
    /// several different "sysroots" in one graph of
    /// crates.
    sysroot_src?: string;
    /// A ProjectJson describing the crates of the sysroot.
    sysroot_project?: ProjectJson;

    /// List of groups of common cfg values, to allow
    /// sharing them between crates.
    ///
    /// Maps from group name to its cfgs. Cfg follow
    /// the same format as `Crate.cfg`.
    cfg_groups?: { [key: string]: string[]; };
    /// The set of crates comprising the current
    /// project. Must include all transitive
    /// dependencies as well as sysroot crate (libstd,
    /// libcore and such).
    crates: Crate[];
    /// Configuration for CLI commands.
    ///
    /// These are used for running and debugging binaries
    /// and tests without encoding build system-specific
    /// knowledge into rust-analyzer.
    ///
    /// # Example
    ///
    /// Below is an example of a test runnable. `{label}` and `{test_id}`
    /// are explained in `Runnable::args`'s documentation below.
    ///
    /// ```json
    /// {
    ///     "program": "buck",
    ///     "args": [
    ///         "test",
    ///          "{label}",
    ///          "--",
    ///          "{test_id}",
    ///          "--print-passing-details"
    ///     ],
    ///     "cwd": "/home/user/repo-root/",
    ///     "kind": "testOne"
    /// }
    /// ```
    runnables?: Runnable[];
}

interface Crate {
    /// Optional crate name used for display purposes,
    /// without affecting semantics. See the `deps`
    /// key for semantically-significant crate names.
    display_name?: string;
    /// Path to the root module of the crate.
    root_module: string;
    /// Edition of the crate.
    edition: '2015' | '2018' | '2021' | '2024';
    /// The version of the crate. Used for calculating
    /// the correct docs.rs URL.
    version?: string;
    /// Dependencies
    deps: Dep[];
    /// Should this crate be treated as a member of
    /// current "workspace".
    ///
    /// By default, inferred from the `root_module`
    /// (members are the crates which reside inside
    /// the directory opened in the editor).
    ///
    /// Set this to `false` for things like standard
    /// library and 3rd party crates to enable
    /// performance optimizations (rust-analyzer
    /// assumes that non-member crates don't change).
    is_workspace_member?: boolean;
    /// Optionally specify the (super)set of `.rs`
    /// files comprising this crate.
    ///
    /// By default, rust-analyzer assumes that only
    /// files under `root_module.parent` can belong
    /// to a crate. `include_dirs` are included
    /// recursively, unless a subdirectory is in
    /// `exclude_dirs`.
    ///
    /// Different crates can share the same `source`.
    ///
    /// If two crates share an `.rs` file in common,
    /// they *must* have the same `source`.
    /// rust-analyzer assumes that files from one
    /// source can't refer to files in another source.
    source?: {
        include_dirs: string[];
        exclude_dirs: string[];
    };
    /// List of cfg groups this crate inherits.
    ///
    /// All cfg in these groups will be concatenated to
    /// `cfg`. It is impossible to replace a value from
    /// the groups.
    cfg_groups?: string[];
    /// The set of cfgs activated for a given crate, like
    /// `["unix", "feature=\"foo\"", "feature=\"bar\""]`.
    cfg: string[];
    /// Target tuple for this Crate.
    ///
    /// Used when running `rustc --print cfg`
    /// to get target-specific cfgs.
    target?: string;
    /// Environment variables, used for
    /// the `env!` macro
    env: { [key: string]: string; };

    /// Whether the crate is a proc-macro crate.
    is_proc_macro: boolean;
    /// For proc-macro crates, path to compiled
    /// proc-macro (.so file).
    proc_macro_dylib_path?: string;

    /// Repository, matching the URL that would be used
    /// in Cargo.toml.
    repository?: string;

    /// Build-specific data about this crate.
    build?: BuildInfo;
}

interface Dep {
    /// Index of a crate in the `crates` array.
    crate: number;
    /// Name as should appear in the (implicit)
    /// `extern crate name` declaration.
    name: string;
}

interface BuildInfo {
    /// The name associated with this crate.
    ///
    /// This is determined by the build system that produced
    /// the `rust-project.json` in question. For instance, if buck were used,
    /// the label might be something like `//ide/rust/rust-analyzer:rust-analyzer`.
    ///
    /// Do not attempt to parse the contents of this string; it is a build system-specific
    /// identifier similar to `Crate::display_name`.
    label: string;
    /// Path corresponding to the build system-specific file defining the crate.
    build_file: string;
    /// The kind of target.
    ///
    /// This information is used to determine what sort
    /// of runnable codelens to provide, if any.
    target_kind: 'bin' | 'lib' | 'test';
}

interface Runnable {
    /// The program invoked by the runnable.
    ///
    /// For example, this might be `cargo`, `buck`, or `bazel`.
    program: string;
    /// The arguments passed to `program`.
    args: string[];
    /// The current working directory of the runnable.
    cwd: string;
    /// Used to decide what code lens to offer.
    ///
    /// `testOne`: This runnable will be used when the user clicks the 'Run Test'
    /// CodeLens above a test.
    ///
    /// The args for testOne can contain two template strings:
    /// `{label}` and `{test_id}`. `{label}` will be replaced
    /// with the `Build::label` and `{test_id}` will be replaced
    /// with the test name.
    kind: 'testOne' | string;
}
</code></pre>
<p>This format is provisional and subject to change. Specifically, the
<code>roots</code> setup will be different eventually.</p>
<p>There are three ways to feed <code>rust-project.json</code> to rust-analyzer:</p>
<ul>
<li>
<p>Place <code>rust-project.json</code> file at the root of the project, and
rust-analyzer will discover it.</p>
</li>
<li>
<p>Specify
<code>"rust-analyzer.linkedProjects": [ "path/to/rust-project.json" ]</code> in
the settings (and make sure that your LSP client sends settings as a
part of initialize request).</p>
</li>
<li>
<p>Specify
<code>"rust-analyzer.linkedProjects": [ { "roots": […​], "crates": […​] }]</code>
inline.</p>
</li>
</ul>
<p>Relative paths are interpreted relative to <code>rust-project.json</code> file
location or (for inline JSON) relative to <code>rootUri</code>.</p>
<p>You can set the <code>RA_LOG</code> environment variable to <code>rust_analyzer=info</code> to
inspect how rust-analyzer handles config and project loading.</p>
<p>Note that calls to <code>cargo check</code> are disabled when using
<code>rust-project.json</code> by default, so compilation errors and warnings will
no longer be sent to your LSP client. To enable these compilation errors
you will need to specify explicitly what command rust-analyzer should
run to perform the checks using the
<code>rust-analyzer.check.overrideCommand</code> configuration. As an example, the
following configuration explicitly sets <code>cargo check</code> as the <code>check</code>
command.</p>
<pre><code>{ "rust-analyzer.check.overrideCommand": ["cargo", "check", "--message-format=json"] }
</code></pre>
<p><code>check.overrideCommand</code> requires the command specified to output json
error messages for rust-analyzer to consume. The <code>--message-format=json</code>
flag does this for <code>cargo check</code> so whichever command you use must also
output errors in this format. See the <a href="non_cargo_based_projects.html#_configuration">Configuration</a>
section for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>At the moment, rust-analyzer assumes that all code is trusted. Here is a
<strong>non-exhaustive</strong> list of ways to make rust-analyzer execute arbitrary
code:</p>
<ul>
<li>
<p>proc macros and build scripts are executed by default</p>
</li>
<li>
<p><code>.cargo/config</code> can override <code>rustc</code> with an arbitrary executable</p>
</li>
<li>
<p><code>rust-toolchain.toml</code> can override <code>rustc</code> with an arbitrary
executable</p>
</li>
<li>
<p>VS Code plugin reads configuration from project directory, and that
can be used to override paths to various executables, like <code>rustfmt</code>
or <code>rust-analyzer</code> itself.</p>
</li>
<li>
<p>rust-analyzer’s syntax trees library uses a lot of <code>unsafe</code> and
hasn’t been properly audited for memory safety.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="privacy"><a class="header" href="#privacy">Privacy</a></h1>
<p>The LSP server performs no network access in itself, but runs
<code>cargo metadata</code> which will update or download the crate registry and
the source code of the project dependencies. If enabled (the default),
build scripts and procedural macros can do anything.</p>
<p>The Code extension does not access the network.</p>
<p>Any other editor plugins are not under the control of the
<code>rust-analyzer</code> developers. For any privacy concerns, you should check
with their respective developers.</p>
<p>For <code>rust-analyzer</code> developers, <code>cargo xtask release</code> uses the GitHub
API to put together the release notes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/annotations.rs#L20">annotations.rs</a></p>
<p>Provides user with annotations above items for looking up references or impl blocks
and running/debugging binaries.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020672-b7c34f00-917a-11eb-8f6e-858735660a0e.png" alt="Annotations" /></p>
<h3 id="auto-import"><a class="header" href="#auto-import">Auto Import</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/auto_import.rs#L17">auto_import.rs</a></p>
<p>Using the <code>auto-import</code> assist it is possible to insert missing imports for unresolved items.
When inserting an import it will do so in a structured manner by keeping imports grouped,
separated by a newline in the following order:</p>
<ul>
<li><code>std</code> and <code>core</code></li>
<li>External Crates</li>
<li>Current Crate, paths prefixed by <code>crate</code></li>
<li>Current Module, paths prefixed by <code>self</code></li>
<li>Super Module, paths prefixed by <code>super</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-rust">use std::fs::File;

use itertools::Itertools;
use syntax::ast;

use crate::utils::insert_use;

use self::auto_import;

use super::AssistContext;</code></pre>
<h4 id="import-granularity"><a class="header" href="#import-granularity">Import Granularity</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: Merge imports from the same crate into a single use statement. This kind of
nesting is only supported in Rust versions later than 1.24.</li>
<li><code>module</code>: Merge imports from the same module into a single use statement.</li>
<li><code>item</code>: Don't merge imports at all, creating one import per item.</li>
<li><code>preserve</code>: Do not change the granularity of any imports. For auto-import this has the same
effect as <code>item</code>.</li>
<li><code>one</code>: Merge all imports into a single use statement as long as they have the same visibility
and attributes.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.granularity.group</code>.</p>
<h4 id="import-prefix"><a class="header" href="#import-prefix">Import Prefix</a></h4>
<p>The style of imports in the same crate is configurable through the <code>imports.prefix</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: This setting will force paths to be always absolute, starting with the <code>crate</code>
prefix, unless the item is defined outside of the current crate.</li>
<li><code>self</code>: This setting will force paths that are relative to the current module to always
start with <code>self</code>. This will result in paths that always start with either <code>crate</code>, <code>self</code>,
<code>super</code> or an extern crate identifier.</li>
<li><code>plain</code>: This setting does not impose any restrictions in imports.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.prefix</code>.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020673-b85be580-917a-11eb-9022-59585f35d4f8.gif" alt="Auto Import" /></p>
<h3 id="child-modules"><a class="header" href="#child-modules">Child Modules</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/child_modules.rs#L10">child_modules.rs</a></p>
<p>Navigates to the child modules of the current module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Locate child modules</strong></td></tr>
</tbody></table>
</div>
<h3 id="completion-with-autoimport"><a class="header" href="#completion-with-autoimport">Completion With Autoimport</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-completion/src/completions/flyimport.rs#L20">flyimport.rs</a></p>
<p>When completing names in the current scope, proposes additional imports from other modules or crates,
if they can be qualified in the scope, and their name contains all symbols from the completion input.</p>
<p>To be considered applicable, the name must contain all input symbols in the given order, not necessarily adjacent.
If any input symbol is not lowercased, the name must contain all symbols in exact case; otherwise the containing is checked case-insensitively.</p>
<pre><code>fn main() {
    pda$0
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>-&gt;</p>
<pre><code>use std::marker::PhantomData;

fn main() {
    PhantomData
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>Also completes associated items, that require trait imports.
If any unresolved and/or partially-qualified path precedes the input, it will be taken into account.
Currently, only the imports with their import path ending with the whole qualifier will be proposed
(no fuzzy matching for qualifier).</p>
<pre><code>mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_A$0
}
</code></pre>
<p>-&gt;</p>
<pre><code>use foo::bar;

mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_ASSOC
}
</code></pre>
<p>NOTE: currently, if an assoc item comes from a trait that's not currently imported, and it also has an unresolved and/or partially-qualified path,
no imports will be proposed.</p>
<h4 id="fuzzy-search-details"><a class="header" href="#fuzzy-search-details">Fuzzy search details</a></h4>
<p>To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only
(i.e. in <code>HashMap</code> in the <code>std::collections::HashMap</code> path).
For the same reasons, avoids searching for any path imports for inputs with their length less than 2 symbols
(but shows all associated items for any input length).</p>
<h4 id="import-configuration"><a class="header" href="#import-configuration">Import configuration</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
Mimics the corresponding behavior of the <code>Auto Import</code> feature.</p>
<h4 id="lsp-and-performance-implications"><a class="header" href="#lsp-and-performance-implications">LSP and performance implications</a></h4>
<p>The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the <code>additionalTextEdits</code>
(case-sensitive) resolve client capability in its client capabilities.
This way the server is able to defer the costly computations, doing them for a selected completion item only.
For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,
which might be slow ergo the feature is automatically disabled.</p>
<h4 id="feature-toggle"><a class="header" href="#feature-toggle">Feature toggle</a></h4>
<p>The feature can be forcefully turned off in the settings with the <code>rust-analyzer.completion.autoimport.enable</code> flag.
Note that having this flag set to <code>true</code> does not guarantee that the feature is enabled: your client needs to have the corresponding
capability enabled.</p>
<h3 id="completions-attribute"><a class="header" href="#completions-attribute">Completions Attribute</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/hir-def/src/lib.rs#L1369">lib.rs</a>
Crate authors can opt their type out of completions in some cases.
This is done with the <code>#[rust_analyzer::completions(...)]</code> attribute.</p>
<p>All completable things support <code>#[rust_analyzer::completions(ignore_flyimport)]</code>,
which causes the thing to get excluded from flyimport completion. It will still
be completed when in scope. This is analogous to the setting <code>rust-analyzer.completion.autoimport.exclude</code>
with <code>"type": "always"</code>.</p>
<p>In addition, traits support two more modes: <code>#[rust_analyzer::completions(ignore_flyimport_methods)]</code>,
which means the trait itself may still be flyimported but its methods won't, and
<code>#[rust_analyzer::completions(ignore_methods)]</code>, which means the methods won't be completed even when
the trait is in scope (but the trait itself may still be completed). The methods will still be completed
on <code>dyn Trait</code>, <code>impl Trait</code> or where the trait is specified in bounds. These modes correspond to
the settings <code>rust-analyzer.completion.autoimport.exclude</code> with <code>"type": "methods"</code> and
<code>rust-analyzer.completion.excludeTraits</code>, respectively.</p>
<p>Malformed attributes will be ignored without warnings.</p>
<p>Note that users have no way to override this attribute, so be careful and only include things
users definitely do not want to be completed!</p>
<h3 id="debug-itemtree"><a class="header" href="#debug-itemtree">Debug ItemTree</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_item_tree.rs#L4">view_item_tree.rs</a></p>
<p>Displays the ItemTree of the currently open file, for debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Debug ItemTree</strong></td></tr>
</tbody></table>
</div>
<h3 id="expand-macro-recursively"><a class="header" href="#expand-macro-recursively">Expand Macro Recursively</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/expand_macro.rs#L18">expand_macro.rs</a></p>
<p>Shows the full macro expansion of the macro at the current caret position.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Expand macro recursively at caret</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif" alt="Expand Macro Recursively" /></p>
<h3 id="expand-and-shrink-selection"><a class="header" href="#expand-and-shrink-selection">Expand and Shrink Selection</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/extend_selection.rs#L15">extend_selection.rs</a></p>
<p>Extends or shrinks the current selection to the encompassing syntactic construct
(expression, statement, item, module, etc). It works with multiple cursors.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Alt+Shift+→</kbd>, <kbd>Alt+Shift+←</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020651-b42fc800-917a-11eb-8a4f-cf1a07859fac.gif" alt="Expand and Shrink Selection" /></p>
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/file_structure.rs#L31">file_structure.rs</a></p>
<p>Provides a tree of the symbols defined in the file. Can be used to</p>
<ul>
<li>fuzzy search symbol in a file (super useful)</li>
<li>draw breadcrumbs to describe the context around the cursor</li>
<li>draw outline of the file</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+Shift+O</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020654-b42fc800-917a-11eb-8388-e7dc4d92b02e.gif" alt="File Structure" /></p>
<h3 id="find-all-references"><a class="header" href="#find-all-references">Find All References</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/references.rs#L70">references.rs</a></p>
<p>Shows all references of the item at the cursor location. This includes:</p>
<ul>
<li>Direct references to variables, functions, types, etc.</li>
<li>Constructor/initialization references when cursor is on struct/enum definition tokens</li>
<li>References in patterns and type contexts</li>
<li>References through dereferencing and borrowing</li>
<li>References in macro expansions</li>
</ul>
<p>Special handling for constructors:</p>
<ul>
<li>When the cursor is on <code>{</code>, <code>(</code>, or <code>;</code> in a struct/enum definition</li>
<li>When the cursor is on the type name in a struct/enum definition
These cases will show only constructor/initialization usages of the type</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Shift+Alt+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020670-b7c34f00-917a-11eb-8003-370ac5f2b3cb.gif" alt="Find All References" /></p>
<h3 id="folding"><a class="header" href="#folding">Folding</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/folding_ranges.rs#L42">folding_ranges.rs</a></p>
<p>Defines folding regions for curly braced blocks, runs of consecutive use, mod, const or static
items, and <code>region</code> / <code>endregion</code> comment markers.</p>
<h3 id="format-string-completion"><a class="header" href="#format-string-completion">Format String Completion</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-completion/src/completions/postfix/format_like.rs#L0">format_like.rs</a></p>
<p><code>"Result {result} is {2 + 2}"</code> is expanded to the <code>"Result {} is {}", result, 2 + 2</code>.</p>
<p>The following postfix snippets are available:</p>
<ul>
<li><code>format</code> -&gt; <code>format!(...)</code></li>
<li><code>panic</code> -&gt; <code>panic!(...)</code></li>
<li><code>println</code> -&gt; <code>println!(...)</code></li>
<li><code>log</code>:
** <code>logd</code> -&gt; <code>log::debug!(...)</code>
** <code>logt</code> -&gt; <code>log::trace!(...)</code>
** <code>logi</code> -&gt; <code>log::info!(...)</code>
** <code>logw</code> -&gt; <code>log::warn!(...)</code>
** <code>loge</code> -&gt; <code>log::error!(...)</code></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif" alt="Format String Completion" /></p>
<h3 id="go-to-declaration"><a class="header" href="#go-to-declaration">Go to Declaration</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/goto_declaration.rs#L13">goto_declaration.rs</a></p>
<p>Navigates to the declaration of an identifier.</p>
<p>This is the same as <code>Go to Definition</code> with the following exceptions:</p>
<ul>
<li>outline modules will navigate to the <code>mod name;</code> item declaration</li>
<li>trait assoc items will navigate to the assoc item of the trait declaration as opposed to the trait impl</li>
<li>fields in patterns will navigate to the field declaration of the struct, union or variant</li>
</ul>
<h3 id="go-to-definition"><a class="header" href="#go-to-definition">Go to Definition</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/goto_definition.rs#L35">goto_definition.rs</a></p>
<p>Navigates to the definition of an identifier.</p>
<p>For outline modules, this will navigate to the source file of the module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065563-025fbe00-91b1-11eb-83e4-a5a703610b23.gif" alt="Go to Definition" /></p>
<h3 id="go-to-implementation"><a class="header" href="#go-to-implementation">Go to Implementation</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/goto_implementation.rs#L15">goto_implementation.rs</a></p>
<p>Navigates to the impl items of types.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065566-02f85480-91b1-11eb-9288-aaad8abd8841.gif" alt="Go to Implementation" /></p>
<h3 id="go-to-type-definition"><a class="header" href="#go-to-type-definition">Go to Type Definition</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/goto_type_definition.rs#L7">goto_type_definition.rs</a></p>
<p>Navigates to the type of an identifier.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Go to Type Definition</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020657-b560f500-917a-11eb-9007-0f809733a338.gif" alt="Go to Type Definition" /></p>
<h3 id="highlight-related"><a class="header" href="#highlight-related">Highlight Related</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/highlight_related.rs#L45">highlight_related.rs</a></p>
<p>Highlights constructs related to the thing under the cursor:</p>
<ol>
<li>if on an identifier, highlights all references to that identifier in the current file
<ul>
<li>additionally, if the identifier is a trait in a where clause, type parameter trait bound or use item, highlights all references to that trait's assoc items in the corresponding scope</li>
</ul>
</li>
<li>if on an <code>async</code> or <code>await</code> token, highlights all yield points for that async context</li>
<li>if on a <code>return</code> or <code>fn</code> keyword, <code>?</code> character or <code>-&gt;</code> return type arrow, highlights all exit points for that context</li>
<li>if on a <code>break</code>, <code>loop</code>, <code>while</code> or <code>for</code> token, highlights all break points for that loop or block context</li>
<li>if on a <code>move</code> or <code>|</code> token that belongs to a closure, highlights all captures of the closure.</li>
</ol>
<p>Note: <code>?</code>, <code>|</code> and <code>-&gt;</code> do not currently trigger this behavior in the VSCode editor.</p>
<h3 id="hover"><a class="header" href="#hover">Hover</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/hover.rs#L128">hover.rs</a></p>
<p>Shows additional information, like the type of an expression or the documentation for a definition when "focusing" code.
Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif" alt="Hover" /></p>
<h3 id="inlay-hints"><a class="header" href="#inlay-hints">Inlay Hints</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/inlay_hints.rs#L46">inlay_hints.rs</a></p>
<p>rust-analyzer shows additional information inline with the source code.
Editors usually render this using read-only virtual text snippets interspersed with code.</p>
<p>rust-analyzer by default shows hints for</p>
<ul>
<li>types of local variables</li>
<li>names of function arguments</li>
<li>names of const generic parameters</li>
<li>types of chained expressions</li>
</ul>
<p>Optionally, one can enable additional hints for</p>
<ul>
<li>return types of closure expressions</li>
<li>elided lifetimes</li>
<li>compiler inserted reborrows</li>
<li>names of generic type and lifetime parameters</li>
</ul>
<p>Note: inlay hints for function argument names are heuristically omitted to reduce noise and will not appear if
any of the
<a href="https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L92-L99">following criteria</a>
are met:</p>
<ul>
<li>the parameter name is a suffix of the function's name</li>
<li>the argument is a qualified constructing or call expression where the qualifier is an ADT</li>
<li>exact argument&lt;-&gt;parameter match(ignoring leading underscore) or parameter is a prefix/suffix
of argument with _ splitting it off</li>
<li>the parameter name starts with <code>ra_fixture</code></li>
<li>the parameter name is a
<a href="https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L200">well known name</a>
in a unary function</li>
<li>the parameter name is a
<a href="https://github.com/rust-lang/rust-analyzer/blob/6b8b8ff4c56118ddee6c531cde06add1aad4a6af/crates/ide/src/inlay_hints/param_name.rs#L201">single character</a>
in a unary function</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png" alt="Inlay hints" /></p>
<h3 id="interpret-a-function-static-or-const"><a class="header" href="#interpret-a-function-static-or-const">Interpret A Function, Static Or Const.</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/interpret.rs#L7">interpret.rs</a></p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Interpret</strong></td></tr>
</tbody></table>
</div>
<h3 id="join-lines"><a class="header" href="#join-lines">Join Lines</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/join_lines.rs#L20">join_lines.rs</a></p>
<p>Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.</p>
<p>See <a href="https://user-images.githubusercontent.com/1711539/124515923-4504e800-dde9-11eb-8d58-d97945a1a785.gif">this gif</a> for the cases handled specially by joined lines.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Join lines</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020661-b6922200-917a-11eb-87c4-b75acc028f11.gif" alt="Join Lines" /></p>
<h3 id="magic-completions"><a class="header" href="#magic-completions">Magic Completions</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-completion/src/lib.rs#L78">lib.rs</a></p>
<p>In addition to usual reference completion, rust-analyzer provides some ✨magic✨
completions as well:</p>
<p>Keywords like <code>if</code>, <code>else</code> <code>while</code>, <code>loop</code> are completed with braces, and cursor
is placed at the appropriate position. Even though <code>if</code> is easy to type, you
still want to complete it, to get <code> { }</code> for free! <code>return</code> is inserted with a
space or <code>;</code> depending on the return type of the function.</p>
<p>When completing a function call, <code>()</code> are automatically inserted. If a function
takes arguments, the cursor is positioned inside the parenthesis.</p>
<p>There are postfix completions, which can be triggered by typing something like
<code>foo().if</code>. The word after <code>.</code> determines postfix completion. Possible variants are:</p>
<ul>
<li><code>expr.if</code> -&gt; <code>if expr {}</code> or <code>if let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.match</code> -&gt; <code>match expr {}</code></li>
<li><code>expr.while</code> -&gt; <code>while expr {}</code> or <code>while let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.ref</code> -&gt; <code>&amp;expr</code></li>
<li><code>expr.refm</code> -&gt; <code>&amp;mut expr</code></li>
<li><code>expr.let</code> -&gt; <code>let $0 = expr;</code></li>
<li><code>expr.lete</code> -&gt; <code>let $1 = expr else { $0 };</code></li>
<li><code>expr.letm</code> -&gt; <code>let mut $0 = expr;</code></li>
<li><code>expr.not</code> -&gt; <code>!expr</code></li>
<li><code>expr.dbg</code> -&gt; <code>dbg!(expr)</code></li>
<li><code>expr.dbgr</code> -&gt; <code>dbg!(&amp;expr)</code></li>
<li><code>expr.call</code> -&gt; <code>(expr)</code></li>
</ul>
<p>There also snippet completions:</p>
<h4 id="expressions"><a class="header" href="#expressions">Expressions</a></h4>
<ul>
<li><code>pd</code> -&gt; <code>eprintln!(" = {:?}", );</code></li>
<li><code>ppd</code> -&gt; <code>eprintln!(" = {:#?}", );</code></li>
</ul>
<h4 id="items"><a class="header" href="#items">Items</a></h4>
<ul>
<li><code>tfn</code> -&gt; <code>#[test] fn feature(){}</code></li>
<li><code>tmod</code> -&gt;</li>
</ul>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_name() {}
}</code></pre>
<p>And the auto import completions, enabled with the <code>rust-analyzer.completion.autoimport.enable</code> setting and the corresponding LSP client capabilities.
Those are the additional completion options with automatic <code>use</code> import and options from all project importable items,
fuzzy matched against the completion input.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020667-b72ab880-917a-11eb-8778-716cf26a0eb3.gif" alt="Magic Completions" /></p>
<h3 id="matching-brace"><a class="header" href="#matching-brace">Matching Brace</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/matching_brace.rs#L6">matching_brace.rs</a></p>
<p>If the cursor is on any brace (<code>&lt;&gt;(){}[]||</code>) which is a part of a brace-pair,
moves cursor to the matching brace. It uses the actual parser to determine
braces, so it won't confuse generics with comparisons.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Find matching brace</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065573-04298180-91b1-11eb-8dec-d4e2a202f304.gif" alt="Matching Brace" /></p>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-db/src/apply_change.rs#L38">apply_change.rs</a></p>
<p>Clears rust-analyzer's internal database and prints memory usage statistics.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Memory Usage (Clears Database)</strong></td></tr>
</tbody></table>
</div>
<h3 id="move-item"><a class="header" href="#move-item">Move Item</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/move_item.rs#L16">move_item.rs</a></p>
<p>Move item under cursor or selection up and down.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item up</strong></td></tr>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item down</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif" alt="Move Item" /></p>
<h3 id="on-enter"><a class="header" href="#on-enter">On Enter</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/typing/on_enter.rs#L16">on_enter.rs</a></p>
<p>rust-analyzer can override <kbd>Enter</kbd> key to make it smarter:</p>
<ul>
<li><kbd>Enter</kbd> inside triple-slash comments automatically inserts <code>///</code></li>
<li><kbd>Enter</kbd> in the middle or after a trailing space in <code>//</code> inserts <code>//</code></li>
<li><kbd>Enter</kbd> inside <code>//!</code> doc comments automatically inserts <code>//!</code></li>
<li><kbd>Enter</kbd> after <code>{</code> indents contents and closing <code>}</code> of single-line block</li>
</ul>
<p>This action needs to be assigned to shortcut explicitly.</p>
<p>Note that, depending on the other installed extensions, this feature can visibly slow down typing.
Similarly, if rust-analyzer crashes or stops responding, <code>Enter</code> might not work.
In that case, you can still press <code>Shift-Enter</code> to insert a newline.</p>
<h4 id="vs-code-1"><a class="header" href="#vs-code-1">VS Code</a></h4>
<p>Add the following to <code>keybindings.json</code>:</p>
<pre><code class="language-json">{
  "key": "Enter",
  "command": "rust-analyzer.onEnter",
  "when": "editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust"
}
</code></pre>
<p>When using the Vim plugin:</p>
<pre><code class="language-json">{
  "key": "Enter",
  "command": "rust-analyzer.onEnter",
  "when": "editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust &amp;&amp; vim.mode == 'Insert'"
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/48062697/113065578-04c21800-91b1-11eb-82b8-22b8c481e645.gif" alt="On Enter" /></p>
<h3 id="on-typing-assists"><a class="header" href="#on-typing-assists">On Typing Assists</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/typing.rs#L44">typing.rs</a></p>
<p>Some features trigger on typing certain characters:</p>
<ul>
<li>typing <code>let =</code> tries to smartly add <code>;</code> if <code>=</code> is followed by an existing expression</li>
<li>typing <code>=</code> between two expressions adds <code>;</code> when in statement position</li>
<li>typing <code>=</code> to turn an assignment into an equality comparison removes <code>;</code> when in expression position</li>
<li>typing <code>.</code> in a chain method call auto-indents</li>
<li>typing <code>{</code> or <code>(</code> in front of an expression inserts a closing <code>}</code> or <code>)</code> after the expression</li>
<li>typing <code>{</code> in a use item adds a closing <code>}</code> in the right place</li>
<li>typing <code>&gt;</code> to complete a return type <code>-&gt;</code> will insert a whitespace after it</li>
</ul>
<h4 id="vs-code-2"><a class="header" href="#vs-code-2">VS Code</a></h4>
<p>Add the following to <code>settings.json</code>:</p>
<pre><code class="language-json">"editor.formatOnType": true,
</code></pre>
<p><img src="https://user-images.githubusercontent.com/48062697/113166163-69758500-923a-11eb-81ee-eb33ec380399.gif" alt="On Typing Assists" />
<img src="https://user-images.githubusercontent.com/48062697/113171066-105c2000-923f-11eb-87ab-f4a263346567.gif" alt="On Typing Assists" /></p>
<h3 id="open-docs"><a class="header" href="#open-docs">Open Docs</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/doc_links.rs#L138">doc_links.rs</a></p>
<p>Retrieve a links to documentation for the given symbol.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Open Docs</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Open Docs</strong></td></tr>
</tbody></table>
</div>
<h3 id="parent-module"><a class="header" href="#parent-module">Parent Module</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/parent_module.rs#L14">parent_module.rs</a></p>
<p>Navigates to the parent module of the current module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Locate parent module</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065580-04c21800-91b1-11eb-9a32-00086161c0bd.gif" alt="Parent Module" /></p>
<h3 id="related-tests"><a class="header" href="#related-tests">Related Tests</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/runnables.rs#L195">runnables.rs</a></p>
<p>Provides a sneak peek of all tests where the current item is used.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Peek Related Tests</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Peek Related Tests</strong></td></tr>
</tbody></table>
</div>
<h3 id="rename"><a class="header" href="#rename">Rename</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/rename.rs#L107">rename.rs</a></p>
<p>Renames the item below the cursor and all of its references</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F2</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065582-055aae80-91b1-11eb-8ade-2b58e6d81883.gif" alt="Rename" /></p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/runnables.rs#L122">runnables.rs</a></p>
<p>Shows a popup suggesting to run a test/benchmark/binary <strong>at the current cursor
location</strong>. Super useful for repeatedly running just a single test. Do bind this
to a shortcut!</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Run</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif" alt="Run" /></p>
<h3 id="semantic-syntax-highlighting"><a class="header" href="#semantic-syntax-highlighting">Semantic Syntax Highlighting</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/syntax_highlighting.rs#L69">syntax_highlighting.rs</a></p>
<p>rust-analyzer highlights the code semantically.
For example, <code>Bar</code> in <code>foo::Bar</code> might be colored differently depending on whether <code>Bar</code> is an enum or a trait.
rust-analyzer does not specify colors directly, instead it assigns a tag (like <code>struct</code>) and a set of modifiers (like <code>declaration</code>) to each token.
It's up to the client to map those to specific colors.</p>
<p>The general rule is that a reference to an entity gets colored the same way as the entity itself.
We also give special modifier for <code>mut</code> and <code>&amp;mut</code> local variables.</p>
<h4 id="token-tags"><a class="header" href="#token-tags">Token Tags</a></h4>
<p>Rust-analyzer currently emits the following token tags:</p>
<ul>
<li>For items:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>attribute</td><td>Emitted for attribute macros.</td></tr>
<tr><td>enum</td><td>Emitted for enums.</td></tr>
<tr><td>function</td><td>Emitted for free-standing functions.</td></tr>
<tr><td>derive</td><td>Emitted for derive macros.</td></tr>
<tr><td>macro</td><td>Emitted for function-like macros.</td></tr>
<tr><td>method</td><td>Emitted for associated functions, also knowns as methods.</td></tr>
<tr><td>namespace</td><td>Emitted for modules.</td></tr>
<tr><td>struct</td><td>Emitted for structs.</td></tr>
<tr><td>trait</td><td>Emitted for traits.</td></tr>
<tr><td>typeAlias</td><td>Emitted for type aliases and <code>Self</code> in <code>impl</code>s.</td></tr>
<tr><td>union</td><td>Emitted for unions.</td></tr>
</tbody></table>
</div>
<ul>
<li>For literals:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>boolean</td><td>Emitted for the boolean literals <code>true</code> and <code>false</code>.</td></tr>
<tr><td>character</td><td>Emitted for character literals.</td></tr>
<tr><td>number</td><td>Emitted for numeric literals.</td></tr>
<tr><td>string</td><td>Emitted for string literals.</td></tr>
<tr><td>escapeSequence</td><td>Emitted for escaped sequences inside strings like <code>\n</code>.</td></tr>
<tr><td>formatSpecifier</td><td>Emitted for format specifiers <code>{:?}</code> in <code>format!</code>-like macros.</td></tr>
</tbody></table>
</div>
<ul>
<li>For operators:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>operator</td><td>Emitted for general operators.</td></tr>
<tr><td>arithmetic</td><td>Emitted for the arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>.</td></tr>
<tr><td>bitwise</td><td>Emitted for the bitwise operators <code>|</code>, <code>&amp;</code>, <code>!</code>, <code>^</code>, <code>|=</code>, <code>&amp;=</code>, <code>^=</code>.</td></tr>
<tr><td>comparison</td><td>Emitted for the comparison oerators <code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>.</td></tr>
<tr><td>logical</td><td>Emitted for the logical operators <code>||</code>, <code>&amp;&amp;</code>, <code>!</code>.</td></tr>
</tbody></table>
</div>
<ul>
<li>For punctuation:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>punctuation</td><td>Emitted for general punctuation.</td></tr>
<tr><td>attributeBracket</td><td>Emitted for attribute invocation brackets, that is the <code>#[</code> and <code>]</code> tokens.</td></tr>
<tr><td>angle</td><td>Emitted for <code>&lt;&gt;</code> angle brackets.</td></tr>
<tr><td>brace</td><td>Emitted for <code>{}</code> braces.</td></tr>
<tr><td>bracket</td><td>Emitted for <code>[]</code> brackets.</td></tr>
<tr><td>parenthesis</td><td>Emitted for <code>()</code> parentheses.</td></tr>
<tr><td>colon</td><td>Emitted for the <code>:</code> token.</td></tr>
<tr><td>comma</td><td>Emitted for the <code>,</code> token.</td></tr>
<tr><td>dot</td><td>Emitted for the <code>.</code> token.</td></tr>
<tr><td>semi</td><td>Emitted for the <code>;</code> token.</td></tr>
<tr><td>macroBang</td><td>Emitted for the <code>!</code> token in macro calls.</td></tr>
</tbody></table>
</div>
<ul>
<li></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>builtinAttribute</td><td>Emitted for names to builtin attributes in attribute path, the <code>repr</code> in <code>#[repr(u8)]</code> for example.</td></tr>
<tr><td>builtinType</td><td>Emitted for builtin types like <code>u32</code>, <code>str</code> and <code>f32</code>.</td></tr>
<tr><td>comment</td><td>Emitted for comments.</td></tr>
<tr><td>constParameter</td><td>Emitted for const parameters.</td></tr>
<tr><td>deriveHelper</td><td>Emitted for derive helper attributes.</td></tr>
<tr><td>enumMember</td><td>Emitted for enum variants.</td></tr>
<tr><td>generic</td><td>Emitted for generic tokens that have no mapping.</td></tr>
<tr><td>keyword</td><td>Emitted for keywords.</td></tr>
<tr><td>label</td><td>Emitted for labels.</td></tr>
<tr><td>lifetime</td><td>Emitted for lifetimes.</td></tr>
<tr><td>parameter</td><td>Emitted for non-self function parameters.</td></tr>
<tr><td>property</td><td>Emitted for struct and union fields.</td></tr>
<tr><td>selfKeyword</td><td>Emitted for the self function parameter and self path-specifier.</td></tr>
<tr><td>selfTypeKeyword</td><td>Emitted for the Self type parameter.</td></tr>
<tr><td>toolModule</td><td>Emitted for tool modules.</td></tr>
<tr><td>typeParameter</td><td>Emitted for type parameters.</td></tr>
<tr><td>unresolvedReference</td><td>Emitted for unresolved references, names that rust-analyzer can't find the definition of.</td></tr>
<tr><td>variable</td><td>Emitted for locals, constants and statics.</td></tr>
</tbody></table>
</div>
<h4 id="token-modifiers"><a class="header" href="#token-modifiers">Token Modifiers</a></h4>
<p>Token modifiers allow to style some elements in the source code more precisely.</p>
<p>Rust-analyzer currently emits the following token modifiers:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>async</td><td>Emitted for async functions and the <code>async</code> and <code>await</code> keywords.</td></tr>
<tr><td>attribute</td><td>Emitted for tokens inside attributes.</td></tr>
<tr><td>callable</td><td>Emitted for locals whose types implements one of the <code>Fn*</code> traits.</td></tr>
<tr><td>constant</td><td>Emitted for const.</td></tr>
<tr><td>consuming</td><td>Emitted for locals that are being consumed when use in a function call.</td></tr>
<tr><td>controlFlow</td><td>Emitted for control-flow related tokens, this includes th <code>?</code> operator.</td></tr>
<tr><td>crateRoot</td><td>Emitted for crate names, like <code>serde</code> and <code>crate</code>.</td></tr>
<tr><td>declaration</td><td>Emitted for names of definitions, like <code>foo</code> in <code>fn foo(){}</code>.</td></tr>
<tr><td>defaultLibrary</td><td>Emitted for items from built-in crates (std, core, alloc, test and proc_macro).</td></tr>
<tr><td>documentation</td><td>Emitted for documentation comment.</td></tr>
<tr><td>injected</td><td>Emitted for doc-string injected highlighting like rust source blocks in documentation.</td></tr>
<tr><td>intraDocLink</td><td>Emitted for intra doc links in doc-string.</td></tr>
<tr><td>library</td><td>Emitted for items that are defined outside of the current crate.</td></tr>
<tr><td>macro</td><td>Emitted for tokens inside macro call.</td></tr>
<tr><td>mutable</td><td>Emitted for mutable locals and statics as well as functions taking <code>&amp;mut self</code>.</td></tr>
<tr><td>public</td><td>Emitted for items that are from the current crate and are <code>pub</code>.</td></tr>
<tr><td>reference</td><td>Emitted for locals behind a reference and functions taking <code>self</code> by reference.</td></tr>
<tr><td>static</td><td>Emitted for "static" functions, also known as functions that do not take a <code>self</code> param, as well as statics and consts.</td></tr>
<tr><td>trait</td><td>Emitted for associated trait item.</td></tr>
<tr><td>unsafe</td><td>Emitted for unsafe operations, like unsafe function calls, as well as the <code>unsafe</code> token.</td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113164457-06cfb980-9239-11eb-819b-0f93e646acf8.png" alt="Semantic Syntax Highlighting" />
<img src="https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png" alt="Semantic Syntax Highlighting" /></p>
<h3 id="show-dependency-tree"><a class="header" href="#show-dependency-tree">Show Dependency Tree</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/fetch_crates.rs#L13">fetch_crates.rs</a></p>
<p>Shows a view tree with all the dependencies of this project</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Panel Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Rust Dependencies</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/5748995/229394139-2625beab-f4c9-484b-84ed-ad5dee0b1e1a.png" alt="Show Dependency Tree" /></p>
<h3 id="show-syntax-tree"><a class="header" href="#show-syntax-tree">Show Syntax Tree</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_syntax_tree.rs#L14">view_syntax_tree.rs</a></p>
<p>Shows a tree view with the syntax tree of the current file</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Panel Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Rust Syntax Tree</strong></td></tr>
</tbody></table>
</div>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/status.rs#L7">status.rs</a></p>
<p>Shows internal statistic about memory usage of rust-analyzer.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Status</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065584-05f34500-91b1-11eb-98cc-5c196f76be7f.gif" alt="Status" /></p>
<h3 id="structural-search-and-replace"><a class="header" href="#structural-search-and-replace">Structural Search and Replace</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-ssr/src/lib.rs#L6">lib.rs</a></p>
<p>Search and replace with named wildcards that will match any expression, type, path, pattern or item.
The syntax for a structural search replace command is <code>&lt;search_pattern&gt; ==&gt;&gt; &lt;replace_pattern&gt;</code>.
A <code>$&lt;name&gt;</code> placeholder in the search pattern will match any AST node and <code>$&lt;name&gt;</code> will reference it in the replacement.
Within a macro call, a placeholder will match up until whatever token follows the placeholder.</p>
<p>All paths in both the search pattern and the replacement template must resolve in the context
in which this command is invoked. Paths in the search pattern will then match the code if they
resolve to the same item, even if they're written differently. For example if we invoke the
command in the module <code>foo</code> with a pattern of <code>Bar</code>, then code in the parent module that refers
to <code>foo::Bar</code> will match.</p>
<p>Paths in the replacement template will be rendered appropriately for the context in which the
replacement occurs. For example if our replacement template is <code>foo::Bar</code> and we match some
code in the <code>foo</code> module, we'll insert just <code>Bar</code>.</p>
<p>Inherent method calls should generally be written in UFCS form. e.g. <code>foo::Bar::baz($s, $a)</code> will
match <code>$s.baz($a)</code>, provided the method call <code>baz</code> resolves to the method <code>foo::Bar::baz</code>. When a
placeholder is the receiver of a method call in the search pattern (e.g. <code>$s.foo()</code>), but not in
the replacement template (e.g. <code>bar($s)</code>), then *, &amp; and &amp;mut will be added as needed to mirror
whatever autoderef and autoref was happening implicitly in the matched code.</p>
<p>The scope of the search / replace will be restricted to the current selection if any, otherwise
it will apply to the whole workspace.</p>
<p>Placeholders may be given constraints by writing them as <code>${&lt;name&gt;:&lt;constraint1&gt;:&lt;constraint2&gt;...}</code>.</p>
<p>Supported constraints:</p>
<div class="table-wrapper"><table><thead><tr><th>Constraint</th><th>Restricts placeholder</th></tr></thead><tbody>
<tr><td>kind(literal)</td><td>Is a literal (e.g. <code>42</code> or <code>"forty two"</code>)</td></tr>
<tr><td>not(a)</td><td>Negates the constraint <code>a</code></td></tr>
</tbody></table>
</div>
<p>Available via the command <code>rust-analyzer.ssr</code>.</p>
<pre><code class="language-rust">// Using structural search replace command [foo($a, $b) ==&gt;&gt; ($a).foo($b)]

// BEFORE
String::from(foo(y + 5, z))

// AFTER
String::from((y + 5).foo(z))</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Structural Search Replace</strong></td></tr>
</tbody></table>
</div>
<p>Also available as an assist, by writing a comment containing the structural
search and replace rule. You will only see the assist if the comment can
be parsed as a valid structural search and replace rule.</p>
<pre><code class="language-rust">// Place the cursor on the line below to see the assist 💡.
// foo($a, $b) ==&gt;&gt; ($a).foo($b)</code></pre>
<h3 id="user-snippet-completions"><a class="header" href="#user-snippet-completions">User Snippet Completions</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-completion/src/snippet.rs#L5">snippet.rs</a></p>
<p>rust-analyzer allows the user to define custom (postfix)-snippets that may depend on items to be accessible for the current scope to be applicable.</p>
<p>A custom snippet can be defined by adding it to the <code>rust-analyzer.completion.snippets.custom</code> object respectively.</p>
<pre><code class="language-json">{
  "rust-analyzer.completion.snippets.custom": {
    "thread spawn": {
      "prefix": ["spawn", "tspawn"],
      "body": [
        "thread::spawn(move || {",
        "\t$0",
        "});",
      ],
      "description": "Insert a thread::spawn call",
      "requires": "std::thread",
      "scope": "expr",
    }
  }
}
</code></pre>
<p>In the example above:</p>
<ul>
<li>
<p><code>"thread spawn"</code> is the name of the snippet.</p>
</li>
<li>
<p><code>prefix</code> defines one or more trigger words that will trigger the snippets completion.
Using <code>postfix</code> will instead create a postfix snippet.</p>
</li>
<li>
<p><code>body</code> is one or more lines of content joined via newlines for the final output.</p>
</li>
<li>
<p><code>description</code> is an optional description of the snippet, if unset the snippet name will be used.</p>
</li>
<li>
<p><code>requires</code> is an optional list of item paths that have to be resolvable in the current crate where the completion is rendered.</p>
</li>
</ul>
<h3 id="view-crate-graph"><a class="header" href="#view-crate-graph">View Crate Graph</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_crate_graph.rs#L10">view_crate_graph.rs</a></p>
<p>Renders the currently loaded crate graph as an SVG graphic. Requires the <code>dot</code> tool, which
is part of graphviz, to be installed.</p>
<p>Only workspace crates are included, no crates.io dependencies or sysroot crates.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Crate Graph</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-hir"><a class="header" href="#view-hir">View Hir</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_hir.rs#L5">view_hir.rs</a></p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Hir</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065588-068bdb80-91b1-11eb-9a78-0b4ef1e972fb.gif" alt="View Hir" /></p>
<h3 id="view-memory-layout"><a class="header" href="#view-memory-layout">View Memory Layout</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_memory_layout.rs#L73">view_memory_layout.rs</a></p>
<p>Displays the recursive memory layout of a datatype.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Memory Layout</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-mir"><a class="header" href="#view-mir">View Mir</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide/src/view_mir.rs#L5">view_mir.rs</a></p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Mir</strong></td></tr>
</tbody></table>
</div>
<h3 id="workspace-symbol"><a class="header" href="#workspace-symbol">Workspace Symbol</a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-db/src/symbol_index.rs#L164">symbol_index.rs</a></p>
<p>Uses fuzzy-search to find types, modules and functions by name across your
project and dependencies. This is <strong>the</strong> most useful feature, which improves code
navigation tremendously. It mostly works on top of the built-in LSP
functionality, however <code>#</code> and <code>*</code> symbols can be used to narrow down the
search. Specifically,</p>
<ul>
<li><code>Foo</code> searches for <code>Foo</code> type in the current workspace</li>
<li><code>foo#</code> searches for <code>foo</code> function in the current workspace</li>
<li><code>Foo*</code> searches for <code>Foo</code> type among dependencies, including <code>stdlib</code></li>
<li><code>foo#*</code> searches for <code>foo</code> function among dependencies</li>
</ul>
<p>That is, <code>#</code> switches from "types" to all symbols, <code>*</code> switches from the current
workspace to dependencies.</p>
<p>Note that filtering does not currently work in VSCode due to the editor never
sending the special symbols to the language server. Instead, you can configure
the filtering via the <code>rust-analyzer.workspace.symbol.search.scope</code> and
<code>rust-analyzer.workspace.symbol.search.kind</code> settings. Symbols prefixed
with <code>__</code> are hidden from the search results unless configured otherwise.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+T</kbd></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="assists"><a class="header" href="#assists">Assists</a></h1>
<p>Assists, or code actions, are small local refactorings, available in a
particular context. They are usually triggered by a shortcut or by
clicking a light bulb icon in the editor. Cursor position or selection
is signified by <code>┃</code> character.</p>
<h3 id="add_braces"><a class="header" href="#add_braces"><code>add_braces</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_braces.rs#L10">add_braces.rs</a></p>
<p>Adds braces to closure bodies, match arm expressions and assignment bodies.</p>
<h4 id="before"><a class="header" href="#before">Before</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt;┃ n + 1,
        _ =&gt; 0
    }
}</code></pre>
<h4 id="after"><a class="header" href="#after">After</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt; {
            n + 1
        },
        _ =&gt; 0
    }
}</code></pre>
<hr />
<h4 id="before-1"><a class="header" href="#before-1">Before</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    let x =┃ n + 2;
}</code></pre>
<h4 id="after-1"><a class="header" href="#after-1">After</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    let x = {
        n + 2
    };
}</code></pre>
<h3 id="add_explicit_enum_discriminant"><a class="header" href="#add_explicit_enum_discriminant"><code>add_explicit_enum_discriminant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_explicit_enum_discriminant.rs#L7">add_explicit_enum_discriminant.rs</a></p>
<p>Adds explicit discriminant to all enum variants.</p>
<h4 id="before-2"><a class="header" href="#before-2">Before</a></h4>
<pre><code class="language-rust">enum TheEnum┃ {
    Foo,
    Bar,
    Baz = 42,
    Quux,
}</code></pre>
<h4 id="after-2"><a class="header" href="#after-2">After</a></h4>
<pre><code class="language-rust">enum TheEnum {
    Foo = 0,
    Bar = 1,
    Baz = 42,
    Quux = 43,
}</code></pre>
<h3 id="add_explicit_type"><a class="header" href="#add_explicit_type"><code>add_explicit_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_explicit_type.rs#L8">add_explicit_type.rs</a></p>
<p>Specify type for a let binding.</p>
<h4 id="before-3"><a class="header" href="#before-3">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x┃ = 92;
}</code></pre>
<h4 id="after-3"><a class="header" href="#after-3">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x: i32 = 92;
}</code></pre>
<h3 id="add_hash"><a class="header" href="#add_hash"><code>add_hash</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L85">raw_string.rs</a></p>
<p>Adds a hash to a raw string literal.</p>
<h4 id="before-4"><a class="header" href="#before-4">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#"Hello,┃ World!"#;
}</code></pre>
<h4 id="after-4"><a class="header" href="#after-4">After</a></h4>
<pre><code class="language-rust">fn main() {
    r##"Hello, World!"##;
}</code></pre>
<h3 id="add_impl_default_members"><a class="header" href="#add_impl_default_members"><code>add_impl_default_members</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_impl_members.rs#L59">add_missing_impl_members.rs</a></p>
<p>Adds scaffold for overriding default impl members.</p>
<h4 id="before-5"><a class="header" href="#before-5">Before</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}┃
}</code></pre>
<h4 id="after-5"><a class="header" href="#after-5">After</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}

    ┃fn bar(&amp;self) {}
}</code></pre>
<h3 id="add_impl_missing_members"><a class="header" href="#add_impl_missing_members"><code>add_impl_missing_members</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_impl_members.rs#L17">add_missing_impl_members.rs</a></p>
<p>Adds scaffold for required impl members.</p>
<h4 id="before-6"><a class="header" href="#before-6">Before</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {┃

}</code></pre>
<h4 id="after-6"><a class="header" href="#after-6">After</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {
    ┃type X;

    fn foo(&amp;self) -&gt; u32 {
        todo!()
    }
}</code></pre>
<h3 id="add_label_to_loop"><a class="header" href="#add_label_to_loop"><code>add_label_to_loop</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_label_to_loop.rs#L9">add_label_to_loop.rs</a></p>
<p>Adds a label to a loop.</p>
<h4 id="before-7"><a class="header" href="#before-7">Before</a></h4>
<pre><code class="language-rust">fn main() {
    loop┃ {
        break;
        continue;
    }
}</code></pre>
<h4 id="after-7"><a class="header" href="#after-7">After</a></h4>
<pre><code class="language-rust">fn main() {
    'l: loop {
        break 'l;
        continue 'l;
    }
}</code></pre>
<h3 id="add_lifetime_to_type"><a class="header" href="#add_lifetime_to_type"><code>add_lifetime_to_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_lifetime_to_type.rs#L5">add_lifetime_to_type.rs</a></p>
<p>Adds a new lifetime to a struct, enum or union.</p>
<h4 id="before-8"><a class="header" href="#before-8">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: &amp;┃u32,
    y: u32,
}</code></pre>
<h4 id="after-8"><a class="header" href="#after-8">After</a></h4>
<pre><code class="language-rust">struct Point&lt;'a&gt; {
    x: &amp;'a u32,
    y: u32,
}</code></pre>
<h3 id="add_missing_match_arms"><a class="header" href="#add_missing_match_arms"><code>add_missing_match_arms</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_match_arms.rs#L17">add_missing_match_arms.rs</a></p>
<p>Adds missing clauses to a <code>match</code> expression.</p>
<h4 id="before-9"><a class="header" href="#before-9">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ┃
    }
}</code></pre>
<h4 id="after-9"><a class="header" href="#after-9">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; ${1:todo!()},
        Action::Stop =&gt; ${2:todo!()},┃
    }
}</code></pre>
<h3 id="add_return_type"><a class="header" href="#add_return_type"><code>add_return_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_return_type.rs#L6">add_return_type.rs</a></p>
<p>Adds the return type to a function or closure inferred from its tail expression if it doesn't have a return
type specified. This assists is useable in a functions or closures tail expression or return type position.</p>
<h4 id="before-10"><a class="header" href="#before-10">Before</a></h4>
<pre><code class="language-rust">fn foo() { 4┃2i32 }</code></pre>
<h4 id="after-10"><a class="header" href="#after-10">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="add_turbo_fish"><a class="header" href="#add_turbo_fish"><code>add_turbo_fish</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_turbo_fish.rs#L14">add_turbo_fish.rs</a></p>
<p>Adds <code>::&lt;_&gt;</code> to a call of a generic method or function.</p>
<h4 id="before-11"><a class="header" href="#before-11">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make┃();
}</code></pre>
<h4 id="after-11"><a class="header" href="#after-11">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make::&lt;${0:_}&gt;();
}</code></pre>
<h3 id="apply_demorgan"><a class="header" href="#apply_demorgan"><code>apply_demorgan</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/apply_demorgan.rs#L22">apply_demorgan.rs</a></p>
<p>Apply <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan's law</a>.
This transforms expressions of the form <code>!l || !r</code> into <code>!(l &amp;&amp; r)</code>.
This also works with <code>&amp;&amp;</code>. This assist can only be applied with the cursor
on either <code>||</code> or <code>&amp;&amp;</code>.</p>
<h4 id="before-12"><a class="header" href="#before-12">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if x != 4 ||┃ y &lt; 3.14 {}
}</code></pre>
<h4 id="after-12"><a class="header" href="#after-12">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !(x == 4 &amp;&amp; y &gt;= 3.14) {}
}</code></pre>
<h3 id="apply_demorgan_iterator"><a class="header" href="#apply_demorgan_iterator"><code>apply_demorgan_iterator</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/apply_demorgan.rs#L167">apply_demorgan.rs</a></p>
<p>Apply <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan's law</a> to
<code>Iterator::all</code> and <code>Iterator::any</code>.</p>
<p>This transforms expressions of the form <code>!iter.any(|x| predicate(x))</code> into
<code>iter.all(|x| !predicate(x))</code> and vice versa. This also works the other way for
<code>Iterator::all</code> into <code>Iterator::any</code>.</p>
<h4 id="before-13"><a class="header" href="#before-13">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let arr = [1, 2, 3];
    if !arr.into_iter().┃any(|num| num == 4) {
        println!("foo");
    }
}</code></pre>
<h4 id="after-13"><a class="header" href="#after-13">After</a></h4>
<pre><code class="language-rust">fn main() {
    let arr = [1, 2, 3];
    if arr.into_iter().all(|num| num != 4) {
        println!("foo");
    }
}</code></pre>
<h3 id="auto_import"><a class="header" href="#auto_import"><code>auto_import</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/auto_import.rs#L75">auto_import.rs</a></p>
<p>If the name is unresolved, provides all possible imports for it.</p>
<h4 id="before-14"><a class="header" href="#before-14">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap┃::new();
}</code></pre>
<h4 id="after-14"><a class="header" href="#after-14">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
}</code></pre>
<h3 id="bind_unused_param"><a class="header" href="#bind_unused_param"><code>bind_unused_param</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/bind_unused_param.rs#L8">bind_unused_param.rs</a></p>
<p>Binds unused function parameter to an underscore.</p>
<h4 id="before-15"><a class="header" href="#before-15">Before</a></h4>
<pre><code class="language-rust">fn some_function(x: i32┃) {}</code></pre>
<h4 id="after-15"><a class="header" href="#after-15">After</a></h4>
<pre><code class="language-rust">fn some_function(x: i32) {
    let _ = x;
}</code></pre>
<h3 id="change_visibility"><a class="header" href="#change_visibility"><code>change_visibility</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/change_visibility.rs#L13">change_visibility.rs</a></p>
<p>Adds or changes existing visibility specifier.</p>
<h4 id="before-16"><a class="header" href="#before-16">Before</a></h4>
<pre><code class="language-rust">┃fn frobnicate() {}</code></pre>
<h4 id="after-16"><a class="header" href="#after-16">After</a></h4>
<pre><code class="language-rust">pub(crate) fn frobnicate() {}</code></pre>
<h3 id="comment_to_doc"><a class="header" href="#comment_to_doc"><code>comment_to_doc</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_comment_from_or_to_doc.rs#L9">convert_comment_from_or_to_doc.rs</a></p>
<p>Converts comments to documentation.</p>
<h4 id="before-17"><a class="header" href="#before-17">Before</a></h4>
<pre><code class="language-rust">// Wow what ┃a nice module
// I sure hope this shows up when I hover over it</code></pre>
<h4 id="after-17"><a class="header" href="#after-17">After</a></h4>
<pre><code class="language-rust">//! Wow what a nice module
//! I sure hope this shows up when I hover over it</code></pre>
<h3 id="convert_bool_then_to_if"><a class="header" href="#convert_bool_then_to_if"><code>convert_bool_then_to_if</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_bool_then.rs#L142">convert_bool_then.rs</a></p>
<p>Converts a <code>bool::then</code> method call to an equivalent if expression.</p>
<h4 id="before-18"><a class="header" href="#before-18">Before</a></h4>
<pre><code class="language-rust">fn main() {
    (0 == 0).then┃(|| val)
}</code></pre>
<h4 id="after-18"><a class="header" href="#after-18">After</a></h4>
<pre><code class="language-rust">fn main() {
    if 0 == 0 {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h3 id="convert_bool_to_enum"><a class="header" href="#convert_bool_to_enum"><code>convert_bool_to_enum</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_bool_to_enum.rs#L24">convert_bool_to_enum.rs</a></p>
<p>This converts boolean local variables, fields, constants, and statics into a new
enum with two variants <code>Bool::True</code> and <code>Bool::False</code>, as well as replacing
all assignments with the variants and replacing all usages with <code>== Bool::True</code> or
<code>== Bool::False</code>.</p>
<h4 id="before-19"><a class="header" href="#before-19">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let ┃bool = true;

    if bool {
        println!("foo");
    }
}</code></pre>
<h4 id="after-19"><a class="header" href="#after-19">After</a></h4>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
enum Bool { True, False }

fn main() {
    let bool = Bool::True;

    if bool == Bool::True {
        println!("foo");
    }
}</code></pre>
<h3 id="convert_closure_to_fn"><a class="header" href="#convert_closure_to_fn"><code>convert_closure_to_fn</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_closure_to_fn.rs#L22">convert_closure_to_fn.rs</a></p>
<p>This converts a closure to a freestanding function, changing all captures to parameters.</p>
<h4 id="before-20"><a class="header" href="#before-20">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let mut s = String::new();
    let closure = |┃a| s.push_str(a);
    closure("abc");
}</code></pre>
<h4 id="after-20"><a class="header" href="#after-20">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut s = String::new();
    fn closure(a: &amp;str, s: &amp;mut String) {
        s.push_str(a)
    }
    closure("abc", &amp;mut s);
}</code></pre>
<h3 id="convert_for_loop_to_while_let"><a class="header" href="#convert_for_loop_to_while_let"><code>convert_for_loop_to_while_let</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_for_to_while_let.rs#L14">convert_for_to_while_let.rs</a></p>
<p>Converts a for loop into a while let on the Iterator.</p>
<h4 id="before-21"><a class="header" href="#before-21">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    for┃ v in x {
        let y = v * 2;
    };
}</code></pre>
<h4 id="after-21"><a class="header" href="#after-21">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    let mut tmp = x.into_iter();
    while let Some(v) = tmp.next() {
        let y = v * 2;
    };
}</code></pre>
<h3 id="convert_for_loop_with_for_each"><a class="header" href="#convert_for_loop_with_for_each"><code>convert_for_loop_with_for_each</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#L76">convert_iter_for_each_to_for.rs</a></p>
<p>Converts a for loop into a for_each loop on the Iterator.</p>
<h4 id="before-22"><a class="header" href="#before-22">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    for┃ v in x {
        let y = v * 2;
    }
}</code></pre>
<h4 id="after-22"><a class="header" href="#after-22">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    x.into_iter().for_each(|v| {
        let y = v * 2;
    });
}</code></pre>
<h3 id="convert_from_to_tryfrom"><a class="header" href="#convert_from_to_tryfrom"><code>convert_from_to_tryfrom</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_from_to_tryfrom.rs#L8">convert_from_to_tryfrom.rs</a></p>
<p>Converts a From impl to a TryFrom impl, wrapping returns in <code>Ok</code>.</p>
<h4 id="before-23"><a class="header" href="#before-23">Before</a></h4>
<pre><code class="language-rust">impl ┃From&lt;usize&gt; for Thing {
    fn from(val: usize) -&gt; Self {
        Thing {
            b: val.to_string(),
            a: val
        }
    }
}</code></pre>
<h4 id="after-23"><a class="header" href="#after-23">After</a></h4>
<pre><code class="language-rust">impl TryFrom&lt;usize&gt; for Thing {
    type Error = ${0:()};

    fn try_from(val: usize) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Thing {
            b: val.to_string(),
            a: val
        })
    }
}</code></pre>
<h3 id="convert_if_to_bool_then"><a class="header" href="#convert_if_to_bool_then"><code>convert_if_to_bool_then</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_bool_then.rs#L21">convert_bool_then.rs</a></p>
<p>Converts an if expression into a corresponding <code>bool::then</code> call.</p>
<h4 id="before-24"><a class="header" href="#before-24">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if┃ cond {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h4 id="after-24"><a class="header" href="#after-24">After</a></h4>
<pre><code class="language-rust">fn main() {
    cond.then(|| val)
}</code></pre>
<h3 id="convert_integer_literal"><a class="header" href="#convert_integer_literal"><code>convert_integer_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_integer_literal.rs#L5">convert_integer_literal.rs</a></p>
<p>Converts the base of integer literals to other bases.</p>
<h4 id="before-25"><a class="header" href="#before-25">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 10┃;</code></pre>
<h4 id="after-25"><a class="header" href="#after-25">After</a></h4>
<pre><code class="language-rust">const _: i32 = 0b1010;</code></pre>
<h3 id="convert_into_to_from"><a class="header" href="#convert_into_to_from"><code>convert_into_to_from</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_into_to_from.rs#L8">convert_into_to_from.rs</a></p>
<p>Converts an Into impl to an equivalent From impl.</p>
<h4 id="before-26"><a class="header" href="#before-26">Before</a></h4>
<pre><code class="language-rust">impl ┃Into&lt;Thing&gt; for usize {
    fn into(self) -&gt; Thing {
        Thing {
            b: self.to_string(),
            a: self
        }
    }
}</code></pre>
<h4 id="after-26"><a class="header" href="#after-26">After</a></h4>
<pre><code class="language-rust">impl From&lt;usize&gt; for Thing {
    fn from(val: usize) -&gt; Self {
        Thing {
            b: val.to_string(),
            a: val
        }
    }
}</code></pre>
<h3 id="convert_iter_for_each_to_for"><a class="header" href="#convert_iter_for_each_to_for"><code>convert_iter_for_each_to_for</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#L11">convert_iter_for_each_to_for.rs</a></p>
<p>Converts an Iterator::for_each function into a for loop.</p>
<h4 id="before-27"><a class="header" href="#before-27">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    iter.for_each┃(|(x, y)| {
        println!("x: {}, y: {}", x, y);
    });
}</code></pre>
<h4 id="after-27"><a class="header" href="#after-27">After</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    for (x, y) in iter {
        println!("x: {}, y: {}", x, y);
    }
}</code></pre>
<h3 id="convert_let_else_to_match"><a class="header" href="#convert_let_else_to_match"><code>convert_let_else_to_match</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_let_else_to_match.rs#L10">convert_let_else_to_match.rs</a></p>
<p>Converts let-else statement to let statement and match expression.</p>
<h4 id="before-28"><a class="header" href="#before-28">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let Ok(mut x) = f() else┃ { return };
}</code></pre>
<h4 id="after-28"><a class="header" href="#after-28">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut x = match f() {
        Ok(x) =&gt; x,
        _ =&gt; return,
    };
}</code></pre>
<h3 id="convert_match_to_let_else"><a class="header" href="#convert_match_to_let_else"><code>convert_match_to_let_else</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_match_to_let_else.rs#L13">convert_match_to_let_else.rs</a></p>
<p>Converts let statement with match initializer to let-else statement.</p>
<h4 id="before-29"><a class="header" href="#before-29">Before</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let val┃ = match opt {
        Some(it) =&gt; it,
        None =&gt; return,
    };
}</code></pre>
<h4 id="after-29"><a class="header" href="#after-29">After</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let Some(val) = opt else { return };
}</code></pre>
<h3 id="convert_named_struct_to_tuple_struct"><a class="header" href="#convert_named_struct_to_tuple_struct"><code>convert_named_struct_to_tuple_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs#L13">convert_named_struct_to_tuple_struct.rs</a></p>
<p>Converts struct with named fields to tuple struct, and analogously for enum variants with named
fields.</p>
<h4 id="before-30"><a class="header" href="#before-30">Before</a></h4>
<pre><code class="language-rust">struct Point┃ { x: f32, y: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { x, y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.x
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.y
    }
}</code></pre>
<h4 id="after-30"><a class="header" href="#after-30">After</a></h4>
<pre><code class="language-rust">struct Point(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h3 id="convert_nested_function_to_closure"><a class="header" href="#convert_nested_function_to_closure"><code>convert_nested_function_to_closure</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_nested_function_to_closure.rs#L7">convert_nested_function_to_closure.rs</a></p>
<p>Converts a function that is defined within the body of another function into a closure.</p>
<h4 id="before-31"><a class="header" href="#before-31">Before</a></h4>
<pre><code class="language-rust">fn main() {
    fn fo┃o(label: &amp;str, number: u64) {
        println!("{}: {}", label, number);
    }

    foo("Bar", 100);
}</code></pre>
<h4 id="after-31"><a class="header" href="#after-31">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = |label: &amp;str, number: u64| {
        println!("{}: {}", label, number);
    };

    foo("Bar", 100);
}</code></pre>
<h3 id="convert_to_guarded_return"><a class="header" href="#convert_to_guarded_return"><code>convert_to_guarded_return</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_to_guarded_return.rs#L23">convert_to_guarded_return.rs</a></p>
<p>Replace a large conditional with a guarded return.</p>
<h4 id="before-32"><a class="header" href="#before-32">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃if cond {
        foo();
        bar();
    }
}</code></pre>
<h4 id="after-32"><a class="header" href="#after-32">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !cond {
        return;
    }
    foo();
    bar();
}</code></pre>
<h3 id="convert_tuple_return_type_to_struct"><a class="header" href="#convert_tuple_return_type_to_struct"><code>convert_tuple_return_type_to_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_tuple_return_type_to_struct.rs#L21">convert_tuple_return_type_to_struct.rs</a></p>
<p>This converts the return type of a function from a tuple type
into a tuple struct and updates the body accordingly.</p>
<h4 id="before-33"><a class="header" href="#before-33">Before</a></h4>
<pre><code class="language-rust">fn bar() {
    let (a, b, c) = foo();
}

fn foo() -&gt; (┃u32, u32, u32) {
    (1, 2, 3)
}</code></pre>
<h4 id="after-33"><a class="header" href="#after-33">After</a></h4>
<pre><code class="language-rust">fn bar() {
    let FooResult(a, b, c) = foo();
}

struct FooResult(u32, u32, u32);

fn foo() -&gt; FooResult {
    FooResult(1, 2, 3)
}</code></pre>
<h3 id="convert_tuple_struct_to_named_struct"><a class="header" href="#convert_tuple_struct_to_named_struct"><code>convert_tuple_struct_to_named_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs#L16">convert_tuple_struct_to_named_struct.rs</a></p>
<p>Converts tuple struct to struct with named fields, and analogously for tuple enum variants.</p>
<h4 id="before-34"><a class="header" href="#before-34">Before</a></h4>
<pre><code class="language-rust">struct Point┃(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h4 id="after-34"><a class="header" href="#after-34">After</a></h4>
<pre><code class="language-rust">struct Point { field1: f32, field2: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { field1: x, field2: y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.field1
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.field2
    }
}</code></pre>
<h3 id="convert_two_arm_bool_match_to_matches_macro"><a class="header" href="#convert_two_arm_bool_match_to_matches_macro"><code>convert_two_arm_bool_match_to_matches_macro</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs#L8">convert_two_arm_bool_match_to_matches_macro.rs</a></p>
<p>Convert 2-arm match that evaluates to a boolean into the equivalent matches! invocation.</p>
<h4 id="before-35"><a class="header" href="#before-35">Before</a></h4>
<pre><code class="language-rust">fn main() {
    match scrutinee┃ {
        Some(val) if val.cond() =&gt; true,
        _ =&gt; false,
    }
}</code></pre>
<h4 id="after-35"><a class="header" href="#after-35">After</a></h4>
<pre><code class="language-rust">fn main() {
    matches!(scrutinee, Some(val) if val.cond())
}</code></pre>
<h3 id="convert_while_to_loop"><a class="header" href="#convert_while_to_loop"><code>convert_while_to_loop</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_while_to_loop.rs#L20">convert_while_to_loop.rs</a></p>
<p>Replace a while with a loop.</p>
<h4 id="before-36"><a class="header" href="#before-36">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃while cond {
        foo();
    }
}</code></pre>
<h4 id="after-36"><a class="header" href="#after-36">After</a></h4>
<pre><code class="language-rust">fn main() {
    loop {
        if !cond {
            break;
        }
        foo();
    }
}</code></pre>
<h3 id="destructure_struct_binding"><a class="header" href="#destructure_struct_binding"><code>destructure_struct_binding</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/destructure_struct_binding.rs#L19">destructure_struct_binding.rs</a></p>
<p>Destructures a struct binding in place.</p>
<h4 id="before-37"><a class="header" href="#before-37">Before</a></h4>
<pre><code class="language-rust">struct Foo {
    bar: i32,
    baz: i32,
}
fn main() {
    let ┃foo = Foo { bar: 1, baz: 2 };
    let bar2 = foo.bar;
    let baz2 = &amp;foo.baz;
}</code></pre>
<h4 id="after-37"><a class="header" href="#after-37">After</a></h4>
<pre><code class="language-rust">struct Foo {
    bar: i32,
    baz: i32,
}
fn main() {
    let Foo { bar, baz } = Foo { bar: 1, baz: 2 };
    let bar2 = bar;
    let baz2 = &amp;baz;
}</code></pre>
<h3 id="destructure_tuple_binding"><a class="header" href="#destructure_tuple_binding"><code>destructure_tuple_binding</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/destructure_tuple_binding.rs#L20">destructure_tuple_binding.rs</a></p>
<p>Destructures a tuple binding in place.</p>
<h4 id="before-38"><a class="header" href="#before-38">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let ┃t = (1,2);
    let v = t.0;
}</code></pre>
<h4 id="after-38"><a class="header" href="#after-38">After</a></h4>
<pre><code class="language-rust">fn main() {
    let (┃_0, _1) = (1,2);
    let v = _0;
}</code></pre>
<h3 id="desugar_async_into_impl_future"><a class="header" href="#desugar_async_into_impl_future"><code>desugar_async_into_impl_future</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/toggle_async_sugar.rs#L100">toggle_async_sugar.rs</a></p>
<p>Rewrites asynchronous function from <code>async fn</code> into <code>-&gt; impl Future</code>.
This action does not touch the function body and therefore <code>0</code>
block does not transform to <code>async { 0 }</code>.</p>
<h4 id="before-39"><a class="header" href="#before-39">Before</a></h4>
<pre><code class="language-rust">pub as┃ync fn foo() -&gt; usize {
    0
}</code></pre>
<h4 id="after-39"><a class="header" href="#after-39">After</a></h4>
<pre><code class="language-rust">pub fn foo() -&gt; impl core::future::Future&lt;Output = usize&gt; {
    0
}</code></pre>
<h3 id="desugar_doc_comment"><a class="header" href="#desugar_doc_comment"><code>desugar_doc_comment</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/desugar_doc_comment.rs#L14">desugar_doc_comment.rs</a></p>
<p>Desugars doc-comments to the attribute form.</p>
<h4 id="before-40"><a class="header" href="#before-40">Before</a></h4>
<pre><code class="language-rust">/// Multi-line┃
/// comment</code></pre>
<h4 id="after-40"><a class="header" href="#after-40">After</a></h4>
<pre><code class="language-rust">#[doc = r"Multi-line
comment"]</code></pre>
<h3 id="desugar_try_expr_let_else"><a class="header" href="#desugar_try_expr_let_else"><code>desugar_try_expr_let_else</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/desugar_try_expr.rs#L39">desugar_try_expr.rs</a></p>
<p>Replaces a <code>try</code> expression with a <code>let else</code> statement.</p>
<h4 id="before-41"><a class="header" href="#before-41">Before</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = Some(true)┃?;
}</code></pre>
<h4 id="after-41"><a class="header" href="#after-41">After</a></h4>
<pre><code class="language-rust">fn handle() {
    let Some(pat) = Some(true) else {
        return None;
    };
}</code></pre>
<h3 id="desugar_try_expr_match"><a class="header" href="#desugar_try_expr_match"><code>desugar_try_expr_match</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/desugar_try_expr.rs#L19">desugar_try_expr.rs</a></p>
<p>Replaces a <code>try</code> expression with a <code>match</code> expression.</p>
<h4 id="before-42"><a class="header" href="#before-42">Before</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = Some(true)┃?;
}</code></pre>
<h4 id="after-42"><a class="header" href="#after-42">After</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = match Some(true) {
        Some(it) =&gt; it,
        None =&gt; return None,
    };
}</code></pre>
<h3 id="expand_glob_import"><a class="header" href="#expand_glob_import"><code>expand_glob_import</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_glob_import.rs#L19">expand_glob_import.rs</a></p>
<p>Expands glob imports.</p>
<h4 id="before-43"><a class="header" href="#before-43">Before</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::*┃;

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h4 id="after-43"><a class="header" href="#after-43">After</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::{Bar, Baz};

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h3 id="expand_glob_reexport"><a class="header" href="#expand_glob_reexport"><code>expand_glob_reexport</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_glob_import.rs#L81">expand_glob_import.rs</a></p>
<p>Expands non-private glob imports.</p>
<h4 id="before-44"><a class="header" href="#before-44">Before</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

pub use foo::*┃;</code></pre>
<h4 id="after-44"><a class="header" href="#after-44">After</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

pub use foo::{Bar, Baz};</code></pre>
<h3 id="expand_record_rest_pattern"><a class="header" href="#expand_record_rest_pattern"><code>expand_record_rest_pattern</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_rest_pattern.rs#L11">expand_rest_pattern.rs</a></p>
<p>Fills fields by replacing rest pattern in record patterns.</p>
<h4 id="before-45"><a class="header" href="#before-45">Before</a></h4>
<pre><code class="language-rust">struct Bar { y: Y, z: Z }

fn foo(bar: Bar) {
    let Bar { ..┃ } = bar;
}</code></pre>
<h4 id="after-45"><a class="header" href="#after-45">After</a></h4>
<pre><code class="language-rust">struct Bar { y: Y, z: Z }

fn foo(bar: Bar) {
    let Bar { y, z } = bar;
}</code></pre>
<h3 id="expand_slice_rest_pattern"><a class="header" href="#expand_slice_rest_pattern"><code>expand_slice_rest_pattern</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_rest_pattern.rs#L226">expand_rest_pattern.rs</a></p>
<p>Fills fields by replacing rest pattern in slice patterns.</p>
<h4 id="before-46"><a class="header" href="#before-46">Before</a></h4>
<pre><code class="language-rust">fn foo(bar: [i32; 3]) {
    let [first, ..┃] = bar;
}</code></pre>
<h4 id="after-46"><a class="header" href="#after-46">After</a></h4>
<pre><code class="language-rust">fn foo(bar: [i32; 3]) {
    let [first, _1, _2] = bar;
}</code></pre>
<h3 id="expand_tuple_rest_pattern"><a class="header" href="#expand_tuple_rest_pattern"><code>expand_tuple_rest_pattern</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_rest_pattern.rs#L161">expand_rest_pattern.rs</a></p>
<p>Fills fields by replacing rest pattern in tuple patterns.</p>
<h4 id="before-47"><a class="header" href="#before-47">Before</a></h4>
<pre><code class="language-rust">fn foo(bar: (char, i32, i32)) {
    let (ch, ..┃) = bar;
}</code></pre>
<h4 id="after-47"><a class="header" href="#after-47">After</a></h4>
<pre><code class="language-rust">fn foo(bar: (char, i32, i32)) {
    let (ch, _1, _2) = bar;
}</code></pre>
<h3 id="expand_tuple_struct_rest_pattern"><a class="header" href="#expand_tuple_struct_rest_pattern"><code>expand_tuple_struct_rest_pattern</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_rest_pattern.rs#L76">expand_rest_pattern.rs</a></p>
<p>Fills fields by replacing rest pattern in tuple struct patterns.</p>
<h4 id="before-48"><a class="header" href="#before-48">Before</a></h4>
<pre><code class="language-rust">struct Bar(Y, Z);

fn foo(bar: Bar) {
    let Bar(..┃) = bar;
}</code></pre>
<h4 id="after-48"><a class="header" href="#after-48">After</a></h4>
<pre><code class="language-rust">struct Bar(Y, Z);

fn foo(bar: Bar) {
    let Bar(_0, _1) = bar;
}</code></pre>
<h3 id="extract_constant"><a class="header" href="#extract_constant"><code>extract_constant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_variable.rs#L37">extract_variable.rs</a></p>
<p>Extracts subexpression into a constant.</p>
<h4 id="before-49"><a class="header" href="#before-49">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃(1 + 2)┃ * 4;
}</code></pre>
<h4 id="after-49"><a class="header" href="#after-49">After</a></h4>
<pre><code class="language-rust">fn main() {
    const ┃VAR_NAME: i32 = 1 + 2;
    VAR_NAME * 4;
}</code></pre>
<h3 id="extract_expressions_from_format_string"><a class="header" href="#extract_expressions_from_format_string"><code>extract_expressions_from_format_string</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_expressions_from_format_string.rs#L14">extract_expressions_from_format_string.rs</a></p>
<p>Move an expression out of a format string.</p>
<h4 id="before-50"><a class="header" href="#before-50">Before</a></h4>
<pre><code class="language-rust">fn main() {
    print!("{var} {x + 1}┃");
}</code></pre>
<h4 id="after-50"><a class="header" href="#after-50">After</a></h4>
<pre><code class="language-rust">fn main() {
    print!("{var} {}"┃, x + 1);
}</code></pre>
<h3 id="extract_function"><a class="header" href="#extract_function"><code>extract_function</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_function.rs#L40">extract_function.rs</a></p>
<p>Extracts selected statements and comments into new function.</p>
<h4 id="before-51"><a class="header" href="#before-51">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    ┃let m = n + 2;
    // calculate
    let k = m + n;┃
    let g = 3;
}</code></pre>
<h4 id="after-51"><a class="header" href="#after-51">After</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    fun_name(n);
    let g = 3;
}

fn ┃fun_name(n: i32) {
    let m = n + 2;
    // calculate
    let k = m + n;
}</code></pre>
<h3 id="extract_module"><a class="header" href="#extract_module"><code>extract_module</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_module.rs#L29">extract_module.rs</a></p>
<p>Extracts a selected region as separate module. All the references, visibility and imports are
resolved.</p>
<h4 id="before-52"><a class="header" href="#before-52">Before</a></h4>
<pre><code class="language-rust">┃fn foo(name: i32) -&gt; i32 {
    name + 1
}┃

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h4 id="after-52"><a class="header" href="#after-52">After</a></h4>
<pre><code class="language-rust">mod modname {
    pub(crate) fn foo(name: i32) -&gt; i32 {
        name + 1
    }
}

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h3 id="extract_static"><a class="header" href="#extract_static"><code>extract_static</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_variable.rs#L54">extract_variable.rs</a></p>
<p>Extracts subexpression into a static.</p>
<h4 id="before-53"><a class="header" href="#before-53">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃(1 + 2)┃ * 4;
}</code></pre>
<h4 id="after-53"><a class="header" href="#after-53">After</a></h4>
<pre><code class="language-rust">fn main() {
    static ┃VAR_NAME: i32 = 1 + 2;
    VAR_NAME * 4;
}</code></pre>
<h3 id="extract_struct_from_enum_variant"><a class="header" href="#extract_struct_from_enum_variant"><code>extract_struct_from_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs#L28">extract_struct_from_enum_variant.rs</a></p>
<p>Extracts a struct from enum variant.</p>
<h4 id="before-54"><a class="header" href="#before-54">Before</a></h4>
<pre><code class="language-rust">enum A { ┃One(u32, u32) }</code></pre>
<h4 id="after-54"><a class="header" href="#after-54">After</a></h4>
<pre><code class="language-rust">struct One(u32, u32);

enum A { One(One) }</code></pre>
<h3 id="extract_type_alias"><a class="header" href="#extract_type_alias"><code>extract_type_alias</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_type_alias.rs#L10">extract_type_alias.rs</a></p>
<p>Extracts the selected type as a type alias.</p>
<h4 id="before-55"><a class="header" href="#before-55">Before</a></h4>
<pre><code class="language-rust">struct S {
    field: ┃(u8, u8, u8)┃,
}</code></pre>
<h4 id="after-55"><a class="header" href="#after-55">After</a></h4>
<pre><code class="language-rust">type ┃Type = (u8, u8, u8);

struct S {
    field: Type,
}</code></pre>
<h3 id="extract_variable"><a class="header" href="#extract_variable"><code>extract_variable</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_variable.rs#L20">extract_variable.rs</a></p>
<p>Extracts subexpression into a variable.</p>
<h4 id="before-56"><a class="header" href="#before-56">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃(1 + 2)┃ * 4;
}</code></pre>
<h4 id="after-56"><a class="header" href="#after-56">After</a></h4>
<pre><code class="language-rust">fn main() {
    let ┃var_name = 1 + 2;
    var_name * 4;
}</code></pre>
<h3 id="fix_visibility"><a class="header" href="#fix_visibility"><code>fix_visibility</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/fix_visibility.rs#L10">fix_visibility.rs</a></p>
<p>Note that there is some duplication between this and the no_such_field diagnostic.</p>
<p>Makes inaccessible item public.</p>
<h4 id="before-57"><a class="header" href="#before-57">Before</a></h4>
<pre><code class="language-rust">mod m {
    fn frobnicate() {}
}
fn main() {
    m::frobnicate┃();
}</code></pre>
<h4 id="after-57"><a class="header" href="#after-57">After</a></h4>
<pre><code class="language-rust">mod m {
    ┃pub(crate) fn frobnicate() {}
}
fn main() {
    m::frobnicate();
}</code></pre>
<h3 id="flip_binexpr"><a class="header" href="#flip_binexpr"><code>flip_binexpr</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_binexpr.rs#L9">flip_binexpr.rs</a></p>
<p>Flips operands of a binary expression.</p>
<h4 id="before-58"><a class="header" href="#before-58">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 90 +┃ 2;
}</code></pre>
<h4 id="after-58"><a class="header" href="#after-58">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 2 + 90;
}</code></pre>
<h3 id="flip_comma"><a class="header" href="#flip_comma"><code>flip_comma</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_comma.rs#L10">flip_comma.rs</a></p>
<p>Flips two comma-separated items.</p>
<h4 id="before-59"><a class="header" href="#before-59">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ((1, 2),┃ (3, 4));
}</code></pre>
<h4 id="after-59"><a class="header" href="#after-59">After</a></h4>
<pre><code class="language-rust">fn main() {
    ((3, 4), (1, 2));
}</code></pre>
<h3 id="flip_or_pattern"><a class="header" href="#flip_or_pattern"><code>flip_or_pattern</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_or_pattern.rs#L9">flip_or_pattern.rs</a></p>
<p>Flips two patterns in an or-pattern.</p>
<h4 id="before-60"><a class="header" href="#before-60">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let (a |┃ b) = 1;
}</code></pre>
<h4 id="after-60"><a class="header" href="#after-60">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let (b | a) = 1;
}</code></pre>
<h3 id="flip_range_expr"><a class="header" href="#flip_range_expr"><code>flip_range_expr</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_binexpr.rs#L91">flip_binexpr.rs</a></p>
<p>Flips operands of a range expression.</p>
<h4 id="before-61"><a class="header" href="#before-61">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 90..┃2;
}</code></pre>
<h4 id="after-61"><a class="header" href="#after-61">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 2..90;
}</code></pre>
<hr />
<h4 id="before-62"><a class="header" href="#before-62">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 90..┃;
}</code></pre>
<h4 id="after-62"><a class="header" href="#after-62">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = ..90;
}</code></pre>
<h3 id="flip_trait_bound"><a class="header" href="#flip_trait_bound"><code>flip_trait_bound</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_trait_bound.rs#L9">flip_trait_bound.rs</a></p>
<p>Flips two trait bounds.</p>
<h4 id="before-63"><a class="header" href="#before-63">Before</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Clone +┃ Copy&gt;() { }</code></pre>
<h4 id="after-63"><a class="header" href="#after-63">After</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Copy + Clone&gt;() { }</code></pre>
<h3 id="generate_blanket_trait_impl"><a class="header" href="#generate_blanket_trait_impl"><code>generate_blanket_trait_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_blanket_trait_impl.rs#L21">generate_blanket_trait_impl.rs</a></p>
<p>Generate blanket trait implementation.</p>
<h4 id="before-64"><a class="header" href="#before-64">Before</a></h4>
<pre><code class="language-rust">trait ┃Foo&lt;T: Send&gt;: ToOwned
where
    Self::Owned: Default,
{
    fn foo(&amp;self) -&gt; T;

    fn print_foo(&amp;self) {
        println!("{}", self.foo());
    }
}</code></pre>
<h4 id="after-64"><a class="header" href="#after-64">After</a></h4>
<pre><code class="language-rust">trait Foo&lt;T: Send&gt;: ToOwned
where
    Self::Owned: Default,
{
    fn foo(&amp;self) -&gt; T;

    fn print_foo(&amp;self) {
        println!("{}", self.foo());
    }
}

impl&lt;T: Send, T1: ToOwned + ?Sized&gt; Foo&lt;T&gt; for ┃T1
where
    Self::Owned: Default,
{
    fn foo(&amp;self) -&gt; T {
        todo!()
    }
}</code></pre>
<h3 id="generate_constant"><a class="header" href="#generate_constant"><code>generate_constant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_constant.rs#L13">generate_constant.rs</a></p>
<p>Generate a named constant.</p>
<h4 id="before-65"><a class="header" href="#before-65">Before</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    let v = S::new(CAPA┃CITY);
}</code></pre>
<h4 id="after-65"><a class="header" href="#after-65">After</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    const CAPACITY: usize = ┃;
    let v = S::new(CAPACITY);
}</code></pre>
<h3 id="generate_default_from_enum_variant"><a class="header" href="#generate_default_from_enum_variant"><code>generate_default_from_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs#L6">generate_default_from_enum_variant.rs</a></p>
<p>Adds a Default impl for an enum using a variant.</p>
<h4 id="before-66"><a class="header" href="#before-66">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor┃,
 Major,
}</code></pre>
<h4 id="after-66"><a class="header" href="#after-66">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Default for Version {
    fn default() -&gt; Self {
        Self::Minor
    }
}</code></pre>
<h3 id="generate_default_from_new"><a class="header" href="#generate_default_from_new"><code>generate_default_from_new</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_default_from_new.rs#L13">generate_default_from_new.rs</a></p>
<p>Generates default implementation from new method.</p>
<h4 id="before-67"><a class="header" href="#before-67">Before</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn n┃ew() -&gt; Self {
        Self { _inner: () }
    }
}</code></pre>
<h4 id="after-67"><a class="header" href="#after-67">After</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn new() -&gt; Self {
        Self { _inner: () }
    }
}

impl Default for Example {
    fn default() -&gt; Self {
        Self::new()
    }
}</code></pre>
<h3 id="generate_delegate_methods"><a class="header" href="#generate_delegate_methods"><code>generate_delegate_methods</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_delegate_methods.rs#L17">generate_delegate_methods.rs</a></p>
<p>Generate delegate methods.</p>
<h4 id="before-68"><a class="header" href="#before-68">Before</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    ag┃e: Age,
}</code></pre>
<h4 id="after-68"><a class="header" href="#after-68">After</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    age: Age,
}

impl Person {
    ┃fn age(&amp;self) -&gt; u8 {
        self.age.age()
    }
}</code></pre>
<h3 id="generate_delegate_trait"><a class="header" href="#generate_delegate_trait"><code>generate_delegate_trait</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_delegate_trait.rs#L28">generate_delegate_trait.rs</a></p>
<p>Generate delegate trait implementation for <code>StructField</code>s.</p>
<h4 id="before-69"><a class="header" href="#before-69">Before</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a┃: A,
}</code></pre>
<h4 id="after-69"><a class="header" href="#after-69">After</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a: A,
}

impl SomeTrait for B {
    type T = &lt;A as SomeTrait&gt;::T;

    fn fn_(arg: u32) -&gt; u32 {
        &lt;A as SomeTrait&gt;::fn_(arg)
    }

    fn method_(&amp;mut self) -&gt; bool {
        &lt;A as SomeTrait&gt;::method_(&amp;mut self.a)
    }
}</code></pre>
<h3 id="generate_deref"><a class="header" href="#generate_deref"><code>generate_deref</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_deref.rs#L16">generate_deref.rs</a></p>
<p>Generate <code>Deref</code> impl using the given struct field.</p>
<h4 id="before-70"><a class="header" href="#before-70">Before</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   ┃a: A
}</code></pre>
<h4 id="after-70"><a class="header" href="#after-70">After</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   a: A
}

impl core::ops::Deref for B {
    type Target = A;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.a
    }
}</code></pre>
<h3 id="generate_derive"><a class="header" href="#generate_derive"><code>generate_derive</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_derive.rs#L10">generate_derive.rs</a></p>
<p>Adds a new <code>#[derive()]</code> clause to a struct or enum.</p>
<h4 id="before-71"><a class="header" href="#before-71">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: u32,
    y: u32,┃
}</code></pre>
<h4 id="after-71"><a class="header" href="#after-71">After</a></h4>
<pre><code class="language-rust">#[derive(┃)]
struct Point {
    x: u32,
    y: u32,
}</code></pre>
<h3 id="generate_doc_example"><a class="header" href="#generate_doc_example"><code>generate_doc_example</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_documentation_template.rs#L77">generate_documentation_template.rs</a></p>
<p>Generates a rustdoc example when editing an item's documentation.</p>
<h4 id="before-72"><a class="header" href="#before-72">Before</a></h4>
<pre><code class="language-rust">/// Adds two numbers.┃
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h4 id="after-72"><a class="header" href="#after-72">After</a></h4>
<pre><code class="language-rust">/// Adds two numbers.
///
/// # Examples
///
/// ```
/// use ra_test_fixture::add;
///
/// assert_eq!(add(a, b), );
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h3 id="generate_documentation_template"><a class="header" href="#generate_documentation_template"><code>generate_documentation_template</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_documentation_template.rs#L14">generate_documentation_template.rs</a></p>
<p>Adds a documentation template above a function definition / declaration.</p>
<h4 id="before-73"><a class="header" href="#before-73">Before</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    pub unsafe fn set_len┃(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h4 id="after-73"><a class="header" href="#after-73">After</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    /// Sets the length of this [`S`].
    ///
    /// # Errors
    ///
    /// This function will return an error if .
    ///
    /// # Safety
    ///
    /// .
    pub unsafe fn set_len(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h3 id="generate_enum_as_method"><a class="header" href="#generate_enum_as_method"><code>generate_enum_as_method</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#L61">generate_enum_projection_method.rs</a></p>
<p>Generate an <code>as_</code> method for this enum variant.</p>
<h4 id="before-74"><a class="header" href="#before-74">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)┃,
}</code></pre>
<h4 id="after-74"><a class="header" href="#after-74">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn as_text(&amp;self) -&gt; Option&lt;&amp;String&gt; {
        if let Self::Text(v) = self {
            Some(v)
        } else {
            None
        }
    }
}</code></pre>
<h3 id="generate_enum_is_method"><a class="header" href="#generate_enum_is_method"><code>generate_enum_is_method</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_is_method.rs#L13">generate_enum_is_method.rs</a></p>
<p>Generate an <code>is_</code> method for this enum variant.</p>
<h4 id="before-75"><a class="header" href="#before-75">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor┃,
 Major,
}</code></pre>
<h4 id="after-75"><a class="header" href="#after-75">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Version {
    /// Returns `true` if the version is [`Minor`].
    ///
    /// [`Minor`]: Version::Minor
    #[must_use]
    fn is_minor(&amp;self) -&gt; bool {
        matches!(self, Self::Minor)
    }
}</code></pre>
<h3 id="generate_enum_try_into_method"><a class="header" href="#generate_enum_try_into_method"><code>generate_enum_try_into_method</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#L14">generate_enum_projection_method.rs</a></p>
<p>Generate a <code>try_into_</code> method for this enum variant.</p>
<h4 id="before-76"><a class="header" href="#before-76">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)┃,
}</code></pre>
<h4 id="after-76"><a class="header" href="#after-76">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn try_into_text(self) -&gt; Result&lt;String, Self&gt; {
        if let Self::Text(v) = self {
            Ok(v)
        } else {
            Err(self)
        }
    }
}</code></pre>
<h3 id="generate_enum_variant"><a class="header" href="#generate_enum_variant"><code>generate_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_variant.rs#L11">generate_enum_variant.rs</a></p>
<p>Adds a variant to an enum.</p>
<h4 id="before-77"><a class="header" href="#before-77">Before</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
}

fn main() {
    let country = Countries::Lesotho┃;
}</code></pre>
<h4 id="after-77"><a class="header" href="#after-77">After</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
    Lesotho,
}

fn main() {
    let country = Countries::Lesotho;
}</code></pre>
<h3 id="generate_fn_type_alias_named"><a class="header" href="#generate_fn_type_alias_named"><code>generate_fn_type_alias_named</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_fn_type_alias.rs#L11">generate_fn_type_alias.rs</a></p>
<p>Generate a type alias for the function with named parameters.</p>
<h4 id="before-78"><a class="header" href="#before-78">Before</a></h4>
<pre><code class="language-rust">unsafe fn fo┃o(n: i32) -&gt; i32 { 42i32 }</code></pre>
<h4 id="after-78"><a class="header" href="#after-78">After</a></h4>
<pre><code class="language-rust">type ${0:FooFn} = unsafe fn(n: i32) -&gt; i32;

unsafe fn foo(n: i32) -&gt; i32 { 42i32 }</code></pre>
<h3 id="generate_fn_type_alias_unnamed"><a class="header" href="#generate_fn_type_alias_unnamed"><code>generate_fn_type_alias_unnamed</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_fn_type_alias.rs#L25">generate_fn_type_alias.rs</a></p>
<p>Generate a type alias for the function with unnamed parameters.</p>
<h4 id="before-79"><a class="header" href="#before-79">Before</a></h4>
<pre><code class="language-rust">unsafe fn fo┃o(n: i32) -&gt; i32 { 42i32 }</code></pre>
<h4 id="after-79"><a class="header" href="#after-79">After</a></h4>
<pre><code class="language-rust">type ${0:FooFn} = unsafe fn(i32) -&gt; i32;

unsafe fn foo(n: i32) -&gt; i32 { 42i32 }</code></pre>
<h3 id="generate_from_impl_for_enum"><a class="header" href="#generate_from_impl_for_enum"><code>generate_from_impl_for_enum</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs#L7">generate_from_impl_for_enum.rs</a></p>
<p>Adds a From impl for this enum variant with one tuple field.</p>
<h4 id="before-80"><a class="header" href="#before-80">Before</a></h4>
<pre><code class="language-rust">enum A { ┃One(u32) }</code></pre>
<h4 id="after-80"><a class="header" href="#after-80">After</a></h4>
<pre><code class="language-rust">enum A { One(u32) }

impl From&lt;u32&gt; for A {
    fn from(v: u32) -&gt; Self {
        Self::One(v)
    }
}</code></pre>
<h3 id="generate_function"><a class="header" href="#generate_function"><code>generate_function</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_function.rs#L30">generate_function.rs</a></p>
<p>Adds a stub function with a signature matching the function under the cursor.</p>
<h4 id="before-81"><a class="header" href="#before-81">Before</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar┃("", baz());
}
</code></pre>
<h4 id="after-81"><a class="header" href="#after-81">After</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar("", baz());
}

fn bar(arg: &amp;'static str, baz: Baz) ${0:-&gt; _} {
    todo!()
}
</code></pre>
<h3 id="generate_getter"><a class="header" href="#generate_getter"><code>generate_getter</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L74">generate_getter_or_setter.rs</a></p>
<p>Generate a getter method.</p>
<h4 id="before-82"><a class="header" href="#before-82">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-82"><a class="header" href="#after-82">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}</code></pre>
<h3 id="generate_getter_mut"><a class="header" href="#generate_getter_mut"><code>generate_getter_mut</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L128">generate_getter_or_setter.rs</a></p>
<p>Generate a mut getter method.</p>
<h4 id="before-83"><a class="header" href="#before-83">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-83"><a class="header" href="#after-83">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃name_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.name
    }
}</code></pre>
<h3 id="generate_impl"><a class="header" href="#generate_impl"><code>generate_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_impl.rs#L25">generate_impl.rs</a></p>
<p>Adds a new inherent impl for a type.</p>
<h4 id="before-84"><a class="header" href="#before-84">Before</a></h4>
<pre><code class="language-rust">struct Ctx┃&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-84"><a class="header" href="#after-84">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {┃}</code></pre>
<h3 id="generate_impl_trait"><a class="header" href="#generate_impl_trait"><code>generate_impl_trait</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_impl.rs#L128">generate_impl.rs</a></p>
<p>Adds this trait impl for a type.</p>
<h4 id="before-85"><a class="header" href="#before-85">Before</a></h4>
<pre><code class="language-rust">trait ┃Foo {
    fn foo(&amp;self) -&gt; i32;
}</code></pre>
<h4 id="after-85"><a class="header" href="#after-85">After</a></h4>
<pre><code class="language-rust">trait Foo {
    fn foo(&amp;self) -&gt; i32;
}

impl Foo for ${1:_} {
    fn foo(&amp;self) -&gt; i32 {
        ┃todo!()
    }
}</code></pre>
<h3 id="generate_is_empty_from_len"><a class="header" href="#generate_is_empty_from_len"><code>generate_is_empty_from_len</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_is_empty_from_len.rs#L12">generate_is_empty_from_len.rs</a></p>
<p>Generates is_empty implementation from the len method.</p>
<h4 id="before-86"><a class="header" href="#before-86">Before</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    p┃ub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }
}</code></pre>
<h4 id="after-86"><a class="header" href="#after-86">After</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    pub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }

    #[must_use]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }
}</code></pre>
<h3 id="generate_mut_trait_impl"><a class="header" href="#generate_mut_trait_impl"><code>generate_mut_trait_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_mut_trait_impl.rs#L13">generate_mut_trait_impl.rs</a></p>
<p>Adds a IndexMut impl from the <code>Index</code> trait.</p>
<h4 id="before-87"><a class="header" href="#before-87">Before</a></h4>
<pre><code class="language-rust">pub enum Axis { X = 0, Y = 1, Z = 2 }

impl&lt;T&gt; core::ops::Index┃&lt;Axis&gt; for [T; 3] {
    type Output = T;

    fn index(&amp;self, index: Axis) -&gt; &amp;Self::Output {
        &amp;self[index as usize]
    }
}</code></pre>
<h4 id="after-87"><a class="header" href="#after-87">After</a></h4>
<pre><code class="language-rust">pub enum Axis { X = 0, Y = 1, Z = 2 }

┃impl&lt;T&gt; core::ops::IndexMut&lt;Axis&gt; for [T; 3] {
    fn index_mut(&amp;mut self, index: Axis) -&gt; &amp;mut Self::Output {
        &amp;mut self[index as usize]
    }
}

impl&lt;T&gt; core::ops::Index&lt;Axis&gt; for [T; 3] {
    type Output = T;

    fn index(&amp;self, index: Axis) -&gt; &amp;Self::Output {
        &amp;self[index as usize]
    }
}</code></pre>
<h3 id="generate_new"><a class="header" href="#generate_new"><code>generate_new</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_new.rs#L15">generate_new.rs</a></p>
<p>Adds a <code>fn new</code> for a type.</p>
<h4 id="before-88"><a class="header" href="#before-88">Before</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,┃
}</code></pre>
<h4 id="after-88"><a class="header" href="#after-88">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {
    fn ┃new(data: T) -&gt; Self {
        Self { data }
    }
}</code></pre>
<h3 id="generate_setter"><a class="header" href="#generate_setter"><code>generate_setter</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L14">generate_getter_or_setter.rs</a></p>
<p>Generate a setter method.</p>
<h4 id="before-89"><a class="header" href="#before-89">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-89"><a class="header" href="#after-89">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃set_name(&amp;mut self, name: String) {
        self.name = name;
    }
}</code></pre>
<h3 id="generate_single_field_struct_from"><a class="header" href="#generate_single_field_struct_from"><code>generate_single_field_struct_from</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_single_field_struct_from.rs#L19">generate_single_field_struct_from.rs</a></p>
<p>Implement From for a single field structure, ignore trivial types.</p>
<h4 id="before-90"><a class="header" href="#before-90">Before</a></h4>
<pre><code class="language-rust">use core::marker::PhantomData;
struct ┃Foo&lt;T&gt; {
    id: i32,
    _phantom_data: PhantomData&lt;T&gt;,
}</code></pre>
<h4 id="after-90"><a class="header" href="#after-90">After</a></h4>
<pre><code class="language-rust">use core::marker::PhantomData;
struct Foo&lt;T&gt; {
    id: i32,
    _phantom_data: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; From&lt;i32&gt; for Foo&lt;T&gt; {
    fn from(id: i32) -&gt; Self {
        Self { id, _phantom_data: PhantomData }
    }
}</code></pre>
<h3 id="generate_trait_from_impl"><a class="header" href="#generate_trait_from_impl"><code>generate_trait_from_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_trait_from_impl.rs#L14">generate_trait_from_impl.rs</a></p>
<p>Generate trait for an already defined inherent impl and convert impl to a trait impl.</p>
<h4 id="before-91"><a class="header" href="#before-91">Before</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

impl&lt;const N: usize&gt; Fo┃o&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h4 id="after-91"><a class="header" href="#after-91">After</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

trait ${0:NewTrait}&lt;const N: usize&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt;;

    const_maker! {i32, 7}
}

impl&lt;const N: usize&gt; ${0:NewTrait}&lt;N&gt; for Foo&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h3 id="generate_trait_impl"><a class="header" href="#generate_trait_impl"><code>generate_trait_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_impl.rs#L74">generate_impl.rs</a></p>
<p>Adds a new trait impl for a type.</p>
<h4 id="before-92"><a class="header" href="#before-92">Before</a></h4>
<pre><code class="language-rust">struct ┃Ctx&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-92"><a class="header" href="#after-92">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; ${1:_} for Ctx&lt;T&gt; {┃}</code></pre>
<h3 id="inline_call"><a class="header" href="#inline_call"><code>inline_call</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_call.rs#L174">inline_call.rs</a></p>
<p>Inlines a function or method body creating a <code>let</code> statement per parameter unless the parameter
can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.</p>
<h4 id="before-93"><a class="header" href="#before-93">Before</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = name.unwrap┃();
}</code></pre>
<h4 id="after-93"><a class="header" href="#after-93">After</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = match name {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        };
}</code></pre>
<h3 id="inline_const_as_literal"><a class="header" href="#inline_const_as_literal"><code>inline_const_as_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_const_as_literal.rs#L6">inline_const_as_literal.rs</a></p>
<p>Evaluate and inline const variable as literal.</p>
<h4 id="before-94"><a class="header" href="#before-94">Before</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = "Hello, World!";

fn something() -&gt; &amp;'static str {
    STRING┃
}</code></pre>
<h4 id="after-94"><a class="header" href="#after-94">After</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = "Hello, World!";

fn something() -&gt; &amp;'static str {
    "Hello, World!"
}</code></pre>
<h3 id="inline_into_callers"><a class="header" href="#inline_into_callers"><code>inline_into_callers</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_call.rs#L34">inline_call.rs</a></p>
<p>Inline a function or method body into all of its callers where possible, creating a <code>let</code> statement per parameter
unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.
If all calls can be inlined the function will be removed.</p>
<h4 id="before-95"><a class="header" href="#before-95">Before</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}
fn foo┃(word: &amp;str) {
    if !word.is_empty() {
        print(word);
    }
}
fn bar() {
    foo("안녕하세요");
    foo("여러분");
}</code></pre>
<h4 id="after-95"><a class="header" href="#after-95">After</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}

fn bar() {
    {
        let word: &amp;str = "안녕하세요";
        if !word.is_empty() {
            print(word);
        }
    };
    {
        let word: &amp;str = "여러분";
        if !word.is_empty() {
            print(word);
        }
    };
}</code></pre>
<h3 id="inline_local_variable"><a class="header" href="#inline_local_variable"><code>inline_local_variable</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_local_variable.rs#L17">inline_local_variable.rs</a></p>
<p>Inlines a local variable.</p>
<h4 id="before-96"><a class="header" href="#before-96">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x┃ = 1 + 2;
    x * 4;
}</code></pre>
<h4 id="after-96"><a class="header" href="#after-96">After</a></h4>
<pre><code class="language-rust">fn main() {
    (1 + 2) * 4;
}</code></pre>
<h3 id="inline_macro"><a class="header" href="#inline_macro"><code>inline_macro</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_macro.rs#L7">inline_macro.rs</a></p>
<p>Takes a macro and inlines it one step.</p>
<h4 id="before-97"><a class="header" href="#before-97">Before</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = num┃!(+ + + - + +);
    println!("{number}");
}</code></pre>
<h4 id="after-97"><a class="header" href="#after-97">After</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = 1+num!(+ + - + +);
    println!("{number}");
}</code></pre>
<h3 id="inline_type_alias"><a class="header" href="#inline_type_alias"><code>inline_type_alias</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_type_alias.rs#L112">inline_type_alias.rs</a></p>
<p>Replace a type alias with its concrete type.</p>
<h4 id="before-98"><a class="header" href="#before-98">Before</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: ┃A;
}</code></pre>
<h4 id="after-98"><a class="header" href="#after-98">After</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: Vec&lt;u32&gt;;
}</code></pre>
<h3 id="inline_type_alias_uses"><a class="header" href="#inline_type_alias_uses"><code>inline_type_alias_uses</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_type_alias.rs#L26">inline_type_alias.rs</a></p>
<p>Inline a type alias into all of its uses where possible.</p>
<h4 id="before-99"><a class="header" href="#before-99">Before</a></h4>
<pre><code class="language-rust">type ┃A = i32;
fn id(x: A) -&gt; A {
    x
};
fn foo() {
    let _: A = 3;
}</code></pre>
<h4 id="after-99"><a class="header" href="#after-99">After</a></h4>
<pre><code class="language-rust">
fn id(x: i32) -&gt; i32 {
    x
};
fn foo() {
    let _: i32 = 3;
}</code></pre>
<h3 id="into_to_qualified_from"><a class="header" href="#into_to_qualified_from"><code>into_to_qualified_from</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/into_to_qualified_from.rs#L7">into_to_qualified_from.rs</a></p>
<p>Convert an <code>into</code> method call to a fully qualified <code>from</code> call.</p>
<h4 id="before-100"><a class="header" href="#before-100">Before</a></h4>
<pre><code class="language-rust">//- minicore: from
struct B;
impl From&lt;i32&gt; for B {
    fn from(a: i32) -&gt; Self {
       B
    }
}

fn main() -&gt; () {
    let a = 3;
    let b: B = a.in┃to();
}</code></pre>
<h4 id="after-100"><a class="header" href="#after-100">After</a></h4>
<pre><code class="language-rust">struct B;
impl From&lt;i32&gt; for B {
    fn from(a: i32) -&gt; Self {
       B
    }
}

fn main() -&gt; () {
    let a = 3;
    let b: B = B::from(a);
}</code></pre>
<h3 id="introduce_named_lifetime"><a class="header" href="#introduce_named_lifetime"><code>introduce_named_lifetime</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/introduce_named_lifetime.rs#L13">introduce_named_lifetime.rs</a></p>
<p>Change an anonymous lifetime to a named lifetime.</p>
<h4 id="before-101"><a class="header" href="#before-101">Before</a></h4>
<pre><code class="language-rust">impl Cursor&lt;'_┃&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h4 id="after-101"><a class="header" href="#after-101">After</a></h4>
<pre><code class="language-rust">impl&lt;'a&gt; Cursor&lt;'a&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h3 id="introduce_named_type_parameter"><a class="header" href="#introduce_named_type_parameter"><code>introduce_named_type_parameter</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/introduce_named_type_parameter.rs#L7">introduce_named_type_parameter.rs</a></p>
<p>Replaces <code>impl Trait</code> function argument with the named generic.</p>
<h4 id="before-102"><a class="header" href="#before-102">Before</a></h4>
<pre><code class="language-rust">fn foo(bar: ┃impl Bar) {}</code></pre>
<h4 id="after-102"><a class="header" href="#after-102">After</a></h4>
<pre><code class="language-rust">fn foo&lt;┃B: Bar&gt;(bar: B) {}</code></pre>
<h3 id="invert_if"><a class="header" href="#invert_if"><code>invert_if</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/invert_if.rs#L13">invert_if.rs</a></p>
<p>This transforms if expressions of the form <code>if !x {A} else {B}</code> into <code>if x {B} else {A}</code>
This also works with <code>!=</code>. This assist can only be applied with the cursor on <code>if</code>.</p>
<h4 id="before-103"><a class="header" href="#before-103">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if┃ !y { A } else { B }
}</code></pre>
<h4 id="after-103"><a class="header" href="#after-103">After</a></h4>
<pre><code class="language-rust">fn main() {
    if y { B } else { A }
}</code></pre>
<h3 id="line_to_block"><a class="header" href="#line_to_block"><code>line_to_block</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_comment_block.rs#L9">convert_comment_block.rs</a></p>
<p>Converts comments between block and single-line form.</p>
<h4 id="before-104"><a class="header" href="#before-104">Before</a></h4>
<pre><code class="language-rust">   // Multi-line┃
   // comment</code></pre>
<h4 id="after-104"><a class="header" href="#after-104">After</a></h4>
<pre><code class="language-rust">  /*
  Multi-line
  comment
  */</code></pre>
<h3 id="make_raw_string"><a class="header" href="#make_raw_string"><code>make_raw_string</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L12">raw_string.rs</a></p>
<p>Adds <code>r#</code> to a plain string literal.</p>
<h4 id="before-105"><a class="header" href="#before-105">Before</a></h4>
<pre><code class="language-rust">fn main() {
    "Hello,┃ World!";
}</code></pre>
<h4 id="after-105"><a class="header" href="#after-105">After</a></h4>
<pre><code class="language-rust">fn main() {
    r#"Hello, World!"#;
}</code></pre>
<h3 id="make_usual_string"><a class="header" href="#make_usual_string"><code>make_usual_string</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L48">raw_string.rs</a></p>
<p>Turns a raw string into a plain string.</p>
<h4 id="before-106"><a class="header" href="#before-106">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#"Hello,┃ "World!""#;
}</code></pre>
<h4 id="after-106"><a class="header" href="#after-106">After</a></h4>
<pre><code class="language-rust">fn main() {
    "Hello, \"World!\"";
}</code></pre>
<h3 id="merge_imports"><a class="header" href="#merge_imports"><code>merge_imports</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/merge_imports.rs#L22">merge_imports.rs</a></p>
<p>Merges neighbor imports with a common prefix.</p>
<h4 id="before-107"><a class="header" href="#before-107">Before</a></h4>
<pre><code class="language-rust">use std::┃fmt::Formatter;
use std::io;</code></pre>
<h4 id="after-107"><a class="header" href="#after-107">After</a></h4>
<pre><code class="language-rust">use std::{fmt::Formatter, io};</code></pre>
<h3 id="merge_match_arms"><a class="header" href="#merge_match_arms"><code>merge_match_arms</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/merge_match_arms.rs#L12">merge_match_arms.rs</a></p>
<p>Merges the current match arm with the following if their bodies are identical.</p>
<h4 id="before-108"><a class="header" href="#before-108">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ┃Action::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-108"><a class="header" href="#after-108">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) | Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="merge_nested_if"><a class="header" href="#merge_nested_if"><code>merge_nested_if</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/merge_nested_if.rs#L11">merge_nested_if.rs</a></p>
<p>This transforms if expressions of the form <code>if x { if y {A} }</code> into <code>if x &amp;&amp; y {A}</code>
This assist can only be applied with the cursor on <code>if</code>.</p>
<h4 id="before-109"><a class="header" href="#before-109">Before</a></h4>
<pre><code class="language-rust">fn main() {
   i┃f x == 3 { if y == 4 { 1 } }
}</code></pre>
<h4 id="after-109"><a class="header" href="#after-109">After</a></h4>
<pre><code class="language-rust">fn main() {
   if x == 3 &amp;&amp; y == 4 { 1 }
}</code></pre>
<h3 id="move_arm_cond_to_match_guard"><a class="header" href="#move_arm_cond_to_match_guard"><code>move_arm_cond_to_match_guard</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_guard.rs#L75">move_guard.rs</a></p>
<p>Moves if expression from match arm body into a guard.</p>
<h4 id="before-110"><a class="header" href="#before-110">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; ┃if distance &gt; 10 { foo() },
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-110"><a class="header" href="#after-110">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } if distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_bounds_to_where_clause"><a class="header" href="#move_bounds_to_where_clause"><code>move_bounds_to_where_clause</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_bounds.rs#L13">move_bounds.rs</a></p>
<p>Moves inline type bounds to a where clause.</p>
<h4 id="before-111"><a class="header" href="#before-111">Before</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, ┃F: FnOnce(T) -&gt; U&gt;(f: F, x: T) -&gt; U {
    f(x)
}</code></pre>
<h4 id="after-111"><a class="header" href="#after-111">After</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, F&gt;(f: F, x: T) -&gt; U where F: FnOnce(T) -&gt; U {
    f(x)
}</code></pre>
<h3 id="move_const_to_impl"><a class="header" href="#move_const_to_impl"><code>move_const_to_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_const_to_impl.rs#L14">move_const_to_impl.rs</a></p>
<p>Move a local constant item in a method to impl's associated constant. All the references will be
qualified with <code>Self::</code>.</p>
<h4 id="before-112"><a class="header" href="#before-112">Before</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    fn foo() -&gt; usize {
        /// The answer.
        const C┃: usize = 42;

        C * C
    }
}</code></pre>
<h4 id="after-112"><a class="header" href="#after-112">After</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    /// The answer.
    const C: usize = 42;

    fn foo() -&gt; usize {
        Self::C * Self::C
    }
}</code></pre>
<h3 id="move_from_mod_rs"><a class="header" href="#move_from_mod_rs"><code>move_from_mod_rs</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_from_mod_rs.rs#L9">move_from_mod_rs.rs</a></p>
<p>Moves xxx/mod.rs to xxx.rs.</p>
<h4 id="before-113"><a class="header" href="#before-113">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a/mod.rs
┃fn t() {}┃</code></pre>
<h4 id="after-113"><a class="header" href="#after-113">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="move_guard_to_arm_body"><a class="header" href="#move_guard_to_arm_body"><code>move_guard_to_arm_body</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_guard.rs#L8">move_guard.rs</a></p>
<p>Moves match guard into match arm body.</p>
<h4 id="before-114"><a class="header" href="#before-114">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } ┃if distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-114"><a class="header" href="#after-114">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; if distance &gt; 10 {
            foo()
        },
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_module_to_file"><a class="header" href="#move_module_to_file"><code>move_module_to_file</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_module_to_file.rs#L15">move_module_to_file.rs</a></p>
<p>Moves inline module's contents to a separate file.</p>
<h4 id="before-115"><a class="header" href="#before-115">Before</a></h4>
<pre><code class="language-rust">mod ┃foo {
    fn t() {}
}</code></pre>
<h4 id="after-115"><a class="header" href="#after-115">After</a></h4>
<pre><code class="language-rust">mod foo;</code></pre>
<h3 id="move_to_mod_rs"><a class="header" href="#move_to_mod_rs"><code>move_to_mod_rs</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_to_mod_rs.rs#L9">move_to_mod_rs.rs</a></p>
<p>Moves xxx.rs to xxx/mod.rs.</p>
<h4 id="before-116"><a class="header" href="#before-116">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a.rs
┃fn t() {}┃</code></pre>
<h4 id="after-116"><a class="header" href="#after-116">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="normalize_import"><a class="header" href="#normalize_import"><code>normalize_import</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/normalize_import.rs#L9">normalize_import.rs</a></p>
<p>Normalizes an import.</p>
<h4 id="before-117"><a class="header" href="#before-117">Before</a></h4>
<pre><code class="language-rust">use┃ std::{io, {fmt::Formatter}};</code></pre>
<h4 id="after-117"><a class="header" href="#after-117">After</a></h4>
<pre><code class="language-rust">use std::{fmt::Formatter, io};</code></pre>
<h3 id="promote_local_to_const"><a class="header" href="#promote_local_to_const"><code>promote_local_to_const</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/promote_local_to_const.rs#L14">promote_local_to_const.rs</a></p>
<p>Promotes a local variable to a const item changing its name to a <code>SCREAMING_SNAKE_CASE</code> variant
if the local uses no non-const expressions.</p>
<h4 id="before-118"><a class="header" href="#before-118">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let foo┃ = true;

    if foo {
        println!("It's true");
    } else {
        println!("It's false");
    }
}</code></pre>
<h4 id="after-118"><a class="header" href="#after-118">After</a></h4>
<pre><code class="language-rust">fn main() {
    const ┃FOO: bool = true;

    if FOO {
        println!("It's true");
    } else {
        println!("It's false");
    }
}</code></pre>
<h3 id="pull_assignment_up"><a class="header" href="#pull_assignment_up"><code>pull_assignment_up</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/pull_assignment_up.rs#L14">pull_assignment_up.rs</a></p>
<p>Extracts variable assignment to outside an if or match statement.</p>
<h4 id="before-119"><a class="header" href="#before-119">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    if true {
        ┃foo = 5;
    } else {
        foo = 4;
    }
}</code></pre>
<h4 id="after-119"><a class="header" href="#after-119">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    foo = if true {
        5
    } else {
        4
    };
}</code></pre>
<h3 id="qualify_method_call"><a class="header" href="#qualify_method_call"><code>qualify_method_call</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/qualify_method_call.rs#L10">qualify_method_call.rs</a></p>
<p>Replaces the method call with a qualified function call.</p>
<h4 id="before-120"><a class="header" href="#before-120">Before</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    foo.fo┃o();
}</code></pre>
<h4 id="after-120"><a class="header" href="#after-120">After</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    Foo::foo(&amp;foo);
}</code></pre>
<h3 id="qualify_path"><a class="header" href="#qualify_path"><code>qualify_path</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/qualify_path.rs#L23">qualify_path.rs</a></p>
<p>If the name is unresolved, provides all possible qualified paths for it.</p>
<h4 id="before-121"><a class="header" href="#before-121">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap┃::new();
}</code></pre>
<h4 id="after-121"><a class="header" href="#after-121">After</a></h4>
<pre><code class="language-rust">fn main() {
    let map = std::collections::HashMap::new();
}</code></pre>
<h3 id="reformat_number_literal"><a class="header" href="#reformat_number_literal"><code>reformat_number_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/number_representation.rs#L7">number_representation.rs</a></p>
<p>Adds or removes separators from integer literal.</p>
<h4 id="before-122"><a class="header" href="#before-122">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 1012345┃;</code></pre>
<h4 id="after-122"><a class="header" href="#after-122">After</a></h4>
<pre><code class="language-rust">const _: i32 = 1_012_345;</code></pre>
<h3 id="remove_dbg"><a class="header" href="#remove_dbg"><code>remove_dbg</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_dbg.rs#L11">remove_dbg.rs</a></p>
<p>Removes <code>dbg!()</code> macro call.</p>
<h4 id="before-123"><a class="header" href="#before-123">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = ┃dbg!(42 * dbg!(4 + 2));┃
}</code></pre>
<h4 id="after-123"><a class="header" href="#after-123">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = 42 * (4 + 2);
}</code></pre>
<h3 id="remove_else_branches"><a class="header" href="#remove_else_branches"><code>remove_else_branches</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_else_branches.rs#L5">remove_else_branches.rs</a></p>
<p>Removes the <code>else</code> keyword and else branches.</p>
<h4 id="before-124"><a class="header" href="#before-124">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if true {
        let _ = 2;
    } ┃else {
        unreachable!();
    }
}</code></pre>
<h4 id="after-124"><a class="header" href="#after-124">After</a></h4>
<pre><code class="language-rust">fn main() {
    if true {
        let _ = 2;
    }
}</code></pre>
<hr />
<h4 id="before-125"><a class="header" href="#before-125">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _x = 2 ┃else { unreachable!() };
}</code></pre>
<h4 id="after-125"><a class="header" href="#after-125">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _x = 2;
}</code></pre>
<h3 id="remove_hash"><a class="header" href="#remove_hash"><code>remove_hash</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L116">raw_string.rs</a></p>
<p>Removes a hash from a raw string literal.</p>
<h4 id="before-126"><a class="header" href="#before-126">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#"Hello,┃ World!"#;
}</code></pre>
<h4 id="after-126"><a class="header" href="#after-126">After</a></h4>
<pre><code class="language-rust">fn main() {
    r"Hello, World!";
}</code></pre>
<h3 id="remove_mut"><a class="header" href="#remove_mut"><code>remove_mut</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_mut.rs#L5">remove_mut.rs</a></p>
<p>Removes the <code>mut</code> keyword.</p>
<h4 id="before-127"><a class="header" href="#before-127">Before</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;mut┃ self, amount: u32) {}
}</code></pre>
<h4 id="after-127"><a class="header" href="#after-127">After</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;self, amount: u32) {}
}</code></pre>
<h3 id="remove_parentheses"><a class="header" href="#remove_parentheses"><code>remove_parentheses</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_parentheses.rs#L9">remove_parentheses.rs</a></p>
<p>Removes redundant parentheses.</p>
<h4 id="before-128"><a class="header" href="#before-128">Before</a></h4>
<pre><code class="language-rust">fn main() {
    _ = ┃(2) + 2;
}</code></pre>
<h4 id="after-128"><a class="header" href="#after-128">After</a></h4>
<pre><code class="language-rust">fn main() {
    _ = 2 + 2;
}</code></pre>
<h3 id="remove_underscore_from_used_variables"><a class="header" href="#remove_underscore_from_used_variables"><code>remove_underscore_from_used_variables</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_underscore.rs#L10">remove_underscore.rs</a></p>
<p>Removes underscore from used variables.</p>
<h4 id="before-129"><a class="header" href="#before-129">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let mut _┃foo = 1;
    _foo = 2;
}</code></pre>
<h4 id="after-129"><a class="header" href="#after-129">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 1;
    foo = 2;
}</code></pre>
<h3 id="remove_unused_imports"><a class="header" href="#remove_unused_imports"><code>remove_unused_imports</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_unused_imports.rs#L20">remove_unused_imports.rs</a></p>
<p>Removes any use statements in the current selection that are unused.</p>
<h4 id="before-130"><a class="header" href="#before-130">Before</a></h4>
<pre><code class="language-rust">struct X();
mod foo {
    use super::X┃;
}</code></pre>
<h4 id="after-130"><a class="header" href="#after-130">After</a></h4>
<pre><code class="language-rust">struct X();
mod foo {
}</code></pre>
<h3 id="remove_unused_param"><a class="header" href="#remove_unused_param"><code>remove_unused_param</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_unused_param.rs#L15">remove_unused_param.rs</a></p>
<p>Removes unused function parameter.</p>
<h4 id="before-131"><a class="header" href="#before-131">Before</a></h4>
<pre><code class="language-rust">fn frobnicate(x: i32┃) {}

fn main() {
    frobnicate(92);
}</code></pre>
<h4 id="after-131"><a class="header" href="#after-131">After</a></h4>
<pre><code class="language-rust">fn frobnicate() {}

fn main() {
    frobnicate();
}</code></pre>
<h3 id="reorder_fields"><a class="header" href="#reorder_fields"><code>reorder_fields</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/reorder_fields.rs#L8">reorder_fields.rs</a></p>
<p>Reorder the fields of record literals and record patterns in the same order as in
the definition.</p>
<h4 id="before-132"><a class="header" href="#before-132">Before</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = ┃Foo {bar: 0, foo: 1}</code></pre>
<h4 id="after-132"><a class="header" href="#after-132">After</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = Foo {foo: 1, bar: 0}</code></pre>
<h3 id="reorder_impl_items"><a class="header" href="#reorder_impl_items"><code>reorder_impl_items</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/reorder_impl_items.rs#L11">reorder_impl_items.rs</a></p>
<p>Reorder the items of an <code>impl Trait</code>. The items will be ordered
in the same order as in the trait definition.</p>
<h4 id="before-133"><a class="header" href="#before-133">Before</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
┃impl Foo for Bar┃ {
    const B: u8 = 17;
    fn c() {}
    type A = String;
}</code></pre>
<h4 id="after-133"><a class="header" href="#after-133">After</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
impl Foo for Bar {
    type A = String;
    const B: u8 = 17;
    fn c() {}
}</code></pre>
<h3 id="replace_arith_with_checked"><a class="header" href="#replace_arith_with_checked"><code>replace_arith_with_checked</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L9">replace_arith_op.rs</a></p>
<p>Replaces arithmetic on integers with the <code>checked_*</code> equivalent.</p>
<h4 id="before-134"><a class="header" href="#before-134">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-134"><a class="header" href="#after-134">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.checked_add(2);
}</code></pre>
<h3 id="replace_arith_with_saturating"><a class="header" href="#replace_arith_with_saturating"><code>replace_arith_with_saturating</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L28">replace_arith_op.rs</a></p>
<p>Replaces arithmetic on integers with the <code>saturating_*</code> equivalent.</p>
<h4 id="before-135"><a class="header" href="#before-135">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-135"><a class="header" href="#after-135">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.saturating_add(2);
}</code></pre>
<h3 id="replace_arith_with_wrapping"><a class="header" href="#replace_arith_with_wrapping"><code>replace_arith_with_wrapping</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L50">replace_arith_op.rs</a></p>
<p>Replaces arithmetic on integers with the <code>wrapping_*</code> equivalent.</p>
<h4 id="before-136"><a class="header" href="#before-136">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-136"><a class="header" href="#after-136">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.wrapping_add(2);
}</code></pre>
<h3 id="replace_char_with_string"><a class="header" href="#replace_char_with_string"><code>replace_char_with_string</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_string_with_char.rs#L52">replace_string_with_char.rs</a></p>
<p>Replace a char literal with a string literal.</p>
<h4 id="before-137"><a class="header" href="#before-137">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find('{┃');
}</code></pre>
<h4 id="after-137"><a class="header" href="#after-137">After</a></h4>
<pre><code class="language-rust">fn main() {
    find("{");
}</code></pre>
<h3 id="replace_derive_with_manual_impl"><a class="header" href="#replace_derive_with_manual_impl"><code>replace_derive_with_manual_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs#L20">replace_derive_with_manual_impl.rs</a></p>
<p>Converts a <code>derive</code> impl into a manual one.</p>
<h4 id="before-138"><a class="header" href="#before-138">Before</a></h4>
<pre><code class="language-rust">#[derive(Deb┃ug, Display)]
struct S;</code></pre>
<h4 id="after-138"><a class="header" href="#after-138">After</a></h4>
<pre><code class="language-rust">#[derive(Display)]
struct S;

impl Debug for S {
    ┃fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;()&gt; {
        f.debug_struct("S").finish()
    }
}</code></pre>
<h3 id="replace_if_let_with_match"><a class="header" href="#replace_if_let_with_match"><code>replace_if_let_with_match</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#L20">replace_if_let_with_match.rs</a></p>
<p>Replaces a <code>if let</code> expression with a <code>match</code> expression.</p>
<h4 id="before-139"><a class="header" href="#before-139">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ┃if let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h4 id="after-139"><a class="header" href="#after-139">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h3 id="replace_is_some_with_if_let_some"><a class="header" href="#replace_is_some_with_if_let_some"><code>replace_is_some_with_if_let_some</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_is_method_with_if_let_method.rs#L7">replace_is_method_with_if_let_method.rs</a></p>
<p>Replace <code>if x.is_some()</code> with <code>if let Some(_tmp) = x</code> or <code>if x.is_ok()</code> with <code>if let Ok(_tmp) = x</code>.</p>
<h4 id="before-140"><a class="header" href="#before-140">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = Some(1);
    if x.is_som┃e() {}
}</code></pre>
<h4 id="after-140"><a class="header" href="#after-140">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = Some(1);
    if let Some(${0:x1}) = x {}
}</code></pre>
<h3 id="replace_let_with_if_let"><a class="header" href="#replace_let_with_if_let"><code>replace_let_with_if_let</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_let_with_if_let.rs#L9">replace_let_with_if_let.rs</a></p>
<p>Replaces <code>let</code> with an <code>if let</code>.</p>
<h4 id="before-141"><a class="header" href="#before-141">Before</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    ┃let x = compute();
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h4 id="after-141"><a class="header" href="#after-141">After</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    if let Some(x) = compute() {
    }
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h3 id="replace_match_with_if_let"><a class="header" href="#replace_match_with_if_let"><code>replace_match_with_if_let</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#L188">replace_if_let_with_match.rs</a></p>
<p>Replaces a binary <code>match</code> with a wildcard pattern with an <code>if let</code> expression.</p>
<h4 id="before-142"><a class="header" href="#before-142">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ┃match action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h4 id="after-142"><a class="header" href="#after-142">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    if let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h3 id="replace_named_generic_with_impl"><a class="header" href="#replace_named_generic_with_impl"><code>replace_named_generic_with_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_named_generic_with_impl.rs#L16">replace_named_generic_with_impl.rs</a></p>
<p>Replaces named generic with an <code>impl Trait</code> in function argument.</p>
<h4 id="before-143"><a class="header" href="#before-143">Before</a></h4>
<pre><code class="language-rust">fn new&lt;P┃: AsRef&lt;Path&gt;&gt;(location: P) -&gt; Self {}</code></pre>
<h4 id="after-143"><a class="header" href="#after-143">After</a></h4>
<pre><code class="language-rust">fn new(location: impl AsRef&lt;Path&gt;) -&gt; Self {}</code></pre>
<h3 id="replace_qualified_name_with_use"><a class="header" href="#replace_qualified_name_with_use"><code>replace_qualified_name_with_use</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs#L14">replace_qualified_name_with_use.rs</a></p>
<p>Adds a use statement for a given fully-qualified name.</p>
<h4 id="before-144"><a class="header" href="#before-144">Before</a></h4>
<pre><code class="language-rust">fn process(map: std::collections::┃HashMap&lt;String, String&gt;) {}</code></pre>
<h4 id="after-144"><a class="header" href="#after-144">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn process(map: HashMap&lt;String, String&gt;) {}</code></pre>
<h3 id="replace_string_with_char"><a class="header" href="#replace_string_with_char"><code>replace_string_with_char</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_string_with_char.rs#L10">replace_string_with_char.rs</a></p>
<p>Replace string literal with char literal.</p>
<h4 id="before-145"><a class="header" href="#before-145">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find("{┃");
}</code></pre>
<h4 id="after-145"><a class="header" href="#after-145">After</a></h4>
<pre><code class="language-rust">fn main() {
    find('{');
}</code></pre>
<h3 id="replace_turbofish_with_explicit_type"><a class="header" href="#replace_turbofish_with_explicit_type"><code>replace_turbofish_with_explicit_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs#L12">replace_turbofish_with_explicit_type.rs</a></p>
<p>Converts <code>::&lt;_&gt;</code> to an explicit type assignment.</p>
<h4 id="before-146"><a class="header" href="#before-146">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a = make┃::&lt;i32&gt;();
}</code></pre>
<h4 id="after-146"><a class="header" href="#after-146">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a: i32 = make();
}</code></pre>
<h3 id="replace_with_eager_method"><a class="header" href="#replace_with_eager_method"><code>replace_with_eager_method</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#L85">replace_method_eager_lazy.rs</a></p>
<p>Replace <code>unwrap_or_else</code> with <code>unwrap_or</code> and <code>ok_or_else</code> with <code>ok_or</code>.</p>
<h4 id="before-147"><a class="header" href="#before-147">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra┃p_or_else(|| 2);
}</code></pre>
<h4 id="after-147"><a class="header" href="#after-147">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or(2);
}</code></pre>
<h3 id="replace_with_lazy_method"><a class="header" href="#replace_with_lazy_method"><code>replace_with_lazy_method</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#L9">replace_method_eager_lazy.rs</a></p>
<p>Replace <code>unwrap_or</code> with <code>unwrap_or_else</code> and <code>ok_or</code> with <code>ok_or_else</code>.</p>
<h4 id="before-148"><a class="header" href="#before-148">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra┃p_or(2);
}</code></pre>
<h4 id="after-148"><a class="header" href="#after-148">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or_else(|| 2);
}</code></pre>
<h3 id="sort_items"><a class="header" href="#sort_items"><code>sort_items</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/sort_items.rs#L12">sort_items.rs</a></p>
<p>Sorts item members alphabetically: fields, enum variants and methods.</p>
<h4 id="before-149"><a class="header" href="#before-149">Before</a></h4>
<pre><code class="language-rust">struct ┃Foo┃ { second: u32, first: String }</code></pre>
<h4 id="after-149"><a class="header" href="#after-149">After</a></h4>
<pre><code class="language-rust">struct Foo { first: String, second: u32 }</code></pre>
<hr />
<h4 id="before-150"><a class="header" href="#before-150">Before</a></h4>
<pre><code class="language-rust">trait ┃Bar┃ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-150"><a class="header" href="#after-150">After</a></h4>
<pre><code class="language-rust">trait Bar {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<hr />
<h4 id="before-151"><a class="header" href="#before-151">Before</a></h4>
<pre><code class="language-rust">struct Baz;
impl ┃Baz┃ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-151"><a class="header" href="#after-151">After</a></h4>
<pre><code class="language-rust">struct Baz;
impl Baz {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<hr />
<p>There is a difference between sorting enum variants:</p>
<h4 id="before-152"><a class="header" href="#before-152">Before</a></h4>
<pre><code class="language-rust">enum ┃Animal┃ {
  Dog(String, f64),
  Cat { weight: f64, name: String },
}</code></pre>
<h4 id="after-152"><a class="header" href="#after-152">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Cat { weight: f64, name: String },
  Dog(String, f64),
}</code></pre>
<p>and sorting a single enum struct variant:</p>
<h4 id="before-153"><a class="header" href="#before-153">Before</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat ┃{ weight: f64, name: String }┃,
}</code></pre>
<h4 id="after-153"><a class="header" href="#after-153">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat { name: String, weight: f64 },
}</code></pre>
<h3 id="split_import"><a class="header" href="#split_import"><code>split_import</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/split_import.rs#L5">split_import.rs</a></p>
<p>Wraps the tail of import into braces.</p>
<h4 id="before-154"><a class="header" href="#before-154">Before</a></h4>
<pre><code class="language-rust">use std::┃collections::HashMap;</code></pre>
<h4 id="after-154"><a class="header" href="#after-154">After</a></h4>
<pre><code class="language-rust">use std::{collections::HashMap};</code></pre>
<h3 id="sugar_impl_future_into_async"><a class="header" href="#sugar_impl_future_into_async"><code>sugar_impl_future_into_async</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/toggle_async_sugar.rs#L10">toggle_async_sugar.rs</a></p>
<p>Rewrites asynchronous function from <code>-&gt; impl Future</code> into <code>async fn</code>.
This action does not touch the function body and therefore <code>async { 0 }</code>
block does not transform to just <code>0</code>.</p>
<h4 id="before-155"><a class="header" href="#before-155">Before</a></h4>
<pre><code class="language-rust">pub fn foo() -&gt; impl core::future::F┃uture&lt;Output = usize&gt; {
    async { 0 }
}</code></pre>
<h4 id="after-155"><a class="header" href="#after-155">After</a></h4>
<pre><code class="language-rust">pub async fn foo() -&gt; usize {
    async { 0 }
}</code></pre>
<h3 id="toggle_ignore"><a class="header" href="#toggle_ignore"><code>toggle_ignore</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/toggle_ignore.rs#L8">toggle_ignore.rs</a></p>
<p>Adds <code>#[ignore]</code> attribute to the test.</p>
<h4 id="before-156"><a class="header" href="#before-156">Before</a></h4>
<pre><code class="language-rust">┃#[test]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h4 id="after-156"><a class="header" href="#after-156">After</a></h4>
<pre><code class="language-rust">#[test]
#[ignore]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h3 id="toggle_macro_delimiter"><a class="header" href="#toggle_macro_delimiter"><code>toggle_macro_delimiter</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/toggle_macro_delimiter.rs#L9">toggle_macro_delimiter.rs</a></p>
<p>Change macro delimiters in the order of <code>( -&gt; { -&gt; [ -&gt; (</code>.</p>
<h4 id="before-157"><a class="header" href="#before-157">Before</a></h4>
<pre><code class="language-rust">macro_rules! sth {
    () =&gt; {};
}

sth!┃( );</code></pre>
<h4 id="after-157"><a class="header" href="#after-157">After</a></h4>
<pre><code class="language-rust">macro_rules! sth {
    () =&gt; {};
}

sth!{ }</code></pre>
<h3 id="unmerge_imports"><a class="header" href="#unmerge_imports"><code>unmerge_imports</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unmerge_imports.rs#L12">unmerge_imports.rs</a></p>
<p>Extracts a use item from a use list into a standalone use list.</p>
<h4 id="before-158"><a class="header" href="#before-158">Before</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug, Display┃};</code></pre>
<h4 id="after-158"><a class="header" href="#after-158">After</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug};
use std::fmt::Display;</code></pre>
<h3 id="unmerge_match_arm"><a class="header" href="#unmerge_match_arm"><code>unmerge_match_arm</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unmerge_match_arm.rs#L9">unmerge_match_arm.rs</a></p>
<p>Splits the current match with a <code>|</code> pattern into two arms with identical bodies.</p>
<h4 id="before-159"><a class="header" href="#before-159">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) ┃| Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-159"><a class="header" href="#after-159">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="unnecessary_async"><a class="header" href="#unnecessary_async"><code>unnecessary_async</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unnecessary_async.rs#L17">unnecessary_async.rs</a></p>
<p>Removes the <code>async</code> mark from functions which have no <code>.await</code> in their body.
Looks for calls to the functions and removes the <code>.await</code> on the call site.</p>
<h4 id="before-160"><a class="header" href="#before-160">Before</a></h4>
<pre><code class="language-rust">pub asy┃nc fn foo() {}
pub async fn bar() { foo().await }</code></pre>
<h4 id="after-160"><a class="header" href="#after-160">After</a></h4>
<pre><code class="language-rust">pub fn foo() {}
pub async fn bar() { foo() }</code></pre>
<h3 id="unqualify_method_call"><a class="header" href="#unqualify_method_call"><code>unqualify_method_call</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unqualify_method_call.rs#L9">unqualify_method_call.rs</a></p>
<p>Transforms universal function call syntax into a method call.</p>
<h4 id="before-161"><a class="header" href="#before-161">Before</a></h4>
<pre><code class="language-rust">fn main() {
    std::ops::Add::add┃(1, 2);
}</code></pre>
<h4 id="after-161"><a class="header" href="#after-161">After</a></h4>
<pre><code class="language-rust">use std::ops::Add;

fn main() {
    1.add(2);
}</code></pre>
<h3 id="unwrap_block"><a class="header" href="#unwrap_block"><code>unwrap_block</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_block.rs#L12">unwrap_block.rs</a></p>
<p>This assist removes if...else, for, while and loop control statements to just keep the body.</p>
<h4 id="before-162"><a class="header" href="#before-162">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    if true {┃
        println!("foo");
    }
}</code></pre>
<h4 id="after-162"><a class="header" href="#after-162">After</a></h4>
<pre><code class="language-rust">fn foo() {
    println!("foo");
}</code></pre>
<h3 id="unwrap_option_return_type"><a class="header" href="#unwrap_option_return_type"><code>unwrap_option_return_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_return_type.rs#L14">unwrap_return_type.rs</a></p>
<p>Unwrap the function's return type.</p>
<h4 id="before-163"><a class="header" href="#before-163">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Option&lt;i32&gt;┃ { Some(42i32) }</code></pre>
<h4 id="after-163"><a class="header" href="#after-163">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="unwrap_result_return_type"><a class="header" href="#unwrap_result_return_type"><code>unwrap_result_return_type</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_return_type.rs#L27">unwrap_return_type.rs</a></p>
<p>Unwrap the function's return type.</p>
<h4 id="before-164"><a class="header" href="#before-164">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32&gt;┃ { Ok(42i32) }</code></pre>
<h4 id="after-164"><a class="header" href="#after-164">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="unwrap_tuple"><a class="header" href="#unwrap_tuple"><code>unwrap_tuple</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_tuple.rs#L8">unwrap_tuple.rs</a></p>
<p>Unwrap the tuple to different variables.</p>
<h4 id="before-165"><a class="header" href="#before-165">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃let (foo, bar) = ("Foo", "Bar");
}</code></pre>
<h4 id="after-165"><a class="header" href="#after-165">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = "Foo";
    let bar = "Bar";
}</code></pre>
<h3 id="unwrap_type_to_generic_arg"><a class="header" href="#unwrap_type_to_generic_arg"><code>unwrap_type_to_generic_arg</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_type_to_generic_arg.rs#L9">unwrap_type_to_generic_arg.rs</a></p>
<p>This assist unwraps a type into its generic type argument.</p>
<h4 id="before-166"><a class="header" href="#before-166">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; ┃Option&lt;i32&gt; {
    todo!()
}</code></pre>
<h4 id="after-166"><a class="header" href="#after-166">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 {
    todo!()
}</code></pre>
<h3 id="wrap_return_type_in_option"><a class="header" href="#wrap_return_type_in_option"><code>wrap_return_type_in_option</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/wrap_return_type.rs#L17">wrap_return_type.rs</a></p>
<p>Wrap the function's return type into Option.</p>
<h4 id="before-167"><a class="header" href="#before-167">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32┃ { 42i32 }</code></pre>
<h4 id="after-167"><a class="header" href="#after-167">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Option&lt;i32&gt; { Some(42i32) }</code></pre>
<h3 id="wrap_return_type_in_result"><a class="header" href="#wrap_return_type_in_result"><code>wrap_return_type_in_result</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/wrap_return_type.rs#L30">wrap_return_type.rs</a></p>
<p>Wrap the function's return type into Result.</p>
<h4 id="before-168"><a class="header" href="#before-168">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32┃ { 42i32 }</code></pre>
<h4 id="after-168"><a class="header" href="#after-168">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32, ${0:_}&gt; { Ok(42i32) }</code></pre>
<h3 id="wrap_unwrap_cfg_attr"><a class="header" href="#wrap_unwrap_cfg_attr"><code>wrap_unwrap_cfg_attr</code></a></h3>
<p><strong>Source:</strong>  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/wrap_unwrap_cfg_attr.rs#L10">wrap_unwrap_cfg_attr.rs</a></p>
<p>Wraps an attribute to a cfg_attr attribute or unwraps a cfg_attr attribute to the inner attributes.</p>
<h4 id="before-169"><a class="header" href="#before-169">Before</a></h4>
<pre><code class="language-rust">#[derive┃(Debug)]
struct S {
   field: i32
}</code></pre>
<h4 id="after-169"><a class="header" href="#after-169">After</a></h4>
<pre><code class="language-rust">#[cfg_attr(┃, derive(Debug))]
struct S {
   field: i32
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h1>
<p>While most errors and warnings provided by rust-analyzer come from the
<code>cargo check</code> integration, there’s a growing number of diagnostics
implemented using rust-analyzer’s own analysis. Some of these
diagnostics don’t respect <code>#[allow]</code> or <code>#[deny]</code> attributes yet, but
can be turned off using the <code>rust-analyzer.diagnostics.enable</code>,
<code>rust-analyzer.diagnostics.experimental.enable</code> or
<code>rust-analyzer.diagnostics.disabled</code> settings.</p>
<h2 id="clippy"><a class="header" href="#clippy">Clippy</a></h2>
<p>To run <code>cargo clippy</code> instead of <code>cargo check</code>, you can set
<code>"rust-analyzer.check.command": "clippy"</code>.</p>
<h4 id="attribute-expansion-disabled"><a class="header" href="#attribute-expansion-disabled">attribute-expansion-disabled</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/macro_error.rs#L7">macro_error.rs</a></p>
<p>This diagnostic is shown for attribute proc macros when attribute expansions have been disabled.</p>
<h4 id="await-outside-of-async"><a class="header" href="#await-outside-of-async">await-outside-of-async</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/await_outside_of_async.rs#L3">await_outside_of_async.rs</a></p>
<p>This diagnostic is triggered if the <code>await</code> keyword is used outside of an async function or block</p>
<h4 id="bad-rtn"><a class="header" href="#bad-rtn">bad-rtn</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/bad_rtn.rs#L5">bad_rtn.rs</a></p>
<p>This diagnostic is shown when a RTN (Return Type Notation, <code>Type::method(..): Send</code>) is written in an improper place.</p>
<h4 id="break-outside-of-loop"><a class="header" href="#break-outside-of-loop">break-outside-of-loop</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs#L3">break_outside_of_loop.rs</a></p>
<p>This diagnostic is triggered if the <code>break</code> keyword is used outside of a loop.</p>
<h4 id="cast-to-unsized"><a class="header" href="#cast-to-unsized">cast-to-unsized</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/invalid_cast.rs#L106">invalid_cast.rs</a></p>
<p>This diagnostic is triggered when casting to an unsized type</p>
<h4 id="elided-lifetimes-in-path"><a class="header" href="#elided-lifetimes-in-path">elided-lifetimes-in-path</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/elided_lifetimes_in_path.rs#L3">elided_lifetimes_in_path.rs</a></p>
<p>This diagnostic is triggered when lifetimes are elided in paths. It is a lint only for some cases,
and a hard error for others.</p>
<h4 id="expected-function"><a class="header" href="#expected-function">expected-function</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/expected_function.rs#L5">expected_function.rs</a></p>
<p>This diagnostic is triggered if a call is made on something that is not callable.</p>
<h4 id="generic-args-prohibited"><a class="header" href="#generic-args-prohibited">generic-args-prohibited</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/generic_args_prohibited.rs#L10">generic_args_prohibited.rs</a></p>
<p>This diagnostic is shown when generic arguments are provided for a type that does not accept
generic arguments.</p>
<h4 id="inactive-code"><a class="header" href="#inactive-code">inactive-code</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/inactive_code.rs#L6">inactive_code.rs</a></p>
<p>This diagnostic is shown for code with inactive <code>#[cfg]</code> attributes.</p>
<h4 id="incoherent-impl"><a class="header" href="#incoherent-impl">incoherent-impl</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/incoherent_impl.rs#L6">incoherent_impl.rs</a></p>
<p>This diagnostic is triggered if the targe type of an impl is from a foreign crate.</p>
<h4 id="incorrect-generics-len"><a class="header" href="#incorrect-generics-len">incorrect-generics-len</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/incorrect_generics_len.rs#L4">incorrect_generics_len.rs</a></p>
<p>This diagnostic is triggered if the number of generic arguments does not match their declaration.</p>
<h4 id="incorrect-generics-order"><a class="header" href="#incorrect-generics-order">incorrect-generics-order</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/incorrect_generics_order.rs#L5">incorrect_generics_order.rs</a></p>
<p>This diagnostic is triggered the order of provided generic arguments does not match their declaration.</p>
<h4 id="incorrect-ident-case"><a class="header" href="#incorrect-ident-case">incorrect-ident-case</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/incorrect_case.rs#L13">incorrect_case.rs</a></p>
<p>This diagnostic is triggered if an item name doesn't follow <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust naming convention</a>.</p>
<h4 id="invalid-cast"><a class="header" href="#invalid-cast">invalid-cast</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/invalid_cast.rs#L18">invalid_cast.rs</a></p>
<p>This diagnostic is triggered if the code contains an illegal cast</p>
<h4 id="invalid-derive-target"><a class="header" href="#invalid-derive-target">invalid-derive-target</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/invalid_derive_target.rs#L3">invalid_derive_target.rs</a></p>
<p>This diagnostic is shown when the derive attribute is used on an item other than a <code>struct</code>,
<code>enum</code> or <code>union</code>.</p>
<h4 id="macro-def-error"><a class="header" href="#macro-def-error">macro-def-error</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/macro_error.rs#L25">macro_error.rs</a></p>
<p>This diagnostic is shown for macro expansion errors.</p>
<h4 id="macro-error"><a class="header" href="#macro-error">macro-error</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/macro_error.rs#L3">macro_error.rs</a></p>
<p>This diagnostic is shown for macro expansion errors.</p>
<h4 id="malformed-derive"><a class="header" href="#malformed-derive">malformed-derive</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/malformed_derive.rs#L3">malformed_derive.rs</a></p>
<p>This diagnostic is shown when the derive attribute has invalid input.</p>
<h4 id="mismatched-arg-count"><a class="header" href="#mismatched-arg-count">mismatched-arg-count</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/mismatched_arg_count.rs#L32">mismatched_arg_count.rs</a></p>
<p>This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.</p>
<h4 id="mismatched-tuple-struct-pat-arg-count"><a class="header" href="#mismatched-tuple-struct-pat-arg-count">mismatched-tuple-struct-pat-arg-count</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/mismatched_arg_count.rs#L11">mismatched_arg_count.rs</a></p>
<p>This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.</p>
<h4 id="missing-fields"><a class="header" href="#missing-fields">missing-fields</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/missing_fields.rs#L25">missing_fields.rs</a></p>
<p>This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.</p>
<p>Example:</p>
<pre><code class="language-rust">struct A { a: u8, b: u8 }

let a = A { a: 10 };</code></pre>
<h4 id="missing-lifetime"><a class="header" href="#missing-lifetime">missing-lifetime</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/missing_lifetime.rs#L3">missing_lifetime.rs</a></p>
<p>This diagnostic is triggered when a lifetime argument is missing.</p>
<h4 id="missing-match-arm"><a class="header" href="#missing-match-arm">missing-match-arm</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/missing_match_arms.rs#L3">missing_match_arms.rs</a></p>
<p>This diagnostic is triggered if <code>match</code> block is missing one or more match arms.</p>
<h4 id="missing-unsafe"><a class="header" href="#missing-unsafe">missing-unsafe</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/missing_unsafe.rs#L10">missing_unsafe.rs</a></p>
<p>This diagnostic is triggered if an operation marked as <code>unsafe</code> is used outside of an <code>unsafe</code> function or block.</p>
<h4 id="moved-out-of-ref"><a class="header" href="#moved-out-of-ref">moved-out-of-ref</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/moved_out_of_ref.rs#L4">moved_out_of_ref.rs</a></p>
<p>This diagnostic is triggered on moving non copy things out of references.</p>
<h4 id="need-mut"><a class="header" href="#need-mut">need-mut</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/mutability_errors.rs#L8">mutability_errors.rs</a></p>
<p>This diagnostic is triggered on mutating an immutable variable.</p>
<h4 id="no-such-field"><a class="header" href="#no-such-field">no-such-field</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/no_such_field.rs#L15">no_such_field.rs</a></p>
<p>This diagnostic is triggered if created structure does not have field provided in record.</p>
<h4 id="non-exhaustive-let"><a class="header" href="#non-exhaustive-let">non-exhaustive-let</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/non_exhaustive_let.rs#L3">non_exhaustive_let.rs</a></p>
<p>This diagnostic is triggered if a <code>let</code> statement without an <code>else</code> branch has a non-exhaustive
pattern.</p>
<h4 id="parenthesized-generic-args-without-fn-trait"><a class="header" href="#parenthesized-generic-args-without-fn-trait">parenthesized-generic-args-without-fn-trait</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/parenthesized_generic_args_without_fn_trait.rs#L3">parenthesized_generic_args_without_fn_trait.rs</a></p>
<p>This diagnostic is shown when a <code>Fn</code>-trait-style generic parameters (<code>Trait(A, B) -&gt; C</code>)
was used on non-<code>Fn</code> trait/type.</p>
<h4 id="private-assoc-item"><a class="header" href="#private-assoc-item">private-assoc-item</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/private_assoc_item.rs#L3">private_assoc_item.rs</a></p>
<p>This diagnostic is triggered if the referenced associated item is not visible from the current
module.</p>
<h4 id="private-field"><a class="header" href="#private-field">private-field</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/private_field.rs#L7">private_field.rs</a></p>
<p>This diagnostic is triggered if the accessed field is not visible from the current module.</p>
<h4 id="proc-macro-disabled"><a class="header" href="#proc-macro-disabled">proc-macro-disabled</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/macro_error.rs#L11">macro_error.rs</a></p>
<p>This diagnostic is shown for proc macros that have been specifically disabled via <code>rust-analyzer.procMacro.ignored</code>.</p>
<h4 id="remove-trailing-return"><a class="header" href="#remove-trailing-return">remove-trailing-return</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/remove_trailing_return.rs#L8">remove_trailing_return.rs</a></p>
<p>This diagnostic is triggered when there is a redundant <code>return</code> at the end of a function
or closure.</p>
<h4 id="remove-unnecessary-else"><a class="header" href="#remove-unnecessary-else">remove-unnecessary-else</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/remove_unnecessary_else.rs#L17">remove_unnecessary_else.rs</a></p>
<p>This diagnostic is triggered when there is an <code>else</code> block for an <code>if</code> expression whose
then branch diverges (e.g. ends with a <code>return</code>, <code>continue</code>, <code>break</code> e.t.c).</p>
<h4 id="replace-filter-map-next-with-find-map"><a class="header" href="#replace-filter-map-next-with-find-map">replace-filter-map-next-with-find-map</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs#L11">replace_filter_map_next_with_find_map.rs</a></p>
<p>This diagnostic is triggered when <code>.filter_map(..).next()</code> is used, rather than the more concise <code>.find_map(..)</code>.</p>
<h4 id="trait-impl-incorrect-safety"><a class="header" href="#trait-impl-incorrect-safety">trait-impl-incorrect-safety</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/trait_impl_incorrect_safety.rs#L6">trait_impl_incorrect_safety.rs</a></p>
<p>Diagnoses incorrect safety annotations of trait impls.</p>
<h4 id="trait-impl-missing-assoc_item"><a class="header" href="#trait-impl-missing-assoc_item">trait-impl-missing-assoc_item</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/trait_impl_missing_assoc_item.rs#L7">trait_impl_missing_assoc_item.rs</a></p>
<p>Diagnoses missing trait items in a trait impl.</p>
<h4 id="trait-impl-orphan"><a class="header" href="#trait-impl-orphan">trait-impl-orphan</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/trait_impl_orphan.rs#L5">trait_impl_orphan.rs</a></p>
<p>Only traits defined in the current crate can be implemented for arbitrary types</p>
<h4 id="trait-impl-redundant-assoc_item"><a class="header" href="#trait-impl-redundant-assoc_item">trait-impl-redundant-assoc_item</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/trait_impl_redundant_assoc_item.rs#L12">trait_impl_redundant_assoc_item.rs</a></p>
<p>Diagnoses redundant trait items in a trait impl.</p>
<h4 id="type-mismatch"><a class="header" href="#type-mismatch">type-mismatch</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/type_mismatch.rs#L19">type_mismatch.rs</a></p>
<p>This diagnostic is triggered when the type of an expression or pattern does not match
the expected type.</p>
<h4 id="typed-hole"><a class="header" href="#typed-hole">typed-hole</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/typed_hole.rs#L20">typed_hole.rs</a></p>
<p>This diagnostic is triggered when an underscore expression is used in an invalid position.</p>
<h4 id="undeclared-label"><a class="header" href="#undeclared-label">undeclared-label</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/undeclared_label.rs#L3">undeclared_label.rs</a></p>
<h4 id="unimplemented-builtin-macro"><a class="header" href="#unimplemented-builtin-macro">unimplemented-builtin-macro</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unimplemented_builtin_macro.rs#L3">unimplemented_builtin_macro.rs</a></p>
<p>This diagnostic is shown for builtin macros which are not yet implemented by rust-analyzer</p>
<h4 id="unlinked-file"><a class="header" href="#unlinked-file">unlinked-file</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unlinked_file.rs#L20">unlinked_file.rs</a></p>
<p>This diagnostic is shown for files that are not included in any crate, or files that are part of
crates rust-analyzer failed to discover. The file will not have IDE features available.</p>
<h4 id="unnecessary-braces"><a class="header" href="#unnecessary-braces">unnecessary-braces</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/useless_braces.rs#L10">useless_braces.rs</a></p>
<p>Diagnostic for unnecessary braces in <code>use</code> items.</p>
<h4 id="unreachable-label"><a class="header" href="#unreachable-label">unreachable-label</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unreachable_label.rs#L3">unreachable_label.rs</a></p>
<h4 id="unresolved-assoc-item"><a class="header" href="#unresolved-assoc-item">unresolved-assoc-item</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_assoc_item.rs#L3">unresolved_assoc_item.rs</a></p>
<p>This diagnostic is triggered if the referenced associated item does not exist.</p>
<h4 id="unresolved-extern-crate"><a class="header" href="#unresolved-extern-crate">unresolved-extern-crate</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_extern_crate.rs#L3">unresolved_extern_crate.rs</a></p>
<p>This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.</p>
<h4 id="unresolved-field"><a class="header" href="#unresolved-field">unresolved-field</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_field.rs#L21">unresolved_field.rs</a></p>
<p>This diagnostic is triggered if a field does not exist on a given type.</p>
<h4 id="unresolved-ident"><a class="header" href="#unresolved-ident">unresolved-ident</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_ident.rs#L3">unresolved_ident.rs</a></p>
<p>This diagnostic is triggered if an expr-position ident is invalid.</p>
<h4 id="unresolved-import"><a class="header" href="#unresolved-import">unresolved-import</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_import.rs#L3">unresolved_import.rs</a></p>
<p>This diagnostic is triggered if rust-analyzer is unable to resolve a path in
a <code>use</code> declaration.</p>
<h4 id="unresolved-macro-call"><a class="header" href="#unresolved-macro-call">unresolved-macro-call</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs#L3">unresolved_macro_call.rs</a></p>
<p>This diagnostic is triggered if rust-analyzer is unable to resolve the path
to a macro in a macro invocation.</p>
<h4 id="unresolved-method"><a class="header" href="#unresolved-method">unresolved-method</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_method.rs#L16">unresolved_method.rs</a></p>
<p>This diagnostic is triggered if a method does not exist on a given type.</p>
<h4 id="unresolved-module"><a class="header" href="#unresolved-module">unresolved-module</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unresolved_module.rs#L8">unresolved_module.rs</a></p>
<p>This diagnostic is triggered if rust-analyzer is unable to discover referred module.</p>
<h4 id="unused-mut"><a class="header" href="#unused-mut">unused-mut</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/mutability_errors.rs#L63">mutability_errors.rs</a></p>
<p>This diagnostic is triggered when a mutable variable isn't actually mutated.</p>
<h4 id="unused-variables"><a class="header" href="#unused-variables">unused-variables</a></h4>
<p>Source:  <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-diagnostics/src/handlers/unused_variables.rs#L13">unused_variables.rs</a></p>
<p>This diagnostic is triggered when a local variable is not used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-features"><a class="header" href="#editor-features">Editor Features</a></h1>
<h2 id="vs-code-3"><a class="header" href="#vs-code-3">VS Code</a></h2>
<h3 id="color-configurations"><a class="header" href="#color-configurations">Color configurations</a></h3>
<p>It is possible to change the foreground/background color and font
family/size of inlay hints. Just add this to your <code>settings.json</code>:</p>
<pre><code class="language-json">{
  "editor.inlayHints.fontFamily": "Courier New",
  "editor.inlayHints.fontSize": 11,

  "workbench.colorCustomizations": {
    // Name of the theme you are currently using
    "[Default Dark+]": {
      "editorInlayHint.foreground": "#868686f0",
      "editorInlayHint.background": "#3d3d3d48",

      // Overrides for specific kinds of inlay hints
      "editorInlayHint.typeForeground": "#fdb6fdf0",
      "editorInlayHint.parameterForeground": "#fdb6fdf0",
    }
  }
}
</code></pre>
<h3 id="semantic-style-customizations"><a class="header" href="#semantic-style-customizations">Semantic style customizations</a></h3>
<p>You can customize the look of different semantic elements in the source
code. For example, mutable bindings are underlined by default and you
can override this behavior by adding the following section to your
<code>settings.json</code>:</p>
<pre><code class="language-json">{
  "editor.semanticTokenColorCustomizations": {
    "rules": {
      "*.mutable": {
        "fontStyle": "", // underline is the default
      },
    }
  },
}
</code></pre>
<p>Most themes doesn’t support styling unsafe operations differently yet.
You can fix this by adding overrides for the rules <code>operator.unsafe</code>,
<code>function.unsafe</code>, and <code>method.unsafe</code>:</p>
<pre><code class="language-json">{
   "editor.semanticTokenColorCustomizations": {
         "rules": {
             "operator.unsafe": "#ff6600",
             "function.unsafe": "#ff6600",
             "method.unsafe": "#ff6600"
         }
    },
}
</code></pre>
<p>In addition to the top-level rules you can specify overrides for
specific themes. For example, if you wanted to use a darker text color
on a specific light theme, you might write:</p>
<pre><code class="language-json">{
   "editor.semanticTokenColorCustomizations": {
         "rules": {
             "operator.unsafe": "#ff6600"
         },
         "[Ayu Light]": {
            "rules": {
               "operator.unsafe": "#572300"
            }
         }
    },
}
</code></pre>
<p>Make sure you include the brackets around the theme name. For example,
use <code>"[Ayu Light]"</code> to customize the theme Ayu Light.</p>
<h3 id="special-when-clause-context-for-keybindings"><a class="header" href="#special-when-clause-context-for-keybindings">Special <code>when</code> clause context for keybindings.</a></h3>
<p>You may use <code>inRustProject</code> context to configure keybindings for rust
projects only. For example:</p>
<pre><code class="language-json">{
    "key": "ctrl+alt+d",
    "command": "rust-analyzer.openDocs",
    "when": "inRustProject"
}
</code></pre>
<p>More about <code>when</code> clause contexts
<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts">here</a>.</p>
<h3 id="setting-runnable-environment-variables"><a class="header" href="#setting-runnable-environment-variables">Setting runnable environment variables</a></h3>
<p>You can use "rust-analyzer.runnables.extraEnv" setting to define
runnable environment-specific substitution variables. The simplest way
for all runnables in a bunch:</p>
<pre><code class="language-json">"rust-analyzer.runnables.extraEnv": {
    "RUN_SLOW_TESTS": "1"
}
</code></pre>
<p>Or it is possible to specify vars more granularly:</p>
<pre><code class="language-json">"rust-analyzer.runnables.extraEnv": [
    {
        // "mask": null, // null mask means that this rule will be applied for all runnables
        "env": {
                "APP_ID": "1",
                "APP_DATA": "asdf"
        }
    },
    {
        "mask": "test_name",
        "env": {
                "APP_ID": "2", // overwrites only APP_ID
        }
    }
]
</code></pre>
<p>You can use any valid regular expression as a mask. Also note that a
full runnable name is something like <strong>run bin_or_example_name</strong>,
<strong>test some::mod::test_name</strong> or <strong>test-mod some::mod</strong>, so it is
possible to distinguish binaries, single tests, and test modules with
this masks: <code>"^run"</code>, <code>"^test "</code> (the trailing space matters!), and
<code>"^test-mod"</code> respectively.</p>
<p>If needed, you can set different values for different platforms:</p>
<pre><code class="language-json">"rust-analyzer.runnables.extraEnv": [
    {
        "platform": "win32", // windows only
        "env": {
                "APP_DATA": "windows specific data"
        }
    },
    {
        "platform": ["linux"],
        "env": {
                "APP_DATA": "linux data",
        }
    },
    { // for all platforms
        "env": {
                "APP_COMMON_DATA": "xxx",
        }
    }
]
</code></pre>
<h3 id="compiler-feedback-from-external-commands"><a class="header" href="#compiler-feedback-from-external-commands">Compiler feedback from external commands</a></h3>
<p>Instead of relying on the built-in <code>cargo check</code>, you can configure Code
to run a command in the background and use the <code>$rustc-watch</code> problem
matcher to generate inline error markers from its output.</p>
<p>To do this you need to create a new <a href="https://code.visualstudio.com/docs/editor/tasks">VS Code
Task</a> and set
<code>"rust-analyzer.checkOnSave": false</code> in preferences.</p>
<p>For example, if you want to run
<a href="https://crates.io/crates/cargo-watch"><code>cargo watch</code></a> instead, you might
add the following to <code>.vscode/tasks.json</code>:</p>
<pre><code class="language-json">{
    "label": "Watch",
    "group": "build",
    "type": "shell",
    "command": "cargo watch",
    "problemMatcher": "$rustc-watch",
    "isBackground": true
}
</code></pre>
<h3 id="live-share"><a class="header" href="#live-share">Live Share</a></h3>
<p>VS Code Live Share has partial support for rust-analyzer.</p>
<p>Live Share <em>requires</em> the official Microsoft build of VS Code, OSS
builds will not work correctly.</p>
<p>The host’s rust-analyzer instance will be shared with all guests joining
the session. The guests do not have to have the rust-analyzer extension
installed for this to work.</p>
<p>If you are joining a Live Share session and <em>do</em> have rust-analyzer
installed locally, commands from the command palette will not work
correctly since they will attempt to communicate with the local server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-quick-start"><a class="header" href="#contributing-quick-start">Contributing Quick Start</a></h1>
<p>rust-analyzer is an ordinary Rust project, which is organized as a Cargo workspace, builds on stable and doesn't depend on C libraries.
So, just</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p>should be enough to get you started!</p>
<p>To learn more about how rust-analyzer works, see <a href="contributing/architecture.html">Architecture</a>.
It also explains the high-level layout of the source code.
Do skim through that document.</p>
<p>We also publish rustdoc docs to <a href="https://rust-lang.github.io/rust-analyzer/ide/">https://rust-lang.github.io/rust-analyzer/ide/</a>.
Note though, that the internal documentation is very incomplete.</p>
<p>Various organizational and process issues are discussed in this document.</p>
<h1 id="getting-in-touch"><a class="header" href="#getting-in-touch">Getting in Touch</a></h1>
<p>rust-analyzer is a part of the <a href="https://github.com/rust-lang/compiler-team/tree/6a769c13656c0a6959ebc09e7b1f7c09b86fb9c0/working-groups/rls-2.0">RLS-2.0 working
group</a>.
Discussion happens in this Zulip stream:</p>
<p><a href="https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer">https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer</a></p>
<ul>
<li><a href="contributing/index.html#issue-labels">Issue Labels</a></li>
<li><a href="contributing/index.html#code-style--review-process">Code Style &amp; Review Process</a></li>
<li><a href="contributing/index.html#cookbook">Cookbook</a>
<ul>
<li><a href="contributing/index.html#ci">CI</a></li>
<li><a href="contributing/index.html#launching-rust-analyzer">Launching rust-analyzer</a></li>
<li><a href="contributing/index.html#typescript-tests">TypeScript Tests</a></li>
<li><a href="contributing/index.html#how-to-">How to ...</a></li>
<li><a href="contributing/index.html#logging">Logging</a></li>
<li><a href="contributing/index.html#profiling">Profiling</a></li>
<li><a href="contributing/index.html#release-process">Release Process</a></li>
<li><a href="contributing/index.html#permissions">Permissions</a></li>
<li><a href="contributing/index.html#synchronizing-subtree-changes">Synchronizing subtree changes</a>
<ul>
<li><a href="contributing/index.html#performing-a-pull">Performing a pull</a></li>
<li><a href="contributing/index.html#performing-a-push">Performing a push</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="issue-labels"><a class="header" href="#issue-labels">Issue Labels</a></h1>
<ul>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22good%20first%20issue%22">good-first-issue</a>
are good issues to get into the project.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-has-instructions">E-has-instructions</a>
issues have links to the code in question and tests.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is:issue+is:open+label:%22Broken+Window%22">Broken Window</a>
are issues which are not necessarily critical by themselves, but which should be fixed ASAP regardless, to avoid accumulation of technical debt.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy">E-easy</a>,
<a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-medium">E-medium</a>,
<a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-hard">E-hard</a>,
<a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-unknown">E-unknown</a>,
labels are <em>estimates</em> for how hard would be to write a fix. Each triaged issue should have one of these labels.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AS-actionable">S-actionable</a> and
<a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AS-unactionable">S-unactionable</a>
specify if there are concrete steps to resolve or advance an issue. Roughly, actionable issues need only work to be fixed,
while unactionable ones are blocked either on user feedback (providing a reproducible example), or on larger architectural
work or decisions. This classification is descriptive, not prescriptive, and might be wrong: Any unactionable issue might have a simple fix that we missed.
Each triaged issue should have one of these labels.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3Afun">fun</a>
is for cool, but probably hard stuff.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/issues?q=is%3Aissue%20state%3Aopen%20label%3AC-Architecture">C-Architecture</a>
is for moderate/large scale architecture discussion.
Also a kind of fun.
These issues should generally include a link to a Zulip discussion thread.</li>
</ul>
<h1 id="code-style--review-process"><a class="header" href="#code-style--review-process">Code Style &amp; Review Process</a></h1>
<p>See the <a href="contributing/style.html">Style Guide</a>.</p>
<h1 id="cookbook"><a class="header" href="#cookbook">Cookbook</a></h1>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>We use GitHub Actions for CI.
Most of the things, including formatting, are checked by <code>cargo test</code>.
If <code>cargo test</code> passes locally, that's a good sign that CI will be green as well.
The only exception is that some long-running tests are skipped locally by default.
Use <code>env RUN_SLOW_TESTS=1 cargo test</code> to run the full suite.</p>
<p>We use bors to enforce the <a href="https://graydon2.dreamwidth.org/1597.html">not rocket science</a> rule.</p>
<h2 id="launching-rust-analyzer"><a class="header" href="#launching-rust-analyzer">Launching rust-analyzer</a></h2>
<p>Debugging the language server can be tricky.
LSP is rather chatty, so driving it from the command line is not really feasible, driving it via VS Code requires interacting with two processes.</p>
<p>For this reason, the best way to see how rust-analyzer works is to <strong>find a relevant test and execute it</strong>.
VS Code &amp; Emacs include an action for running a single test.</p>
<p>Launching a VS Code instance with a locally built language server is also possible.
There's <strong>"Run Extension (Debug Build)"</strong> launch configuration for this in VS Code.</p>
<p>In general, I use one of the following workflows for fixing bugs and implementing features:</p>
<p>If the problem concerns only internal parts of rust-analyzer (i.e. I don't need to touch the <code>rust-analyzer</code> crate or TypeScript code), there is a unit-test for it.
So, I use <strong>rust-analyzer: Run</strong> action in VS Code to run this single test, and then just do printf-driven development/debugging.
As a sanity check after I'm done, I use <code>cargo xtask install --server</code> and <strong>Reload Window</strong> action in VS Code to verify that the thing works as I expect.</p>
<p>If the problem concerns only the VS Code extension, I use <strong>Run Installed Extension</strong> launch configuration from <code>launch.json</code>.
Notably, this uses the usual <code>rust-analyzer</code> binary from <code>PATH</code>.
For this, it is important to have the following in your <code>settings.json</code> file:</p>
<pre><code class="language-json">{
    "rust-analyzer.server.path": "rust-analyzer"
}
</code></pre>
<p>After I am done with the fix, I use <code>cargo xtask install --client</code> to try the new extension for real.</p>
<p>If I need to fix something in the <code>rust-analyzer</code> crate, I feel sad because it's on the boundary between the two processes, and working there is slow.
I usually just <code>cargo xtask install --server</code> and poke changes from my live environment.
Note that this uses <code>--release</code>, which is usually faster overall, because loading stdlib into debug version of rust-analyzer takes a lot of time.
To speed things up, sometimes I open a temporary hello-world project which has <code>"rust-analyzer.cargo.sysroot": null</code> in <code>.code/settings.json</code>.
This flag causes rust-analyzer to skip loading the sysroot, which greatly reduces the amount of things rust-analyzer needs to do, and makes printf's more useful.
Note that you should only use the <code>eprint!</code> family of macros for debugging: stdout is used for LSP communication, and <code>print!</code> would break it.</p>
<p>If I need to fix something simultaneously in the server and in the client, I feel even more sad.
I don't have a specific workflow for this case.</p>
<p>Additionally, I use <code>cargo run --release -p rust-analyzer -- analysis-stats path/to/some/rust/crate</code> to run a batch analysis.
This is primarily useful for performance optimizations, or for bug minimization.</p>
<h2 id="typescript-tests"><a class="header" href="#typescript-tests">TypeScript Tests</a></h2>
<p>If you change files under <code>editors/code</code> and would like to run the tests and linter, install npm and run:</p>
<pre><code class="language-bash">cd editors/code
npm ci
npm run lint
</code></pre>
<h2 id="how-to-"><a class="header" href="#how-to-">How to ...</a></h2>
<ul>
<li>... add an assist? <a href="https://github.com/rust-lang/rust-analyzer/pull/7535">#7535</a></li>
<li>... add a new protocol extension? <a href="https://github.com/rust-lang/rust-analyzer/pull/4569">#4569</a></li>
<li>... add a new configuration option? <a href="https://github.com/rust-lang/rust-analyzer/pull/7451">#7451</a></li>
<li>... add a new completion? <a href="https://github.com/rust-lang/rust-analyzer/pull/6964">#6964</a></li>
<li>... allow new syntax in the parser? <a href="https://github.com/rust-lang/rust-analyzer/pull/7338">#7338</a></li>
</ul>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Logging is done by both rust-analyzer and VS Code, so it might be tricky to figure out where logs go.</p>
<p>Inside rust-analyzer, we use the <a href="https://docs.rs/tracing/"><code>tracing</code></a> crate for logging,
and <a href="https://docs.rs/tracing-subscriber"><code>tracing-subscriber</code></a> for logging frontend.
By default, log goes to stderr, but the stderr itself is processed by VS Code.
<code>--log-file &lt;PATH&gt;</code> CLI argument allows logging to file.
Setting the <code>RA_LOG_FILE=&lt;PATH&gt;</code> environment variable will also log to file, it will also override <code>--log-file</code>.</p>
<p>To see the server stderr output in the running VS Code instance, go to the "Output" tab of the panel
and select <code>rust-analyzer Language Server</code>.
This shows <code>eprintln!</code> as well.
Note that <code>stdout</code> is used by LSP messages, so using <code>println!</code>—or anything that writes to <code>stdout</code>—will break rust-analyzer!</p>
<p>To log all communication between the server and the client, there are two choices:</p>
<ul>
<li>
<p>You can log on the server side, by running something like</p>
<pre><code class="language-bash">env RA_LOG=lsp_server=debug code .
</code></pre>
</li>
<li>
<p>You can log on the client side, by the <code>rust-analyzer: Toggle LSP Logs</code> command or enabling <code>"rust-analyzer.trace.server": "verbose"</code> workspace setting.
These logs are shown in a separate tab named <code>rust-analyzer LSP Trace</code> in the output and could be used with LSP inspector.
Kudos to <a href="https://github.com/DJMcNab">@DJMcNab</a> for setting this awesome infra up!</p>
</li>
</ul>
<p>Finally there are the logs of the VSCode extension itself which go into the <code>rust-analyzer Extension</code> output tab.</p>
<p>There are also several VS Code commands which might be of interest:</p>
<ul>
<li>
<p><code>rust-analyzer: Status</code> shows some memory-usage statistics.</p>
</li>
<li>
<p><code>rust-analyzer: View Hir</code> shows the HIR expressions within the function containing the cursor.</p>
</li>
<li>
<p>If <code>rust-analyzer.showSyntaxTree</code> is enabled in settings, <code>Rust Syntax Tree: Focus on Rust Syntax Tree View</code> shows the syntax tree of the current file.</p>
<p>You can click on nodes in the rust editor to go to the corresponding syntax node.</p>
<p>You can click on <code>Reveal Syntax Element</code> next to a syntax node to go to the corresponding rust code and highlight the proper text range.</p>
<p>If you trigger Go to Definition in the inspected Rust source file,
the syntax tree view should scroll to and select the
appropriate syntax node token.</p>
<p>You can click on <code>Copy</code> next to a syntax node to copy a text representation of the node.</p>
<p><img src="https://github.com/user-attachments/assets/2d20ae87-0abf-495f-bee8-54aa2494a00d" alt="demo" /></p>
</li>
</ul>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>We have a built-in hierarchical profiler, you can enable it by using <code>RA_PROFILE</code> env-var:</p>
<pre><code class="language-bash">RA_PROFILE=*             // dump everything
RA_PROFILE=foo|bar|baz   // enabled only selected entries
RA_PROFILE=*@3&gt;10        // dump everything, up to depth 3, if it takes more than 10 ms
</code></pre>
<p>Some rust-analyzer contributors have <code>export RA_PROFILE='*&gt;10'</code> in my shell profile.</p>
<p>For machine-readable JSON output, we have the <code>RA_PROFILE_JSON</code> env variable. We support
filtering only by span name:</p>
<pre><code class="language-bash">RA_PROFILE=* // dump everything
RA_PROFILE_JSON="vfs_load|parallel_prime_caches|discover_command" // dump selected spans
</code></pre>
<p>We also have a "counting" profiler which counts number of instances of popular structs.
It is enabled by <code>RA_COUNT=1</code>.</p>
<p>To measure time for from-scratch analysis, use something like this:</p>
<pre><code class="language-bash">$ cargo run --release -p rust-analyzer -- analysis-stats ../chalk/
</code></pre>
<p>For measuring time of incremental analysis, use either of these:</p>
<pre><code class="language-bash">$ cargo run --release -p rust-analyzer -- analysis-bench ../chalk/ --highlight ../chalk/chalk-engine/src/logic.rs
$ cargo run --release -p rust-analyzer -- analysis-bench ../chalk/ --complete ../chalk/chalk-engine/src/logic.rs:94:0
</code></pre>
<p>Look for <code>fn benchmark_xxx</code> tests for a quick way to reproduce performance problems.</p>
<h2 id="release-process"><a class="header" href="#release-process">Release Process</a></h2>
<p>Release process is handled by <code>release</code>, <code>dist</code>, <code>publish-release-notes</code> and <code>promote</code> xtasks, <code>release</code> being the main one.</p>
<p><code>release</code> assumes that you have checkouts of <code>rust-analyzer</code>, <code>rust-analyzer.github.io</code>, and <code>rust-lang/rust</code> in the same directory:</p>
<pre><code class="language-bash">./rust-analyzer
./rust-analyzer.github.io
./rust-rust-analyzer  # Note the name!
</code></pre>
<p>The remote for <code>rust-analyzer</code> must be called <code>upstream</code> (I use <code>origin</code> to point to my fork).
In addition, for <code>xtask promote</code> (see below), <code>rust-rust-analyzer</code> must have a <code>rust-analyzer</code> remote pointing to this repository on GitHub.</p>
<p><code>release</code> calls the GitHub API calls to scrape pull request comments and categorize them in the changelog.
This step uses the <code>curl</code> and <code>jq</code> applications, which need to be available in <code>PATH</code>.
Finally, you need to obtain a GitHub personal access token and set the <code>GITHUB_TOKEN</code> environment variable.</p>
<p>Release steps:</p>
<ol>
<li>Set the <code>GITHUB_TOKEN</code> environment variable.</li>
<li>Inside rust-analyzer, run <code>cargo xtask release</code>. This will:
<ul>
<li>checkout the <code>release</code> branch</li>
<li>reset it to <code>upstream/nightly</code></li>
<li>push it to <code>upstream</code>. This triggers GitHub Actions which:
<ul>
<li>runs <code>cargo xtask dist</code> to package binaries and VS Code extension</li>
<li>makes a GitHub release</li>
<li>publishes the VS Code extension to the marketplace</li>
</ul>
</li>
<li>call the GitHub API for PR details</li>
<li>create a new changelog in <code>rust-analyzer.github.io</code></li>
</ul>
</li>
<li>While the release is in progress, fill in the changelog.</li>
<li>Commit &amp; push the changelog.</li>
<li>Run <code>cargo xtask publish-release-notes &lt;CHANGELOG&gt;</code> -- this will convert the changelog entry in AsciiDoc to Markdown and update the body of GitHub Releases entry.</li>
<li>Tweet.</li>
<li>Perform a subtree <a href="contributing/index.html#performing-a-pull">pull</a>.</li>
<li>Perform a subtree <a href="contributing/index.html#performing-a-push">push</a>.</li>
</ol>
<p>If the GitHub Actions release fails because of a transient problem like a timeout, you can re-run the job from the Actions console.
If it fails because of something that needs to be fixed, remove the release tag (if needed), fix the problem, then start over.
Make sure to remove the new changelog post created when running <code>cargo xtask release</code> a second time.</p>
<p>We release "nightly" every night automatically and promote the latest nightly to "stable" manually, every week.</p>
<p>We don't do "patch" releases, unless something truly egregious comes up.
To do a patch release, cherry-pick the fix on top of the current <code>release</code> branch and push the branch.
There's no need to write a changelog for a patch release, it's OK to include the notes about the fix into the next weekly one.
Note: we tag releases by dates, releasing a patch release on the same day should work (by overwriting a tag), but I am not 100% sure.</p>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>There are two sets of people with extra permissions:</p>
<ul>
<li>The <a href="https://github.com/rust-lang">rust-lang</a> team <a href="https://github.com/rust-lang/team/blob/master/teams/rust-analyzer.toml">t-rust-analyzer</a>.
This team has write access to the repository and merge queue permissions (note the repo itself is managed by infra admins).
It's ok to self-approve if you think you know what you are doing!
Feel free to request a review or assign any PR to a reviewer with the relevant expertise to bring the work to their attention.
Don't feel pressured to review assigned PRs though.
If you don't feel like reviewing for whatever reason, someone else will pick the review up (but please speak up if you don't feel like it)!</li>
<li>The <a href="https://github.com/rust-lang">rust-lang</a> team <a href="https://github.com/rust-lang/team/blob/master/teams/rust-analyzer-contributors.toml">t-rust-analyzer-contributors</a>.
This team has general triaging permissions allowing to label, close and re-open issues.</li>
</ul>
<h2 id="synchronizing-subtree-changes"><a class="header" href="#synchronizing-subtree-changes">Synchronizing subtree changes</a></h2>
<p><code>rust-analyzer</code> is a <a href="https://josh-project.github.io/josh/intro.html">josh</a> subtree of the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a>
repository. We use the <a href="https://github.com/rust-lang/josh-sync">rustc-josh-sync</a> tool to perform synchronization between these two
repositories. You can find documentation of the tool <a href="https://github.com/rust-lang/josh-sync">here</a>.</p>
<p>You can install the synchronization tool using the following commands:</p>
<pre><code>cargo install --locked --git https://github.com/rust-lang/josh-sync
</code></pre>
<p>Both pulls (synchronizing changes from rust-lang/rust into rust-analyzer) and pushes (synchronizing
changes from rust-analyzer into rust-lang/rust) are performed from this repository.
changes from rust-analyzer to rust-lang/rust) are performed from this repository.</p>
<p>Usually we first perform a pull, wait for it to be merged, and then perform a push.</p>
<h3 id="performing-a-pull"><a class="header" href="#performing-a-pull">Performing a pull</a></h3>
<ol>
<li>Checkout a new branch that will be used to create a PR against rust-analyzer</li>
<li>Run the pull command
<pre><code>rustc-josh-sync pull
</code></pre>
</li>
<li>Push the branch to your fork of <code>rust-analyzer</code> and create a PR</li>
</ol>
<ul>
<li>If you have the <code>gh</code> CLI installed, <code>rustc-josh-sync</code> can create the PR for you.</li>
</ul>
<h3 id="performing-a-push"><a class="header" href="#performing-a-push">Performing a push</a></h3>
<p>Wait for the previous pull to be merged.</p>
<ol>
<li>Switch to <code>master</code> and pull</li>
<li>Run the push command to create a branch named <code>&lt;branch-name&gt;</code> in a <code>rustc</code> fork under the <code>&lt;gh-username&gt;</code> account
<pre><code>rustc-josh-sync push &lt;branch-name&gt; &lt;gh-username&gt;
</code></pre>
<ul>
<li>The push will ask you to download a checkout of the <code>rust-lang/rust</code> repository.</li>
<li>If you get prompted for a password, see <a href="https://github.com/rust-lang/josh-sync?tab=readme-ov-file#git-peculiarities">this</a>.</li>
</ul>
</li>
<li>Create a PR from <code>&lt;branch-name&gt;</code> into <code>rust-lang/rust</code></li>
</ol>
<blockquote>
<p>Besides the <code>rust</code> checkout, the Josh cache (stored under <code>~/.cache/rustc-josh</code>) will contain a bare clone of <code>rust-lang/rust</code>. This currently takes several GBs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This document describes the high-level architecture of rust-analyzer.
If you want to familiarize yourself with the code base, you are just in the right place!</p>
<p>You might also enjoy <a href="https://www.youtube.com/playlist?list=PLhb66M_x9UmrqXhQuIpWC5VgTdrGxMx3y">"Explaining Rust Analyzer"</a> series on YouTube.
It goes deeper than what is covered in this document, but will take some time to watch.</p>
<p>See also these implementation-related blog posts:</p>
<ul>
<li><a href="https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html">https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html">https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html">https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html</a></li>
<li><a href="https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html">https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html</a></li>
</ul>
<p>For older, by now mostly outdated stuff, see the <a href="contributing/./guide.html">guide</a> and <a href="https://www.youtube.com/playlist?list=PL85XCvVPmGQho7MZkdW-wtPtuJcFpzycE">another playlist</a>.</p>
<h2 id="birds-eye-view"><a class="header" href="#birds-eye-view">Bird's Eye View</a></h2>
<p><img src="https://user-images.githubusercontent.com/4789492/107129398-0ab70f00-687a-11eb-9bfc-d4eb023aec06.png" alt="" /></p>
<ul>
<li><a href="contributing/architecture.html#entry-points">Entry Points</a></li>
<li><a href="contributing/architecture.html#code-map">Code Map</a>
<ul>
<li><a href="contributing/architecture.html#xtask"><code>xtask</code></a></li>
<li><a href="contributing/architecture.html#editorscode"><code>editors/code</code></a></li>
<li><a href="contributing/architecture.html#lib"><code>lib/</code></a></li>
<li><a href="contributing/architecture.html#cratesparser"><code>crates/parser</code></a></li>
<li><a href="contributing/architecture.html#cratessyntax"><code>crates/syntax</code></a></li>
<li><a href="contributing/architecture.html#cratesbase-db"><code>crates/base-db</code></a></li>
<li><a href="contributing/architecture.html#crateshir-expand-crateshir-def-crateshir_ty"><code>crates/hir-expand</code>, <code>crates/hir-def</code>, <code>crates/hir_ty</code></a></li>
<li><a href="contributing/architecture.html#crateshir"><code>crates/hir</code></a></li>
<li><a href="contributing/architecture.html#crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><code>crates/ide</code>, <code>crates/ide-db</code>, <code>crates/ide-assists</code>, <code>crates/ide-completion</code>, <code>crates/ide-diagnostics</code>, <code>crates/ide-ssr</code></a></li>
<li><a href="contributing/architecture.html#cratesrust-analyzer"><code>crates/rust-analyzer</code></a></li>
<li><a href="contributing/architecture.html#cratestoolchain-cratesproject-model-cratesflycheck"><code>crates/toolchain</code>, <code>crates/project-model</code>, <code>crates/flycheck</code></a></li>
<li><a href="contributing/architecture.html#cratesmbe-cratestt-cratesproc-macro-api-cratesproc-macro-srv-cratesproc-macro-srv-cli"><code>crates/mbe</code>, <code>crates/tt</code>, <code>crates/proc-macro-api</code>, <code>crates/proc-macro-srv</code>, <code>crates/proc-macro-srv-cli</code></a></li>
<li><a href="contributing/architecture.html#cratescfg"><code>crates/cfg</code></a></li>
<li><a href="contributing/architecture.html#cratesvfs-cratesvfs-notify-cratespaths"><code>crates/vfs</code>, <code>crates/vfs-notify</code>, <code>crates/paths</code></a></li>
<li><a href="contributing/architecture.html#cratesstdx"><code>crates/stdx</code></a></li>
<li><a href="contributing/architecture.html#cratesprofile"><code>crates/profile</code></a></li>
<li><a href="contributing/architecture.html#cratesintern"><code>crates/intern</code></a></li>
<li><a href="contributing/architecture.html#cratesload-cargo"><code>crates/load-cargo</code></a></li>
<li><a href="contributing/architecture.html#cratesrustc-dependencies"><code>crates/rustc-dependencies</code></a></li>
<li><a href="contributing/architecture.html#cratesspan"><code>crates/span</code></a></li>
</ul>
</li>
<li><a href="contributing/architecture.html#cross-cutting-concerns">Cross-Cutting Concerns</a>
<ul>
<li><a href="contributing/architecture.html#stability-guarantees">Stability Guarantees</a></li>
<li><a href="contributing/architecture.html#code-generation">Code generation</a></li>
<li><a href="contributing/architecture.html#cancellation">Cancellation</a></li>
<li><a href="contributing/architecture.html#testing">Testing</a></li>
<li><a href="contributing/architecture.html#performance-testing">Performance Testing</a></li>
<li><a href="contributing/architecture.html#error-handling">Error Handling</a></li>
<li><a href="contributing/architecture.html#observability">Observability</a></li>
<li><a href="contributing/architecture.html#configurability">Configurability</a></li>
<li><a href="contributing/architecture.html#serialization">Serialization</a></li>
</ul>
</li>
</ul>
<p>On the highest level, rust-analyzer is a thing which accepts input source code from the client and produces a structured semantic model of the code.</p>
<p>More specifically, input data consists of a set of test files (<code>(PathBuf, String)</code> pairs) and information about project structure, captured in the so called <code>CrateGraph</code>.
The crate graph specifies which files are crate roots, which cfg flags are specified for each crate and what dependencies exist between the crates.
This is the input (ground) state.
The analyzer keeps all this input data in memory and never does any IO.
Because the input data is source code, which typically measures in tens of megabytes at most, keeping everything in memory is OK.</p>
<p>A "structured semantic model" is basically an object-oriented representation of modules, functions and types which appear in the source code.
This representation is fully "resolved": all expressions have types, all references are bound to declarations, etc.
This is derived state.</p>
<p>The client can submit a small delta of input data (typically, a change to a single file) and get a fresh code model which accounts for changes.</p>
<p>The underlying engine makes sure that model is computed lazily (on-demand) and can be quickly updated for small modifications.</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry Points</a></h2>
<p><code>crates/rust-analyzer/src/bin/main.rs</code> contains the main function which spawns LSP.
This is <em>the</em> entry point, but it front-loads a lot of complexity, so it's fine to just skim through it.</p>
<p><code>crates/rust-analyzer/src/handlers/request.rs</code> implements all LSP requests and is a great place to start if you are already familiar with LSP.</p>
<p><code>Analysis</code> and <code>AnalysisHost</code> types define the main API for consumers of IDE services.</p>
<h2 id="code-map"><a class="header" href="#code-map">Code Map</a></h2>
<p>This section talks briefly about various important directories and data structures.
Pay attention to the <strong>Architecture Invariant</strong> sections.
They often talk about things which are deliberately absent in the source code.</p>
<p>Note also which crates are <strong>API Boundaries</strong>.
Remember, <a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">rules at the boundary are different</a>.</p>
<h3 id="xtask"><a class="header" href="#xtask"><code>xtask</code></a></h3>
<p>This is rust-analyzer's "build system".
We use cargo to compile rust code, but there are also various other tasks, like release management or local installation.
They are handled by Rust code in the xtask directory.</p>
<h3 id="editorscode"><a class="header" href="#editorscode"><code>editors/code</code></a></h3>
<p>VS Code plugin.</p>
<h3 id="lib"><a class="header" href="#lib"><code>lib/</code></a></h3>
<p>rust-analyzer independent libraries which we publish to crates.io.
It's not heavily utilized at the moment.</p>
<h3 id="cratesparser"><a class="header" href="#cratesparser"><code>crates/parser</code></a></h3>
<p>It is a hand-written recursive descent parser, which produces a sequence of events like "start node X", "finish node Y".
It works similarly to
<a href="https://github.com/JetBrains/kotlin/blob/4d951de616b20feca92f3e9cc9679b2de9e65195/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinParsing.java">kotlin's parser</a>,
which is a good source of inspiration for dealing with syntax errors and incomplete input.
Original <a href="https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src/libsyntax/parse/parser.rs">libsyntax parser</a> is what we use for the definition of the Rust language.
<code>TreeSink</code> and <code>TokenSource</code> traits bridge the tree-agnostic parser from <code>grammar</code> with <code>rowan</code> trees.</p>
<p><strong>Architecture Invariant:</strong> the parser is independent of the particular tree structure and particular representation of the tokens.
It transforms one flat stream of events into another flat stream of events.
Token independence allows us to parse out both text-based source code and <code>tt</code>-based macro input.
Tree independence allows us to more easily vary the syntax tree implementation.
It should also unlock efficient light-parsing approaches.
For example, you can extract the set of names defined in a file (for typo correction) without building a syntax tree.</p>
<p><strong>Architecture Invariant:</strong> parsing never fails, the parser produces <code>(T, Vec&lt;Error&gt;)</code> rather than <code>Result&lt;T, Error&gt;</code>.</p>
<h3 id="cratessyntax"><a class="header" href="#cratessyntax"><code>crates/syntax</code></a></h3>
<p>Rust syntax tree structure and parser.
See <a href="https://github.com/rust-lang/rfcs/pull/2256">RFC</a> and <a href="contributing/./syntax.html">./syntax.md</a> for some design notes.</p>
<ul>
<li><a href="https://github.com/rust-analyzer/rowan">rowan</a> library is used for constructing syntax trees.</li>
<li><code>ast</code> provides a type safe API on top of the raw <code>rowan</code> tree.</li>
<li><code>ungrammar</code> description of the grammar, which is used to generate <code>syntax_kinds</code> and <code>ast</code> modules, using <code>cargo test -p xtask</code> command.</li>
</ul>
<p>Tests for ra_syntax are mostly data-driven.
<code>test_data/parser</code> contains subdirectories with a bunch of <code>.rs</code> (test vectors) and <code>.txt</code> files with corresponding syntax trees.
During testing, we check <code>.rs</code> against <code>.txt</code>.
If the <code>.txt</code> file is missing, it is created (this is how you update tests).
Additionally, running the xtask test suite with <code>cargo test -p xtask</code> will walk the grammar module and collect all <code>// test test_name</code> comments into files inside <code>test_data/parser/inline</code> directory.</p>
<p>To update test data, run with <code>UPDATE_EXPECT</code> variable:</p>
<pre><code class="language-bash">env UPDATE_EXPECT=1 cargo qt
</code></pre>
<p>After adding a new inline test you need to run <code>cargo test -p xtask</code> and also update the test data as described above.</p>
<p>Note <a href="https://github.com/rust-lang/rust-analyzer/blob/2fb6af89eb794f775de60b82afe56b6f986c2a40/crates/ra_syntax/src/lib.rs#L190-L348"><code>api_walkthrough</code></a>
in particular: it shows off various methods of working with syntax tree.</p>
<p>See <a href="https://github.com/rust-lang/rust-analyzer/pull/93">#93</a> for an example PR which fixes a bug in the grammar.</p>
<p><strong>Architecture Invariant:</strong> <code>syntax</code> crate is completely independent from the rest of rust-analyzer. It knows nothing about salsa or LSP.
This is important because it is possible to make useful tooling using only the syntax tree.
Without semantic information, you don't need to be able to <em>build</em> code, which makes the tooling more robust.
See also https://mlfbrown.com/paper.pdf.
You can view the <code>syntax</code> crate as an entry point to rust-analyzer.
<code>syntax</code> crate is an <strong>API Boundary</strong>.</p>
<p><strong>Architecture Invariant:</strong> syntax tree is a value type.
The tree is fully determined by the contents of its syntax nodes, it doesn't need global context (like an interner) and doesn't store semantic info.
Using the tree as a store for semantic info is convenient in traditional compilers, but doesn't work nicely in the IDE.
Specifically, assists and refactors require transforming syntax trees, and that becomes awkward if you need to do something with the semantic info.</p>
<p><strong>Architecture Invariant:</strong> syntax tree is built for a single file.
This is to enable parallel parsing of all files.</p>
<p><strong>Architecture Invariant:</strong>  Syntax trees are by design incomplete and do not enforce well-formedness.
If an AST method returns an <code>Option</code>, it <em>can</em> be <code>None</code> at runtime, even if this is forbidden by the grammar.</p>
<h3 id="cratesbase-db"><a class="header" href="#cratesbase-db"><code>crates/base-db</code></a></h3>
<p>We use the <a href="https://github.com/salsa-rs/salsa">salsa</a> crate for incremental and on-demand computation.
Roughly, you can think of salsa as a key-value store, but it can also compute derived values using specified functions.
The <code>base-db</code> crate provides basic infrastructure for interacting with salsa.
Crucially, it defines most of the "input" queries: facts supplied by the client of the analyzer.
Reading the docs of the <code>base_db::input</code> module should be useful: everything else is strictly derived from those inputs.</p>
<p><strong>Architecture Invariant:</strong> particularities of the build system are <em>not</em> the part of the ground state.
In particular, <code>base-db</code> knows nothing about cargo.
For example, <code>cfg</code> flags are a part of <code>base_db</code>, but <code>feature</code>s are not.
A <code>foo</code> feature is a Cargo-level concept, which is lowered by Cargo to <code>--cfg feature=foo</code> argument on the command line.
The <code>CrateGraph</code> structure is used to represent the dependencies between the crates abstractly.</p>
<p><strong>Architecture Invariant:</strong> <code>base-db</code> doesn't know about file system and file paths.
Files are represented with opaque <code>FileId</code>, there's no operation to get an <code>std::path::Path</code> out of the <code>FileId</code>.</p>
<h3 id="crateshir-expand-crateshir-def-crateshir_ty"><a class="header" href="#crateshir-expand-crateshir-def-crateshir_ty"><code>crates/hir-expand</code>, <code>crates/hir-def</code>, <code>crates/hir_ty</code></a></h3>
<p>These crates are the <em>brain</em> of rust-analyzer.
This is the compiler part of the IDE.</p>
<p><code>hir-xxx</code> crates have a strong <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a> flavor, in that they work with raw ids and directly query the database.
There's little abstraction here.
These crates integrate deeply with salsa and chalk.</p>
<p>Name resolution, macro expansion and type inference all happen here.
These crates also define various intermediate representations of the core.</p>
<p><code>ItemTree</code> condenses a single <code>SyntaxTree</code> into a "summary" data structure, which is stable over modifications to function bodies.</p>
<p><code>DefMap</code> contains the module tree of a crate and stores module scopes.</p>
<p><code>Body</code> stores information about expressions.</p>
<p><strong>Architecture Invariant:</strong> these crates are not, and will never be, an api boundary.</p>
<p><strong>Architecture Invariant:</strong> these crates explicitly care about being incremental.
The core invariant we maintain is "typing inside a function's body never invalidates global derived data".
i.e., if you change the body of <code>foo</code>, all facts about <code>bar</code> should remain intact.</p>
<p><strong>Architecture Invariant:</strong> hir exists only in context of particular crate instance with specific CFG flags.
The same syntax may produce several instances of HIR if the crate participates in the crate graph more than once.</p>
<h3 id="crateshir"><a class="header" href="#crateshir"><code>crates/hir</code></a></h3>
<p>The top-level <code>hir</code> crate is an <strong>API Boundary</strong>.
If you think about "using rust-analyzer as a library", <code>hir</code> crate is most likely the façade you'll be talking to.</p>
<p>It wraps ECS-style internal API into a more OO-flavored API (with an extra <code>db</code> argument for each call).</p>
<p><strong>Architecture Invariant:</strong> <code>hir</code> provides a static, fully resolved view of the code.
While internal <code>hir-*</code> crates <em>compute</em> things, <code>hir</code>, from the outside, looks like an inert data structure.</p>
<p><code>hir</code> also handles the delicate task of going from syntax to the corresponding <code>hir</code>.
Remember that the mapping here is one-to-many.
See <code>Semantics</code> type and <code>source_to_def</code> module.</p>
<p>Note in particular a curious recursive structure in <code>source_to_def</code>.
We first resolve the parent <em>syntax</em> node to the parent <em>hir</em> element.
Then we ask the <em>hir</em> parent what <em>syntax</em> children does it have.
Then we look for our node in the set of children.</p>
<p>This is the heart of many IDE features, like goto definition, which start with figuring out the hir node at the cursor.
This is some kind of (yet unnamed) uber-IDE pattern, as it is present in Roslyn and Kotlin as well.</p>
<h3 id="crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><a class="header" href="#crateside-crateside-db-crateside-assists-crateside-completion-crateside-diagnostics-crateside-ssr"><code>crates/ide</code>, <code>crates/ide-db</code>, <code>crates/ide-assists</code>, <code>crates/ide-completion</code>, <code>crates/ide-diagnostics</code>, <code>crates/ide-ssr</code></a></h3>
<p>The <code>ide</code> crate builds on top of <code>hir</code> semantic model to provide high-level IDE features like completion or goto definition.
It is an <strong>API Boundary</strong>.
If you want to use IDE parts of rust-analyzer via LSP, custom flatbuffers-based protocol or just as a library in your text editor, this is the right API.</p>
<p><strong>Architecture Invariant:</strong> <code>ide</code> crate's API is build out of POD types with public fields.
The API uses editor's terminology, it talks about offsets and string labels rather than in terms of definitions or types.
It is effectively the view in MVC and viewmodel in <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVVM</a>.
All arguments and return types are conceptually serializable.
In particular, syntax trees and hir types are generally absent from the API (but are used heavily in the implementation).
Shout outs to LSP developers for popularizing the idea that "UI" is a good place to draw a boundary at.</p>
<p><code>ide</code> is also the first crate which has the notion of change over time.
<code>AnalysisHost</code> is a state to which you can transactionally <code>apply_change</code>.
<code>Analysis</code> is an immutable snapshot of the state.</p>
<p>Internally, <code>ide</code> is split across several crates. <code>ide-assists</code>, <code>ide-completion</code>, <code>ide-diagnostics</code> and <code>ide-ssr</code> implement large isolated features.
<code>ide-db</code> implements common IDE functionality (notably, reference search is implemented here).
The <code>ide</code> contains a public API/façade, as well as implementation for a plethora of smaller features.</p>
<p><strong>Architecture Invariant:</strong> <code>ide</code> crate strives to provide a <em>perfect</em> API.
Although at the moment it has only one consumer, the LSP server, LSP <em>does not</em> influence its API design.
Instead, we keep in mind a hypothetical <em>ideal</em> client -- an IDE tailored specifically for rust, every nook and cranny of which is packed with Rust-specific goodies.</p>
<h3 id="cratesrust-analyzer"><a class="header" href="#cratesrust-analyzer"><code>crates/rust-analyzer</code></a></h3>
<p>This crate defines the <code>rust-analyzer</code> binary, so it is the <strong>entry point</strong>.
It implements the language server.</p>
<p><strong>Architecture Invariant:</strong> <code>rust-analyzer</code> is the only crate that knows about LSP and JSON serialization.
If you want to expose a data structure <code>X</code> from ide to LSP, don't make it serializable.
Instead, create a serializable counterpart in <code>rust-analyzer</code> crate and manually convert between the two.</p>
<p><code>GlobalState</code> is the state of the server.
The <code>main_loop</code> defines the server event loop which accepts requests and sends responses.
Requests that modify the state or might block user's typing are handled on the main thread.
All other requests are processed in background.</p>
<p><strong>Architecture Invariant:</strong> the server is stateless, a-la HTTP.
Sometimes state needs to be preserved between requests.
For example, "what is the <code>edit</code> for the fifth completion item of the last completion edit?".
For this, the second request should include enough info to re-create the context from scratch.
This generally means including all the parameters of the original request.</p>
<p><code>reload</code> module contains the code that handles configuration and Cargo.toml changes.
This is a tricky business.</p>
<p><strong>Architecture Invariant:</strong> <code>rust-analyzer</code> should be partially available even when the build is broken.
Reloading process should not prevent IDE features from working.</p>
<h3 id="cratestoolchain-cratesproject-model-cratesflycheck"><a class="header" href="#cratestoolchain-cratesproject-model-cratesflycheck"><code>crates/toolchain</code>, <code>crates/project-model</code>, <code>crates/flycheck</code></a></h3>
<p>These crates deal with invoking <code>cargo</code> to learn about project structure and get compiler errors for the "check on save" feature.</p>
<p>They use <code>crates/paths</code> heavily instead of <code>std::path</code>.
A single <code>rust-analyzer</code> process can serve many projects, so it is important that server's current directory does not leak.</p>
<h3 id="cratesmbe-cratestt-cratesproc-macro-api-cratesproc-macro-srv-cratesproc-macro-srv-cli"><a class="header" href="#cratesmbe-cratestt-cratesproc-macro-api-cratesproc-macro-srv-cratesproc-macro-srv-cli"><code>crates/mbe</code>, <code>crates/tt</code>, <code>crates/proc-macro-api</code>, <code>crates/proc-macro-srv</code>, <code>crates/proc-macro-srv-cli</code></a></h3>
<p>These crates implement macros as token tree -&gt; token tree transforms.
They are independent from the rest of the code.</p>
<p><code>tt</code> crate defined <code>TokenTree</code>, a single token or a delimited sequence of token trees.
<code>mbe</code> crate contains tools for transforming between syntax trees and token tree.
And it also handles the actual parsing and expansion of declarative macro (a-la "Macros By Example" or mbe).</p>
<p>For proc macros, the client-server model are used.
We start a separate process  (<code>proc-macro-srv-cli</code>) which loads and runs the proc-macros for us.
And the client (<code>proc-macro-api</code>) provides an interface to talk to that server separately.</p>
<p>And then token trees are passed from client, and the server will load the corresponding dynamic library (which built by <code>cargo</code>).
And due to the fact the api for getting result from proc macro are always unstable in <code>rustc</code>,
we maintain our own copy (and paste) of that part of code to allow us to build the whole thing in stable rust.</p>
<p><strong>Architecture Invariant:</strong>
Bad proc macros may panic or segfault accidentally. So we run it in another process and recover it from fatal error.
And they may be non-deterministic which conflict how <code>salsa</code> works, so special attention is required.</p>
<h3 id="cratescfg"><a class="header" href="#cratescfg"><code>crates/cfg</code></a></h3>
<p>This crate is responsible for parsing, evaluation and general definition of <code>cfg</code> attributes.</p>
<h3 id="cratesvfs-cratesvfs-notify-cratespaths"><a class="header" href="#cratesvfs-cratesvfs-notify-cratespaths"><code>crates/vfs</code>, <code>crates/vfs-notify</code>, <code>crates/paths</code></a></h3>
<p>These crates implement a virtual file system.
They provide consistent snapshots of the underlying file system and insulate messy OS paths.</p>
<p><strong>Architecture Invariant:</strong> vfs doesn't assume a single unified file system.
i.e., a single rust-analyzer process can act as a remote server for two different machines, where the same <code>/tmp/foo.rs</code> path points to different files.
For this reason, all path APIs generally take some existing path as a "file system witness".</p>
<h3 id="cratesstdx"><a class="header" href="#cratesstdx"><code>crates/stdx</code></a></h3>
<p>This crate contains various non-rust-analyzer specific utils, which could have been in std, as well
as copies of unstable std items we would like to make use of already.</p>
<h3 id="cratesprofile"><a class="header" href="#cratesprofile"><code>crates/profile</code></a></h3>
<p>This crate contains utilities for CPU and memory profiling.</p>
<h3 id="cratesintern"><a class="header" href="#cratesintern"><code>crates/intern</code></a></h3>
<p>This crate contains infrastructure for globally interning things via <code>Arc</code>.</p>
<h3 id="cratesload-cargo"><a class="header" href="#cratesload-cargo"><code>crates/load-cargo</code></a></h3>
<p>This crate exposes several utilities for loading projects, used by the main <code>rust-analyzer</code> crate
and other downstream consumers.</p>
<h3 id="cratesrustc-dependencies"><a class="header" href="#cratesrustc-dependencies"><code>crates/rustc-dependencies</code></a></h3>
<p>This crate wraps the <code>rustc_*</code> crates rust-analyzer relies on and conditionally points them to
mirrored crates-io releases such that rust-analyzer keeps building on stable.</p>
<h3 id="cratesspan"><a class="header" href="#cratesspan"><code>crates/span</code></a></h3>
<p>This crate exposes types and functions related to rust-analyzer's span for macros.</p>
<p>A span is effectively a text range relative to some item in a file with a given <code>SyntaxContext</code> (hygiene).</p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-Cutting Concerns</a></h2>
<p>This sections talks about the things which are everywhere and nowhere in particular.</p>
<h3 id="stability-guarantees"><a class="header" href="#stability-guarantees">Stability Guarantees</a></h3>
<p>One of the reasons rust-analyzer moves relatively fast is that we don't introduce new stability guarantees.
Instead, as much as possible we leverage existing ones.</p>
<p>Examples:</p>
<ul>
<li>The <code>ide</code> API of rust-analyzer are explicitly unstable, but the LSP interface is stable, and here we just implement a stable API managed by someone else.</li>
<li>Rust language and Cargo are stable, and they are the primary inputs to rust-analyzer.</li>
<li>The <code>rowan</code> library is published to crates.io, but it is deliberately kept under <code>1.0</code> and always makes semver-incompatible upgrades</li>
</ul>
<p>Another important example is that rust-analyzer isn't run on CI, so, unlike <code>rustc</code> and <code>clippy</code>, it is actually ok for us to change runtime behavior.</p>
<p>At some point we might consider opening up APIs or allowing crates.io libraries to include rust-analyzer specific annotations, but that's going to be a big commitment on our side.</p>
<p>Exceptions:</p>
<ul>
<li><code>rust-project.json</code> is a de-facto stable format for non-cargo build systems.
It is probably ok enough, but was definitely stabilized implicitly.
Lesson for the future: when designing API which could become a stability boundary, don't wait for the first users until you stabilize it.
By the time you have first users, it is already de-facto stable.
And the users will first use the thing, and <em>then</em> inform you that now you have users.
The sad thing is that stuff should be stable before someone uses it for the first time, or it should contain explicit opt-in.</li>
<li>We ship some LSP extensions, and we try to keep those somewhat stable.
Here, we need to work with a finite set of editor maintainers, so not providing rock-solid guarantees works.</li>
</ul>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<p>Some components in this repository are generated through automatic processes.
Generated code is updated automatically on <code>cargo test</code>.
Generated code is generally committed to the git repository.</p>
<p>In particular, we generate:</p>
<ul>
<li>
<p>API for working with syntax trees (<code>syntax::ast</code>, the <a href="https://github.com/rust-analyzer/ungrammar"><code>ungrammar</code></a> crate).</p>
</li>
<li>
<p>Various sections of the manual:</p>
<ul>
<li>features</li>
<li>assists</li>
<li>config</li>
</ul>
</li>
<li>
<p>Documentation tests for assists</p>
</li>
</ul>
<p>See the <code>xtask\src\codegen\assists_doc_tests.rs</code> module for details.</p>
<p><strong>Architecture Invariant:</strong> we avoid bootstrapping.
For codegen we need to parse Rust code.
Using rust-analyzer for that would work and would be fun, but it would also complicate the build process a lot.
For that reason, we use syn and manual string parsing.</p>
<h3 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h3>
<p>Let's say that the IDE is in the process of computing syntax highlighting, when the user types <code>foo</code>.
What should happen?
<code>rust-analyzer</code>s answer is that the highlighting process should be cancelled -- its results are now stale, and it also blocks modification of the inputs.</p>
<p>The salsa database maintains a global revision counter.
When applying a change, salsa bumps this counter and waits until all other threads using salsa finish.
If a thread does salsa-based computation and notices that the counter is incremented, it panics with a special value (see <code>Canceled::throw</code>).
That is, rust-analyzer requires unwinding.</p>
<p><code>ide</code> is the boundary where the panic is caught and transformed into a <code>Result&lt;T, Cancelled&gt;</code>.</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>rust-analyzer has three interesting <a href="https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html">system boundaries</a> to concentrate tests on.</p>
<p>The outermost boundary is the <code>rust-analyzer</code> crate, which defines an LSP interface in terms of stdio.
We do integration testing of this component, by feeding it with a stream of LSP requests and checking responses.
These tests are known as "heavy", because they interact with Cargo and read real files from disk.
For this reason, we try to avoid writing too many tests on this boundary: in a statically typed language, it's hard to make an error in the protocol itself if messages are themselves typed.
Heavy tests are only run when <code>RUN_SLOW_TESTS</code> env var is set.</p>
<p>The middle, and most important, boundary is <code>ide</code>.
Unlike <code>rust-analyzer</code>, which exposes API, <code>ide</code> uses Rust API and is intended for use by various tools.
A typical test creates an <code>AnalysisHost</code>, calls some <code>Analysis</code> functions and compares the results against expectation.</p>
<p>The innermost and most elaborate boundary is <code>hir</code>.
It has a much richer vocabulary of types than <code>ide</code>, but the basic testing setup is the same: we create a database, run some queries, assert result.</p>
<p>For comparisons, we use the <code>expect</code> crate for snapshot testing.</p>
<p>To test various analysis corner cases and avoid forgetting about old tests, we use so-called marks.
See the <a href="https://docs.rs/cov-mark/latest/cov_mark/">cov_mark</a> crate documentation for more.</p>
<p><strong>Architecture Invariant:</strong> rust-analyzer tests do not use libcore or libstd.
All required library code must be a part of the tests.
This ensures fast test execution.</p>
<p><strong>Architecture Invariant:</strong> tests are data driven and do not test the API.
Tests which directly call various API functions are a liability, because they make refactoring the API significantly more complicated.
So most of the tests look like this:</p>
<pre><code class="language-rust">#[track_caller]
fn check(input: &amp;str, expect: expect_test::Expect) {
    // The single place that actually exercises a particular API
}

#[test]
fn foo() {
    check("foo", expect![["bar"]]);
}

#[test]
fn spam() {
    check("spam", expect![["eggs"]]);
}
// ...and a hundred more tests that don't care about the specific API at all.</code></pre>
<p>To specify input data, we use a single string literal in a special format, which can describe a set of rust files.
See the <code>Fixture</code> its module for fixture examples and documentation.</p>
<p><strong>Architecture Invariant:</strong> all code invariants are tested by <code>#[test]</code> tests.
There's no additional checks in CI, formatting and tidy tests are run with <code>cargo test</code>.</p>
<p><strong>Architecture Invariant:</strong> tests do not depend on any kind of external resources, they are perfectly reproducible.</p>
<h3 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h3>
<p>TBA, take a look at the <code>metrics</code> xtask and <code>#[test] fn benchmark_xxx()</code> functions.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p><strong>Architecture Invariant:</strong> core parts of rust-analyzer (<code>ide</code>/<code>hir</code>) don't interact with the outside world and thus can't fail.
Only parts touching LSP are allowed to do IO.</p>
<p>Internals of rust-analyzer need to deal with broken code, but this is not an error condition.
rust-analyzer is robust: various analysis compute <code>(T, Vec&lt;Error&gt;)</code> rather than <code>Result&lt;T, Error&gt;</code>.</p>
<p>rust-analyzer is a complex long-running process.
It will always have bugs and panics.
But a panic in an isolated feature should not bring down the whole process.
Each LSP-request is protected by a <code>catch_unwind</code>.
We use <code>always</code> and <code>never</code> macros instead of <code>assert</code> to gracefully recover from impossible conditions.</p>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<p>rust-analyzer is a long-running process, so it is important to understand what's going on inside.
We have several instruments for that.</p>
<p>The event loop that runs rust-analyzer is very explicit.
Rather than spawning futures or scheduling callbacks (open), the event loop accepts an <code>enum</code> of possible events (closed).
It's easy to see all the things that trigger rust-analyzer processing, together with their performance</p>
<p>rust-analyzer includes a simple hierarchical profiler (<code>hprof</code>).
It is enabled with <code>RA_PROFILE='*&gt;50'</code> env var (log all (<code>*</code>) actions which take more than <code>50</code> ms) and produces output like:</p>
<pre><code>85ms - handle_completion
    68ms - import_on_the_fly
        67ms - import_assets::search_for_relative_paths
             0ms - crate_def_map:wait (804 calls)
             0ms - find_path (16 calls)
             2ms - find_similar_imports (1 calls)
             0ms - generic_params_query (334 calls)
            59ms - trait_solve_query (186 calls)
         0ms - Semantics::analyze_impl (1 calls)
         1ms - render_resolution (8 calls)
     0ms - Semantics::analyze_impl (5 calls)
</code></pre>
<p>This is cheap enough to enable in production.</p>
<p>Similarly, we save live object counting (<code>RA_COUNT=1</code>).
It is not cheap enough to enable in prod, and this is a bug which should be fixed.</p>
<h3 id="configurability"><a class="header" href="#configurability">Configurability</a></h3>
<p>rust-analyzer strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.
The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.
There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.
Enabling them by default is a matter of discoverability, as many users don't know about some features even though they are presented in the manual.
Mind the code--architecture gap: at the moment, we are using fewer feature flags than we really should.</p>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<p>In Rust, it is easy (often too easy) to add serialization to any type by adding <code>#[derive(Serialize)]</code>.
This easiness is misleading -- serializable types impose significant backwards compatibility constraints.
If a type is serializable, then it is a part of some IPC boundary.
You often don't control the other side of this boundary, so changing serializable types is hard.</p>
<p>For this reason, the types in <code>ide</code>, <code>base_db</code> and below are not serializable by design.
If such types need to cross an IPC boundary, then the client of rust-analyzer needs to provide a custom, client-specific serialization format.
This isolates backwards compatibility and migration concerns to a specific client.</p>
<p>For example, <code>rust-project.json</code> is its own format -- it doesn't include <code>CrateGraph</code> as is.
Instead, it creates a <code>CrateGraph</code> by calling appropriate constructing functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-vscode-plugin-and-the-language-server"><a class="header" href="#debugging-vscode-plugin-and-the-language-server">Debugging VSCode plugin and the language server</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>
<p>Install <a href="https://lldb.llvm.org/">LLDB</a> and the <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">LLDB Extension</a>.</p>
</li>
<li>
<p>Open the root folder in VSCode. Here you can access the preconfigured debug setups.</p>
<img height=150px src="https://user-images.githubusercontent.com/36276403/74611090-92ec5380-5101-11ea-8a41-598f51f3f3e3.png" alt="Debug options view">
</li>
<li>
<p>Install all TypeScript dependencies</p>
<pre><code class="language-bash">cd editors/code
npm ci
</code></pre>
</li>
</ul>
<h2 id="common-knowledge"><a class="header" href="#common-knowledge">Common knowledge</a></h2>
<ul>
<li>All debug configurations open a new <code>[Extension Development Host]</code> VSCode instance
where <strong>only</strong> the <code>rust-analyzer</code> extension being debugged is enabled.</li>
<li>To activate the extension you need to open any Rust project folder in <code>[Extension Development Host]</code>.</li>
</ul>
<h2 id="debug-typescript-vscode-extension"><a class="header" href="#debug-typescript-vscode-extension">Debug TypeScript VSCode extension</a></h2>
<ul>
<li><code>Run Installed Extension</code> - runs the extension with the globally installed <code>rust-analyzer</code> binary.</li>
<li><code>Run Extension (Debug Build)</code> - runs extension with the locally built LSP server (<code>target/debug/rust-analyzer</code>).</li>
</ul>
<p>TypeScript debugging is configured to watch your source edits and recompile.
To apply changes to an already running debug process, press <kbd>Ctrl+Shift+P</kbd> and run the following command in your <code>[Extension Development Host]</code></p>
<pre><code>&gt; Developer: Reload Window
</code></pre>
<h2 id="debug-rust-lsp-server"><a class="header" href="#debug-rust-lsp-server">Debug Rust LSP server</a></h2>
<ul>
<li>
<p>When attaching a debugger to an already running <code>rust-analyzer</code> server on Linux you might need to enable <code>ptrace</code> for unrelated processes by running:</p>
<pre><code class="language-bash">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
</code></pre>
</li>
<li>
<p>By default, the LSP server is built without debug information. To enable it, you'll need to change <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">  [profile.dev]
  debug = 2
</code></pre>
</li>
<li>
<p>Select <code>Run Extension (Debug Build)</code> to run your locally built <code>target/debug/rust-analyzer</code>.</p>
</li>
<li>
<p>In the original VSCode window once again select the <code>Attach To Server</code> debug configuration.</p>
</li>
<li>
<p>A list of running processes should appear. Select the <code>rust-analyzer</code> from this repo.</p>
</li>
<li>
<p>Navigate to <code>crates/rust-analyzer/src/main_loop.rs</code> and add a breakpoint to the <code>on_request</code> function.</p>
</li>
<li>
<p>Go back to the <code>[Extension Development Host]</code> instance and hover over a Rust variable and your breakpoint should hit.</p>
</li>
</ul>
<p>If you need to debug the server from the very beginning, including its initialization code, you can use the <code>--wait-dbg</code> command line argument or <code>RA_WAIT_DBG</code> environment variable. The server will spin at the beginning of the <code>try_main</code> function (see <code>crates\rust-analyzer\src\bin\main.rs</code>)</p>
<pre><code class="language-rust">    let mut d = 4;
    while d == 4 { // set a breakpoint here and change the value
        d = 4;
    }</code></pre>
<p>However for this to work, you will need to enable debug_assertions in your build</p>
<pre><code class="language-rust">RUSTFLAGS='--cfg debug_assertions' cargo build --release</code></pre>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=T-hvpK6s4wM">Debugging TypeScript VScode extension</a>.</li>
<li><a href="https://www.youtube.com/watch?v=EaNb5rg4E0M">Debugging Rust LSP server</a>.</li>
</ul>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="cant-find-the-rust-analyzer-process"><a class="header" href="#cant-find-the-rust-analyzer-process">Can't find the <code>rust-analyzer</code> process</a></h3>
<p>It could be a case of just jumping the gun.</p>
<p>The <code>rust-analyzer</code> is only started once the <code>onLanguage:rust</code> activation.</p>
<p>Make sure you open a rust file in the <code>[Extension Development Host]</code> and try again.</p>
<h3 id="cant-connect-to-rust-analyzer"><a class="header" href="#cant-connect-to-rust-analyzer">Can't connect to <code>rust-analyzer</code></a></h3>
<p>Make sure you have run <code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code>.</p>
<p>By default this should reset back to 1 every time you log in.</p>
<h3 id="breakpoints-are-never-being-hit"><a class="header" href="#breakpoints-are-never-being-hit">Breakpoints are never being hit</a></h3>
<p>Check your version of <code>lldb</code>. If it's version 6 and lower, use the <code>classic</code> adapter type.
It's <code>lldb.adapterType</code> in settings file.</p>
<p>If you're running <code>lldb</code> version 7, change the lldb adapter type to <code>bundled</code> or <code>native</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-rust-analyzer"><a class="header" href="#guide-to-rust-analyzer">Guide to rust-analyzer</a></h1>
<h2 id="about-the-guide"><a class="header" href="#about-the-guide">About the guide</a></h2>
<p>This guide describes the current state of rust-analyzer as of the 2024-01-01 release
(git tag <a href="https://github.com/rust-lang/rust-analyzer/tree/2024-01-01">2024-01-01</a>). Its purpose is to document various problems and
architectural solutions related to the problem of building IDE-first compiler
for Rust. There is a video version of this guide as well -
however, it's based on an older 2019-01-20 release (git tag <a href="https://github.com/rust-lang/rust-analyzer/tree/guide-2019-01">guide-2019-01</a>):
https://youtu.be/ANKBNiSWyfc.</p>
<ul>
<li><a href="contributing/guide.html#the-big-picture">The big picture</a></li>
<li><a href="contributing/guide.html#ide-api">IDE API</a></li>
<li><a href="contributing/guide.html#inputs">Inputs</a></li>
<li><a href="contributing/guide.html#source-roots-aka-filesystems-are-horrible">Source roots (a.k.a. "Filesystems are horrible")</a></li>
<li><a href="contributing/guide.html#language-server-protocol">Language Server Protocol</a></li>
<li><a href="contributing/guide.html#salsa">Salsa</a></li>
<li><a href="contributing/guide.html#salsa-input-queries">Salsa Input Queries</a></li>
<li><a href="contributing/guide.html#from-text-to-semantic-model">From text to semantic model</a></li>
<li><a href="contributing/guide.html#syntax-trees">Syntax trees</a></li>
<li><a href="contributing/guide.html#building-a-module-tree">Building a Module Tree</a></li>
<li><a href="contributing/guide.html#location-interner-pattern">Location Interner pattern</a></li>
<li><a href="contributing/guide.html#macros-and-recursive-locations">Macros and recursive locations</a></li>
<li><a href="contributing/guide.html#name-resolution">Name resolution</a></li>
<li><a href="contributing/guide.html#source-map-pattern">Source Map pattern</a></li>
<li><a href="contributing/guide.html#type-inference">Type inference</a></li>
<li><a href="contributing/guide.html#tying-it-all-together-completion">Tying it all together: completion</a></li>
</ul>
<h2 id="the-big-picture"><a class="header" href="#the-big-picture">The big picture</a></h2>
<p>On the highest possible level, rust-analyzer is a stateful component. A client may
apply changes to the analyzer (new contents of <code>foo.rs</code> file is "fn main() {}")
and it may ask semantic questions about the current state (what is the
definition of the identifier with offset 92 in file <code>bar.rs</code>?). Two important
properties hold:</p>
<ul>
<li>
<p>Analyzer does not do any I/O. It starts in an empty state and all input data is
provided via <code>apply_change</code> API.</p>
</li>
<li>
<p>Only queries about the current state are supported. One can, of course,
simulate undo and redo by keeping a log of changes and inverse changes respectively.</p>
</li>
</ul>
<h2 id="ide-api"><a class="header" href="#ide-api">IDE API</a></h2>
<p>To see the bigger picture of how the IDE features work, let's take a look at the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide/src/lib.rs#L161-L213"><code>AnalysisHost</code></a> and
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide/src/lib.rs#L220-L761"><code>Analysis</code></a> pair of types. <code>AnalysisHost</code> has three methods:</p>
<ul>
<li><code>default()</code> for creating an empty analysis instance</li>
<li><code>apply_change(&amp;mut self)</code> to make changes (this is how you get from an empty
state to something interesting)</li>
<li><code>analysis(&amp;self)</code> to get an instance of <code>Analysis</code></li>
</ul>
<p><code>Analysis</code> has a ton of methods for IDEs, like <code>goto_definition</code>, or
<code>completions</code>. Both inputs and outputs of <code>Analysis</code>' methods are formulated in
terms of files and offsets, and <strong>not</strong> in terms of Rust concepts like structs,
traits, etc. The "typed" API with Rust specific types is slightly lower in the
stack, we'll talk about it later.</p>
<p>The reason for this separation of <code>Analysis</code> and <code>AnalysisHost</code> is that we want to apply
changes "uniquely", but we might also want to fork an <code>Analysis</code> and send it to
another thread for background processing. That is, there is only a single
<code>AnalysisHost</code>, but there may be several (equivalent) <code>Analysis</code>.</p>
<p>Note that all of the <code>Analysis</code> API return <code>Cancellable&lt;T&gt;</code>. This is required to
be responsive in an IDE setting. Sometimes a long-running query is being computed
and the user types something in the editor and asks for completion. In this
case, we cancel the long-running computation (so it returns <code>Err(Cancelled)</code>),
apply the change and execute request for completion. We never use stale data to
answer requests. Under the cover, <code>AnalysisHost</code> "remembers" all outstanding
<code>Analysis</code> instances. The <code>AnalysisHost::apply_change</code> method cancels all
<code>Analysis</code>es, blocks until all of them are <code>Dropped</code> and then applies changes
in-place. This may be familiar to Rustaceans who use read-write locks for interior
mutability.</p>
<p>Next, let's talk about what the inputs to the <code>Analysis</code> are, precisely.</p>
<h2 id="inputs"><a class="header" href="#inputs">Inputs</a></h2>
<p>rust-analyzer never does any I/O itself, all inputs get passed explicitly via
the <code>AnalysisHost::apply_change</code> method, which accepts a single argument, a
<code>Change</code>. <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/change.rs#L10-L42"><code>Change</code></a> is a wrapper for <code>FileChange</code> that adds proc-macro knowledge.
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/base-db/src/change.rs#L14-L78"><code>FileChange</code></a> is a builder for a single change "transaction", so it suffices
to study its methods to understand all the input data.</p>
<p>The <code>change_file</code> method controls the set of the input files, where each file
has an integer id (<code>FileId</code>, picked by the client) and text (<code>Option&lt;Arc&lt;str&gt;&gt;</code>).
Paths are tricky; they'll be explained below, in source roots section,
together with the <code>set_roots</code> method. The "source root" <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/base-db/src/input.rs#L38"><code>is_library</code></a> flag
along with the concept of <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/base-db/src/change.rs#L80-L86"><code>durability</code></a> allows us to add a group of files which
are assumed to rarely change. It's mostly an optimization and does not change
the fundamental picture.</p>
<p>The <code>set_crate_graph</code> method allows us to control how the input files are partitioned
into compilation units -- crates. It also controls (in theory, not implemented
yet) <code>cfg</code> flags. <code>CrateGraph</code> is a directed acyclic graph of crates. Each crate
has a root <code>FileId</code>, a set of active <code>cfg</code> flags and a set of dependencies. Each
dependency is a pair of a crate and a name. It is possible to have two crates
with the same root <code>FileId</code> but different <code>cfg</code>-flags/dependencies. This model
is lower than Cargo's model of packages: each Cargo package consists of several
targets, each of which is a separate crate (or several crates, if you try
different feature combinations).</p>
<p>Procedural macros are inputs as well, roughly modeled as a crate with a bunch of
additional black box <code>dyn Fn(TokenStream) -&gt; TokenStream</code> functions.</p>
<p>Soon we'll talk how we build an LSP server on top of <code>Analysis</code>, but first,
let's deal with that paths issue.</p>
<h2 id="source-roots-aka-filesystems-are-horrible"><a class="header" href="#source-roots-aka-filesystems-are-horrible">Source roots (a.k.a. "Filesystems are horrible")</a></h2>
<p>This is a non-essential section, feel free to skip.</p>
<p>The previous section said that the filesystem path is an attribute of a file,
but this is not the whole truth. Making it an absolute <code>PathBuf</code> will be bad for
several reasons. First, filesystems are full of (platform-dependent) edge cases:</p>
<ul>
<li>It's hard (requires a syscall) to decide if two paths are equivalent.</li>
<li>Some filesystems are case-sensitive (e.g. macOS).</li>
<li>Paths are not necessarily UTF-8.</li>
<li>Symlinks can form cycles.</li>
</ul>
<p>Second, this might hurt the reproducibility and hermeticity of builds. In theory,
moving a project from <code>/foo/bar/my-project</code> to <code>/spam/eggs/my-project</code> should
not change a bit in the output. However, if the absolute path is a part of the
input, it is at least in theory observable, and <em>could</em> affect the output.</p>
<p>Yet another problem is that we really <em>really</em> want to avoid doing I/O, but with
Rust the set of "input" files is not necessarily known up-front. In theory, you
can have <code>#[path="/dev/random"] mod foo;</code>.</p>
<p>To solve (or explicitly refuse to solve) these problems rust-analyzer uses the
concept of a "source root". Roughly speaking, source roots are the contents of a
directory on a file system, like <code>/home/matklad/projects/rustraytracer/**.rs</code>.</p>
<p>More precisely, all files (<code>FileId</code>s) are partitioned into disjoint
<code>SourceRoot</code>s. Each file has a relative UTF-8 path within the <code>SourceRoot</code>.
<code>SourceRoot</code> has an identity (integer ID). Crucially, the root path of the
source root itself is unknown to the analyzer: A client is supposed to maintain a
mapping between <code>SourceRoot</code> IDs (which are assigned by the client) and actual
<code>PathBuf</code>s. <code>SourceRoot</code>s give a sane tree model of the file system to the
analyzer.</p>
<p>Note that <code>mod</code>, <code>#[path]</code> and <code>include!()</code> can only reference files from the
same source root. It is of course possible to explicitly add extra files to
the source root, even <code>/dev/random</code>.</p>
<h2 id="language-server-protocol"><a class="header" href="#language-server-protocol">Language Server Protocol</a></h2>
<p>Now let's see how the <code>Analysis</code> API is exposed via the JSON RPC based language server protocol.
The hard part here is managing changes (which can come either from the file system
or from the editor) and concurrency (we want to spawn background jobs for things
like syntax highlighting). We use the event loop pattern to manage the zoo, and
the loop is the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L114-L140"><code>GlobalState::run</code></a> function initiated by <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L31-L54"><code>main_loop</code></a> after
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/global_state.rs#L148-L215"><code>GlobalState::new</code></a> does a one-time initialization and tearing down of the resources.</p>
<p>Let's walk through a typical analyzer session!</p>
<p>First, we need to figure out what to analyze. To do this, we run <code>cargo metadata</code> to learn about Cargo packages for current workspace and dependencies,
and we run <code>rustc --print sysroot</code> and scan the "sysroot"
(the directory containing the current Rust toolchain's files) to learn about crates
like <code>std</code>. This happens in the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/reload.rs#L186-L257"><code>GlobalState::fetch_workspaces</code></a> method.
We load this configuration at the start of the server in <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/global_state.rs#L148-L215"><code>GlobalState::new</code></a>,
but it's also triggered by workspace change events and requests to reload the
workspace from the client.</p>
<p>The <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/project-model/src/workspace.rs#L57-L100"><code>ProjectModel</code></a> we get after this step is very Cargo and sysroot specific,
it needs to be lowered to get the input in the form of <code>Change</code>. This happens
in <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/global_state.rs#L217-L356"><code>GlobalState::process_changes</code></a> method. Specifically</p>
<ul>
<li>Create <code>SourceRoot</code>s for each Cargo package(s) and sysroot.</li>
<li>Schedule a filesystem scan of the roots.</li>
<li>Create an analyzer's <code>Crate</code> for each Cargo <strong>target</strong> and sysroot crate.</li>
<li>Setup dependencies between the crates.</li>
</ul>
<p>The results of the scan (which may take a while) will be processed in the body
of the main loop, just like any other change. Here's where we handle:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L273">File system changes</a></li>
<li><a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L801-L803">Changes from the editor</a></li>
</ul>
<p>After a single loop's turn, we group the changes into one <code>Change</code> and
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/global_state.rs#L333">apply</a> it. This always happens on the main thread and blocks the loop.</p>
<p>To handle requests, like <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L767">"goto definition"</a>, we create an instance of the
<code>Analysis</code> and <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/dispatch.rs#L138"><code>schedule</code></a> the task (which consumes <code>Analysis</code>) on the
threadpool. <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/handlers/request.rs#L610-L623">The task</a> calls the corresponding <code>Analysis</code> method, while
massaging the types into the LSP representation. Keep in mind that if we are
executing "goto definition" on the threadpool and a new change comes in, the
task will be canceled as soon as the main loop calls <code>apply_change</code> on the
<code>AnalysisHost</code>.</p>
<p>This concludes the overview of the analyzer's programing <em>interface</em>. Next, let's
dig into the implementation!</p>
<h2 id="salsa"><a class="header" href="#salsa">Salsa</a></h2>
<p>The most straightforward way to implement an "apply change, get analysis, repeat"
API would be to maintain the input state and to compute all possible analysis
information from scratch after every change. This works, but scales poorly with
the size of the project. To make this fast, we need to take advantage of the
fact that most of the changes are small, and that analysis results are unlikely
to change significantly between invocations.</p>
<p>To do this we use <a href="https://github.com/salsa-rs/salsa">salsa</a>: a framework for incremental on-demand computation.
You can skip the rest of the section if you are familiar with <code>rustc</code>'s red-green
algorithm (which is used for incremental compilation).</p>
<p>It's better to refer to salsa's docs to learn about it. Here's a small excerpt:</p>
<p>The key idea of salsa is that you define your program as a set of queries. Every
query is used like a function <code>K -&gt; V</code> that maps from some key of type <code>K</code> to a value
of type <code>V</code>. Queries come in two basic varieties:</p>
<ul>
<li>
<p><strong>Inputs</strong>: the base inputs to your system. You can change these whenever you
like.</p>
</li>
<li>
<p><strong>Functions</strong>: pure functions (no side effects) that transform your inputs
into other values. The results of queries are memoized to avoid recomputing
them a lot. When you make changes to the inputs, we'll figure out (fairly
intelligently) when we can re-use these memoized values and when we have to
recompute them.</p>
</li>
</ul>
<p>For further discussion, it's important to understand one bit of "fairly
intelligently". Suppose we have two functions, <code>f1</code> and <code>f2</code>, and one input,
<code>z</code>. We call <code>f1(X)</code> which in turn calls <code>f2(Y)</code> which inspects <code>i(Z)</code>. <code>i(Z)</code>
returns some value <code>V1</code>, <code>f2</code> uses that and returns <code>R1</code>, <code>f1</code> uses that and
returns <code>O</code>. Now, let's change <code>i</code> at <code>Z</code> to <code>V2</code> from <code>V1</code> and try to compute
<code>f1(X)</code> again. Because <code>f1(X)</code> (transitively) depends on <code>i(Z)</code>, we can't just
reuse its value as is. However, if <code>f2(Y)</code> is <em>still</em> equal to <code>R1</code> (despite
<code>i</code>'s change), we, in fact, <em>can</em> reuse <code>O</code> as result of <code>f1(X)</code>. And that's how
salsa works: it recomputes results in <em>reverse</em> order, starting from inputs and
progressing towards outputs, stopping as soon as it sees an intermediate value
that hasn't changed. If this sounds confusing to you, don't worry: it is
confusing. This illustration by @killercup might help:</p>
<img alt="step 1" src="https://user-images.githubusercontent.com/1711539/51460907-c5484780-1d6d-11e9-9cd2-d6f62bd746e0.png" width="50%">
<img alt="step 2" src="https://user-images.githubusercontent.com/1711539/51460915-c9746500-1d6d-11e9-9a77-27d33a0c51b5.png" width="50%">
<img alt="step 3" src="https://user-images.githubusercontent.com/1711539/51460920-cda08280-1d6d-11e9-8d96-a782aa57a4d4.png" width="50%">
<img alt="step 4" src="https://user-images.githubusercontent.com/1711539/51460927-d1340980-1d6d-11e9-851e-13c149d5c406.png" width="50%">
<h2 id="salsa-input-queries"><a class="header" href="#salsa-input-queries">Salsa Input Queries</a></h2>
<p>All analyzer information is stored in a salsa database. <code>Analysis</code> and
<code>AnalysisHost</code> types are essentially newtype wrappers for <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-db/src/lib.rs#L69-L324"><code>RootDatabase</code></a>
-- a salsa database.</p>
<p>Salsa input queries are defined in <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/base-db/src/lib.rs#L58-L65"><code>SourceDatabase</code></a> and <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/base-db/src/lib.rs#L76-L88"><code>SourceDatabaseExt</code></a>
(which are a part of <code>RootDatabase</code>). They closely mirror the familiar <code>Change</code>
structure: indeed, what <code>apply_change</code> does is it sets the values of input queries.</p>
<h2 id="from-text-to-semantic-model"><a class="header" href="#from-text-to-semantic-model">From text to semantic model</a></h2>
<p>The bulk of the rust-analyzer is transforming input text into a semantic model of
Rust code: a web of entities like modules, structs, functions and traits.</p>
<p>An important fact to realize is that (unlike most other languages like C# or
Java) there is not a one-to-one mapping between the source code and the semantic model. A
single function definition in the source code might result in several semantic
functions: for example, the same source file might get included as a module in
several crates or a single crate might be present in the compilation DAG
several times, with different sets of <code>cfg</code>s enabled. The IDE-specific task of
mapping source code into a semantic model is inherently imprecise for
this reason and gets handled by the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir/src/source_analyzer.rs"><code>source_analyzer</code></a>.</p>
<p>The semantic interface is declared in the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir/src/semantics.rs"><code>semantics</code></a> module. Each entity is
identified by an integer ID and has a bunch of methods which take a salsa database
as an argument and returns other entities (which are also IDs). Internally, these
methods invoke various queries on the database to build the model on demand.
Here's <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-ty/src/db.rs#L29-L275">the list of queries</a>.</p>
<p>The first step of building the model is parsing the source code.</p>
<h2 id="syntax-trees"><a class="header" href="#syntax-trees">Syntax trees</a></h2>
<p>An important property of the Rust language is that each file can be parsed in
isolation. Unlike, say, <code>C++</code>, an <code>include</code> can't change the meaning of the
syntax. For this reason, rust-analyzer can build a syntax tree for each "source
file", which could then be reused by several semantic models if this file
happens to be a part of several crates.</p>
<p>The representation of syntax trees that rust-analyzer uses is similar to that of <code>Roslyn</code>
and Swift's new <a href="https://github.com/apple/swift/tree/5e2c815edfd758f9b1309ce07bfc01c4bc20ec23/lib/Syntax">libsyntax</a>. Swift's docs give an excellent overview of the
approach, so I skip this part here and instead outline the main characteristics
of the syntax trees:</p>
<ul>
<li>
<p>Syntax trees are fully lossless. Converting <strong>any</strong> text to a syntax tree and
back is a total identity function. All whitespace and comments are explicitly
represented in the tree.</p>
</li>
<li>
<p>Syntax nodes have generic <code>(next|previous)_sibling</code>, <code>parent</code>,
<code>(first|last)_child</code> functions. You can get from any one node to any other
node in the file using only these functions.</p>
</li>
<li>
<p>Syntax nodes know their range (start offset and length) in the file.</p>
</li>
<li>
<p>Syntax nodes share the ownership of their syntax tree: if you keep a reference
to a single function, the whole enclosing file is alive.</p>
</li>
<li>
<p>Syntax trees are immutable and the cost of replacing the subtree is
proportional to the depth of the subtree. Read Swift's docs to learn how
immutable + parent pointers + cheap modification is possible.</p>
</li>
<li>
<p>Syntax trees are build on best-effort basis. All accessor methods return
<code>Option</code>s. The tree for <code>fn foo</code> will contain a function declaration with
<code>None</code> for parameter list and body.</p>
</li>
<li>
<p>Syntax trees do not know the file they are built from, they only know about
the text.</p>
</li>
</ul>
<p>The implementation is based on the generic <a href="https://github.com/rust-analyzer/rowan/tree/100a36dc820eb393b74abe0d20ddf99077b61f88">rowan</a> crate on top of which a
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/syntax/src/ast/generated.rs">rust-specific</a> AST is generated.</p>
<p>The next step in constructing the semantic model is ...</p>
<h2 id="building-a-module-tree"><a class="header" href="#building-a-module-tree">Building a Module Tree</a></h2>
<p>The algorithm for building a tree of modules is to start with a crate root
(remember, each <code>Crate</code> from a <code>CrateGraph</code> has a <code>FileId</code>), collect all <code>mod</code>
declarations and recursively process child modules. This is handled by the
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres.rs#L307-L324"><code>crate_def_map_query</code></a>, with two slight variations.</p>
<p>First, rust-analyzer builds a module tree for all crates in a source root
simultaneously. The main reason for this is historical (<code>module_tree</code> predates
<code>CrateGraph</code>), but this approach also enables accounting for files which are not
part of any crate. That is, if you create a file but do not include it as a
submodule anywhere, you still get semantic completion, and you get a warning
about a free-floating module (the actual warning is not implemented yet).</p>
<p>The second difference is that <code>crate_def_map_query</code> does not <em>directly</em> depend on
the <code>SourceDatabase::parse</code> query. Why would calling the parse directly be bad?
Suppose the user changes the file slightly, by adding an insignificant whitespace.
Adding whitespace changes the parse tree (because it includes whitespace),
and that means recomputing the whole module tree.</p>
<p>We deal with this problem by introducing an intermediate <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres.rs#L326-L354"><code>block_def_map_query</code></a>.
This query processes the syntax tree and extracts a set of declared submodule
names. Now, changing the whitespace results in <code>block_def_map_query</code> being
re-executed for a <em>single</em> module, but because the result of this query stays
the same, we don't have to re-execute <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres.rs#L307-L324"><code>crate_def_map_query</code></a>. In fact, we only
need to re-execute it when we add/remove new files or when we change mod
declarations.</p>
<p>We store the resulting modules in a <code>Vec</code>-based indexed arena. The indices in
the arena becomes module IDs. And this brings us to the next topic:
assigning IDs in the general case.</p>
<h2 id="location-interner-pattern"><a class="header" href="#location-interner-pattern">Location Interner pattern</a></h2>
<p>One way to assign IDs is how we've dealt with modules: Collect all items into a
single array in some specific order and use the index in the array as an ID. The
main drawback of this approach is that these IDs are not stable: Adding a new item can
shift the IDs of all other items. This works for modules, because adding a module is
a comparatively rare operation, but would be less convenient for, for example,
functions.</p>
<p>Another solution here is positional IDs: We can identify a function as "the
function with name <code>foo</code> in a ModuleId(92) module". Such locations are stable:
adding a new function to the module (unless it is also named <code>foo</code>) does not
change the location. However, such "ID" types ceases to be a <code>Copy</code>able integer and in
general can become pretty large if we account for nesting (for example: "third parameter of
the <code>foo</code> function of the <code>bar</code> <code>impl</code> in the <code>baz</code> module").</p>
<p><a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/lib.rs#L96-L106"><code>Intern</code> and <code>Lookup</code></a> traits allows us to combine the benefits of positional and numeric
IDs. Implementing both traits effectively creates a bidirectional append-only map
between locations and integer IDs (typically newtype wrappers for <a href="https://docs.rs/salsa/0.16.1/salsa/struct.InternId.html"><code>salsa::InternId</code></a>)
which can "intern" a location and return an integer ID back. The salsa database we use
includes a couple of <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/lib.rs#L108-L122">interners</a>. How to "garbage collect" unused locations
is an open question.</p>
<p>For example, we use <code>Intern</code> and <code>Lookup</code> implementations to assign IDs to
definitions of functions, structs, enums, etc. The location, <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/lib.rs#L209-L212"><code>ItemLoc</code></a> contains
two bits of information:</p>
<ul>
<li>the ID of the module which contains the definition,</li>
<li>the ID of the specific item in the module's source code.</li>
</ul>
<p>We "could" use a text offset for the location of a particular item, but that would play
badly with salsa: offsets change after edits. So, as a rule of thumb, we avoid
using offsets, text ranges or syntax trees as keys and values for queries. What
we do instead is we store "index" of the item among all of the items of a file
(so, a positional based ID, but localized to a single file).</p>
<p>One thing we've glossed over for the time being is support for macros. We have
only proof of concept handling of macros at the moment, but they are extremely
interesting from an "assigning IDs" perspective.</p>
<h2 id="macros-and-recursive-locations"><a class="header" href="#macros-and-recursive-locations">Macros and recursive locations</a></h2>
<p>The tricky bit about macros is that they effectively create new source files.
While we can use <code>FileId</code>s to refer to original files, we can't just assign them
willy-nilly to the pseudo files of macro expansion. Instead, we use a special
ID, <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/span/src/lib.rs#L148-L160"><code>HirFileId</code></a> to refer to either a usual file or a macro-generated file:</p>
<pre><code class="language-rust">enum HirFileId {
    FileId(FileId),
    Macro(MacroCallId),
}</code></pre>
<p><code>MacroCallId</code> is an interned ID that identifies a particular macro invocation.
Simplifying, it's a <code>HirFileId</code> of a file containing the call plus the offset
of the macro call in the file.</p>
<p>Note how <code>HirFileId</code> is defined in terms of <code>MacroCallId</code> which is defined in
terms of <code>HirFileId</code>! This does not recur infinitely though: any chain of
<code>HirFileId</code>s bottoms out in <code>HirFileId::FileId</code>, that is, some source file
actually written by the user.</p>
<p>Note also that in the actual implementation, the two variants are encoded in
a single <code>u32</code>, which are differentiated by the MSB (most significant bit).
If the MSB is 0, the value represents a <code>FileId</code>, otherwise the remaining
31 bits represent a <code>MacroCallId</code>.</p>
<p>Now that we understand how to identify a definition, in a source or in a
macro-generated file, we can discuss name resolution a bit.</p>
<h2 id="name-resolution"><a class="header" href="#name-resolution">Name resolution</a></h2>
<p>Name resolution faces the same problem as the module tree: if we look at the
syntax tree directly, we'll have to recompute name resolution after every
modification. The solution to the problem is the same: We <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree.rs#L110-L154">lower</a> the source code of
each module into a position-independent representation which does not change if
we modify bodies of the items. After that we <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres/collector.rs#L404-L437">loop</a> resolving all imports until
we've reached a fixed point.</p>
<p>And, given all our preparation with IDs and a position-independent representation,
it is satisfying to <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/nameres/tests/incremental.rs#L31">test</a> that typing inside function body does not invalidate
name resolution results.</p>
<p>An interesting fact about name resolution is that it "erases" all of the
intermediate paths from the imports: in the end, we know which items are defined
and which items are imported in each module, but, if the import was <code>use foo::bar::baz</code>, we deliberately forget what modules <code>foo</code> and <code>bar</code> resolve to.</p>
<p>To serve "goto definition" requests on intermediate segments we need this info
in the IDE, however. Luckily, we need it only for a tiny fraction of imports, so we just ask
the module explicitly, "What does the path <code>foo::bar</code> resolve to?". This is a
general pattern: we try to compute the minimal possible amount of information
during analysis while allowing IDE to ask for additional specific bits.</p>
<p>Name resolution is also a good place to introduce another salsa pattern used
throughout the analyzer:</p>
<h2 id="source-map-pattern"><a class="header" href="#source-map-pattern">Source Map pattern</a></h2>
<p>Due to an obscure edge case in completion, IDE needs to know the syntax node of
a use statement which imported the given completion candidate. We can't just
store the syntax node as a part of name resolution: this will break
incrementality, due to the fact that syntax changes after every file
modification.</p>
<p>We solve this problem during the lowering step of name resolution. Along with
the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree.rs"><code>ItemTree</code></a> output, the lowering query additionally produces an <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/ast_id_map.rs#L136-L142"><code>AstIdMap</code></a>
via an <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree/lower.rs#L32"><code>ast_id_map</code></a> query. The <code>ItemTree</code> contains <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/item_tree.rs#L559-L563">imports</a>, but in a
position-independent form based on <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-expand/src/ast_id_map.rs#L29"><code>AstId</code></a>. The <code>AstIdMap</code> contains a mapping
from position-independent <code>AstId</code>s to (position-dependent) syntax nodes.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>First of all, implementation of type inference in rust-analyzer was spearheaded
by <a href="https://github.com/flodiebold">@flodiebold</a>. <a href="https://github.com/rust-lang/rust-analyzer/pull/327">#327</a> was an awesome Christmas present, thank you, Florian!</p>
<p>Type inference runs on per-function granularity and uses the patterns we've
discussed previously.</p>
<p>First, we <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/body.rs">lower the AST</a> of a function body into a position-independent
representation. In this representation, each expression is assigned a
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/hir.rs#L37">positional ID</a>. Alongside the lowered expression, <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-def/src/body.rs#L84-L88">a source map</a> is produced,
which maps between expression ids and original syntax. This lowering step also
deals with "incomplete" source trees by replacing missing expressions by an
explicit <code>Missing</code> expression.</p>
<p>Given the lowered body of the function, we can now run <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/hir-ty/src/infer.rs#L76-L131">type inference</a> and
construct a mapping from <code>ExprId</code>s to types.</p>
<h2 id="tying-it-all-together-completion"><a class="header" href="#tying-it-all-together-completion">Tying it all together: completion</a></h2>
<p>To conclude the overview of the rust-analyzer, let's trace the request for
(type-inference powered!) code completion!</p>
<p>We start by <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/main_loop.rs#L213">receiving a message</a> from the language client. We decode the
message as a request for completion and <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/dispatch.rs#L197-L211">schedule it on the threadpool</a>. This is
the place where we <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/dispatch.rs#L292">catch</a> canceled errors if, immediately after completion, the
client sends some modification.</p>
<p>In <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/rust-analyzer/src/handlers/request.rs#L850-L876">the handler</a>, we deserialize LSP requests into rust-analyzer specific data
types (by converting a file url into a numeric <code>FileId</code>), <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide/src/lib.rs#L605-L615">ask analysis for
completion</a> and serialize results into the LSP.</p>
<p>The <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/lib.rs#L148-L229">completion implementation</a> is finally the place where we start doing the actual
work. The first step is to collect the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context.rs#L407-L441"><code>CompletionContext</code></a> -- a struct which
describes the cursor position in terms of Rust syntax and semantics. For
example, <code>expected_name: Option&lt;NameOrNameRef&gt;</code> is the syntactic representation
for the expected name of what we're completing (usually the parameter name of
a function argument), while <code>expected_type: Option&lt;Type&gt;</code> is the semantic model
for the expected type of what we're completing.</p>
<p>To construct the context, we first do an <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context.rs#L644-L648">"IntelliJ Trick"</a>: we insert a dummy
identifier at the cursor's position and parse this modified file, to get a
reasonably looking syntax tree. Then we do a bunch of "classification" routines
to figure out the context. For example, we <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L463">find an parent <code>fn</code> node</a>, get a
<a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L466">semantic model</a> for it (using the lossy <code>source_analyzer</code> infrastructure)
and use it to determine the <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/context/analysis.rs#L467">expected type at the cursor position</a>.</p>
<p>The second step is to run a <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/lib.rs#L157-L226">series of independent completion routines</a>. Let's
take a closer look at <a href="https://github.com/rust-lang/rust-analyzer/blob/2024-01-01/crates/ide-completion/src/completions/dot.rs#L11-L41"><code>complete_dot</code></a>, which completes fields and methods in
<code>foo.bar|</code>. First we extract a semantic receiver type out of the <code>DotAccess</code>
argument. Then, using the semantic model for the type, we determine if the
receiver implements the <code>Future</code> trait, and add a <code>.await</code> completion item in
the affirmative case. Finally, we add all fields &amp; methods from the type to
completion.</p>
<div style="break-before: page; page-break-before: always;"></div><!---
lsp/ext.rs hash: 78e87a78de8f288e

If you need to change the above hash to make the test pass, please check if you
need to adjust this doc as well and ping this issue:

  https://github.com/rust-lang/rust-analyzer/issues/4604

--->
<h1 id="lsp-extensions"><a class="header" href="#lsp-extensions">LSP Extensions</a></h1>
<p>This document describes LSP extensions used by rust-analyzer.
It's a best effort document, when in doubt, consult the source (and send a PR with clarification ;-) ).
We aim to upstream all non Rust-specific extensions to the protocol, but this is not a top priority.
All capabilities are enabled via the <code>experimental</code> field of <code>ClientCapabilities</code> or <code>ServerCapabilities</code>.
Requests which we hope to upstream live under <code>experimental/</code> namespace.
Requests, which are likely to always remain specific to <code>rust-analyzer</code> are under <code>rust-analyzer/</code> namespace.</p>
<p>If you want to be notified about the changes to this document, subscribe to <a href="https://github.com/rust-lang/rust-analyzer/issues/4604">#4604</a>.</p>
<ul>
<li><a href="contributing/lsp-extensions.html#configuration-in-initializationoptions">Configuration in <code>initializationOptions</code></a></li>
<li><a href="contributing/lsp-extensions.html#snippet-textedit">Snippet <code>TextEdit</code></a>
<ul>
<li><a href="contributing/lsp-extensions.html#example">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-questions">Unresolved Questions</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#codeaction-groups"><code>CodeAction</code> Groups</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-1">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-questions-1">Unresolved Questions</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#parent-module">Parent Module</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-2">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-question">Unresolved Question</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#join-lines">Join Lines</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-3">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-question-1">Unresolved Question</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#on-enter">On Enter</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-4">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-question-2">Unresolved Question</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#structural-search-replace-ssr">Structural Search Replace (SSR)</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-5">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-question-3">Unresolved Question</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#matching-brace">Matching Brace</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-6">Example</a></li>
<li><a href="contributing/lsp-extensions.html#unresolved-question-4">Unresolved Question</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#runnables">Runnables</a></li>
<li><a href="contributing/lsp-extensions.html#test-explorer">Test explorer</a></li>
<li><a href="contributing/lsp-extensions.html#open-external-documentation">Open External Documentation</a></li>
<li><a href="contributing/lsp-extensions.html#local-documentation">Local Documentation</a></li>
<li><a href="contributing/lsp-extensions.html#analyzer-status">Analyzer Status</a></li>
<li><a href="contributing/lsp-extensions.html#reload-workspace">Reload Workspace</a></li>
<li><a href="contributing/lsp-extensions.html#rebuild-proc-macros">Rebuild proc-macros</a></li>
<li><a href="contributing/lsp-extensions.html#server-status">Server Status</a>
<ul>
<li><a href="contributing/lsp-extensions.html#controlling-flycheck">Controlling Flycheck</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#view-syntax-tree">View Syntax Tree</a></li>
<li><a href="contributing/lsp-extensions.html#view-hir">View Hir</a></li>
<li><a href="contributing/lsp-extensions.html#view-mir">View Mir</a></li>
<li><a href="contributing/lsp-extensions.html#interpret-function">Interpret Function</a></li>
<li><a href="contributing/lsp-extensions.html#view-file-text">View File Text</a></li>
<li><a href="contributing/lsp-extensions.html#view-itemtree">View ItemTree</a></li>
<li><a href="contributing/lsp-extensions.html#view-crate-graph">View Crate Graph</a></li>
<li><a href="contributing/lsp-extensions.html#expand-macro">Expand Macro</a></li>
<li><a href="contributing/lsp-extensions.html#hover-actions">Hover Actions</a></li>
<li><a href="contributing/lsp-extensions.html#open-cargotoml">Open Cargo.toml</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-7">Example</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#related-tests">Related tests</a></li>
<li><a href="contributing/lsp-extensions.html#hover-range">Hover Range</a>
<ul>
<li><a href="contributing/lsp-extensions.html#example-8">Example</a></li>
</ul>
</li>
<li><a href="contributing/lsp-extensions.html#move-item">Move Item</a></li>
<li><a href="contributing/lsp-extensions.html#workspace-symbols-filtering">Workspace Symbols Filtering</a></li>
<li><a href="contributing/lsp-extensions.html#client-commands">Client Commands</a></li>
<li><a href="contributing/lsp-extensions.html#colored-diagnostic-output">Colored Diagnostic Output</a></li>
<li><a href="contributing/lsp-extensions.html#dependency-tree">Dependency Tree</a></li>
<li><a href="contributing/lsp-extensions.html#view-recursive-memory-layout">View Recursive Memory Layout</a>
<ul>
<li><a href="contributing/lsp-extensions.html#unresolved-questions-2">Unresolved questions:</a></li>
</ul>
</li>
</ul>
<h2 id="configuration-in-initializationoptions"><a class="header" href="#configuration-in-initializationoptions">Configuration in <code>initializationOptions</code></a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/567</p>
<p>The <code>initializationOptions</code> field of the <code>InitializeParams</code> of the initialization request should contain the <code>"rust-analyzer"</code> section of the configuration.</p>
<p><code>rust-analyzer</code> normally sends a <code>"workspace/configuration"</code> request with <code>{ "items": ["rust-analyzer"] }</code> payload.
However, the server can't do this during initialization.
At the same time some essential configuration parameters are needed early on, before servicing requests.
For this reason, we ask that <code>initializationOptions</code> contains the configuration, as if the server did make a <code>"workspace/configuration"</code> request.</p>
<p>If a language client does not know about <code>rust-analyzer</code>'s configuration options it can get sensible defaults by doing any of the following:</p>
<ul>
<li>Not sending <code>initializationOptions</code></li>
<li>Sending <code>"initializationOptions": null</code></li>
<li>Sending <code>"initializationOptions": {}</code></li>
</ul>
<h2 id="snippet-textedit"><a class="header" href="#snippet-textedit">Snippet <code>TextEdit</code></a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/724</p>
<p><strong>Experimental Client Capability:</strong> <code>{ "snippetTextEdit": boolean }</code></p>
<p>If this capability is set, <code>WorkspaceEdit</code>s returned from <code>codeAction</code> requests and <code>TextEdit</code>s returned from <code>textDocument/onTypeFormatting</code> requests might contain <code>SnippetTextEdit</code>s instead of usual <code>TextEdit</code>s:</p>
<pre><code class="language-typescript">interface SnippetTextEdit extends TextEdit {
    insertTextFormat?: InsertTextFormat;
    annotationId?: ChangeAnnotationIdentifier;
}
</code></pre>
<pre><code class="language-typescript">export interface TextDocumentEdit {
    textDocument: OptionalVersionedTextDocumentIdentifier;
    edits: (TextEdit | SnippetTextEdit)[];
}
</code></pre>
<p>When applying such code action or text edit, the editor should insert snippet, with tab stops and placeholders.
At the moment, rust-analyzer guarantees that only a single <code>TextDocumentEdit</code> will have edits which can be <code>InsertTextFormat.Snippet</code>.
Any additional <code>TextDocumentEdit</code>s will only have edits which are <code>InsertTextFormat.PlainText</code>.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>"Add <code>derive</code>" code action transforms <code>struct S;</code> into <code>#[derive($0)] struct S;</code></p>
<h3 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved Questions</a></h3>
<ul>
<li>Where exactly are <code>SnippetTextEdit</code>s allowed (only in code actions at the moment)?</li>
<li>Can snippets span multiple files (so far, no)?</li>
</ul>
<h2 id="codeaction-groups"><a class="header" href="#codeaction-groups"><code>CodeAction</code> Groups</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/994</p>
<p><strong>Experimental Client Capability:</strong> <code>{ "codeActionGroup": boolean }</code></p>
<p>If this capability is set, <code>CodeAction</code>s returned from the server contain an additional field, <code>group</code>:</p>
<pre><code class="language-typescript">interface CodeAction {
    title: string;
    group?: string;
    ...
}
</code></pre>
<p>All code-actions with the same <code>group</code> should be grouped under single (extendable) entry in lightbulb menu.
The set of actions <code>[ { title: "foo" }, { group: "frobnicate", title: "bar" }, { group: "frobnicate", title: "baz" }]</code> should be rendered as</p>
<pre><code>💡
  +-------------+
  | foo         |
  +-------------+-----+
  | frobnicate &gt;| bar |
  +-------------+-----+
                | baz |
                +-----+
</code></pre>
<p>Alternatively, selecting <code>frobnicate</code> could present a user with an additional menu to choose between <code>bar</code> and <code>baz</code>.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let x: Entry/*cursor here*/ = todo!();
}</code></pre>
<p>Invoking code action at this position will yield two code actions for importing <code>Entry</code> from either <code>collections::HashMap</code> or <code>collection::BTreeMap</code>, grouped under a single "import" group.</p>
<h3 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved Questions</a></h3>
<ul>
<li>Is a fixed two-level structure enough?</li>
<li>Should we devise a general way to encode custom interaction protocols for GUI refactorings?</li>
</ul>
<h2 id="parent-module-1"><a class="header" href="#parent-module-1">Parent Module</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/1002</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "parentModule": boolean }</code></p>
<p>This request is sent from client to server to handle "Goto Parent Module" editor action.</p>
<p><strong>Method:</strong> <code>experimental/parentModule</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>Location | Location[] | LocationLink[] | null</code></p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-rust">// src/main.rs
mod foo;
// src/foo.rs

/* cursor here*/</code></pre>
<p><code>experimental/parentModule</code> returns a single <code>Link</code> to the <code>mod foo;</code> declaration.</p>
<h3 id="unresolved-question"><a class="header" href="#unresolved-question">Unresolved Question</a></h3>
<ul>
<li>An alternative would be to use a more general "gotoSuper" request, which would work for super methods, super classes and super modules.
This is the approach IntelliJ Rust is taking.
However, experience shows that super module (which generally has a feeling of navigation between files) should be separate.
If you want super module, but the cursor happens to be inside an overridden function, the behavior with single "gotoSuper" request is surprising.</li>
</ul>
<h2 id="join-lines-1"><a class="header" href="#join-lines-1">Join Lines</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/992</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "joinLines": boolean }</code></p>
<p>This request is sent from client to server to handle "Join Lines" editor action.</p>
<p><strong>Method:</strong> <code>experimental/joinLines</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface JoinLinesParams {
    textDocument: TextDocumentIdentifier,
    /// Currently active selections/cursor offsets.
    /// This is an array to support multiple cursors.
    ranges: Range[],
}
</code></pre>
<p><strong>Response:</strong> <code>TextEdit[]</code></p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust">fn main() {
    /*cursor here*/let x = {
        92
    };
}</code></pre>
<p><code>experimental/joinLines</code> yields (curly braces are automagically removed)</p>
<pre><code class="language-rust">fn main() {
    let x = 92;
}</code></pre>
<h3 id="unresolved-question-1"><a class="header" href="#unresolved-question-1">Unresolved Question</a></h3>
<ul>
<li>What is the position of the cursor after <code>joinLines</code>?
Currently, this is left to editor's discretion, but it might be useful to specify on the server via snippets.
However, it then becomes unclear how it works with multi cursor.</li>
</ul>
<h2 id="on-enter-1"><a class="header" href="#on-enter-1">On Enter</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/1001</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "onEnter": boolean }</code></p>
<p>This request is sent from client to server to handle the <kbd>Enter</kbd> key press.</p>
<p><strong>Method:</strong> <code>experimental/onEnter</code></p>
<p><strong>Request:</strong>: <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">SnippetTextEdit[]
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust">fn main() {
    // Some /*cursor here*/ docs
    let x = 92;
}</code></pre>
<p><code>experimental/onEnter</code> returns the following snippet</p>
<pre><code class="language-rust">fn main() {
    // Some
    // $0 docs
    let x = 92;
}</code></pre>
<p>The primary goal of <code>onEnter</code> is to handle automatic indentation when opening a new line.
This is not yet implemented.
The secondary goal is to handle fixing up syntax, like continuing doc strings and comments, and escaping <code>\n</code> in string literals.</p>
<p>As proper cursor positioning is raison d'être for <code>onEnter</code>, it uses <code>SnippetTextEdit</code>.</p>
<h3 id="unresolved-question-2"><a class="header" href="#unresolved-question-2">Unresolved Question</a></h3>
<ul>
<li>How to deal with synchronicity of the request?
One option is to require the client to block until the server returns the response.
Another option is to do a operational transforms style merging of edits from client and server.
A third option is to do a record-replay: client applies heuristic on enter immediately, then applies all user's keypresses.
When the server is ready with the response, the client rollbacks all the changes and applies the recorded actions on top of the correct response.</li>
<li>How to deal with multiple carets?</li>
<li>Should we extend this to arbitrary typed events and not just <code>onEnter</code>?</li>
</ul>
<h2 id="structural-search-replace-ssr"><a class="header" href="#structural-search-replace-ssr">Structural Search Replace (SSR)</a></h2>
<p><strong>Experimental Server Capability:</strong> <code>{ "ssr": boolean }</code></p>
<p>This request is sent from client to server to handle structural search replace -- automated syntax tree based transformation of the source.</p>
<p><strong>Method:</strong> <code>experimental/ssr</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface SsrParams {
    /// Search query.
    /// The specific syntax is specified outside of the protocol.
    query: string,
    /// If true, only check the syntax of the query and don't compute the actual edit.
    parseOnly: boolean,
    /// The current text document. This and `position` will be used to determine in what scope
    /// paths in `query` should be resolved.
    textDocument: TextDocumentIdentifier;
    /// Position where SSR was invoked.
    position: Position;
    /// Current selections. Search/replace will be restricted to these if non-empty.
    selections: Range[];
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">WorkspaceEdit
</code></pre>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<p>SSR with query <code>foo($a, $b) ==&gt;&gt; ($a).foo($b)</code> will transform, eg <code>foo(y + 5, z)</code> into <code>(y + 5).foo(z)</code>.</p>
<h3 id="unresolved-question-3"><a class="header" href="#unresolved-question-3">Unresolved Question</a></h3>
<ul>
<li>Probably needs search without replace mode</li>
<li>Needs a way to limit the scope to certain files.</li>
</ul>
<h2 id="matching-brace-1"><a class="header" href="#matching-brace-1">Matching Brace</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/999</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "matchingBrace": boolean }</code></p>
<p>This request is sent from client to server to handle "Matching Brace" editor action.</p>
<p><strong>Method:</strong> <code>experimental/matchingBrace</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface MatchingBraceParams {
    textDocument: TextDocumentIdentifier,
    /// Position for each cursor
    positions: Position[],
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">Position[]
</code></pre>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let x: Vec&lt;()&gt;/*cursor here*/ = vec![];
}</code></pre>
<p><code>experimental/matchingBrace</code> yields the position of <code>&lt;</code>.
In many cases, matching braces can be handled by the editor.
However, some cases (like disambiguating between generics and comparison operations) need a real parser.
Moreover, it would be cool if editors didn't need to implement even basic language parsing</p>
<h3 id="unresolved-question-4"><a class="header" href="#unresolved-question-4">Unresolved Question</a></h3>
<ul>
<li>Should we return a nested brace structure, to allow <a href="https://paredit.org/">paredit</a>-like actions of jump <em>out</em> of the current brace pair?
This is how <code>SelectionRange</code> request works.</li>
<li>Alternatively, should we perhaps flag certain <code>SelectionRange</code>s as being brace pairs?</li>
</ul>
<h2 id="runnables"><a class="header" href="#runnables">Runnables</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/944</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "runnables": { "kinds": string[] } }</code></p>
<p>This request is sent from client to server to get the list of things that can be run (tests, binaries, <code>cargo check -p</code>).</p>
<p><strong>Method:</strong> <code>experimental/runnables</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface RunnablesParams {
    textDocument: TextDocumentIdentifier;
    /// If null, compute runnables for the whole file.
    position?: Position;
}
</code></pre>
<p><strong>Response:</strong> <code>Runnable[]</code></p>
<pre><code class="language-typescript">interface Runnable {
    label: string;
    /// If this Runnable is associated with a specific function/module, etc., the location of this item
    location?: LocationLink;
    /// Running things is necessary technology specific, `kind` needs to be advertised via server capabilities,
    // the type of `args` is specific to `kind`. The actual running is handled by the client.
    kind: string;
    args: any;
}
</code></pre>
<p>rust-analyzer supports two <code>kind</code>s of runnables, <code>"cargo"</code> and <code>"shell"</code>. The <code>args</code> for <code>"cargo"</code> look like this:</p>
<pre><code class="language-typescript">{
    /**
     * Environment variables to set before running the command.
     */
    environment?: Record&lt;string, string&gt;;
    /**
     * The working directory to run the command in.
     */
    cwd: string;
    /**
     * The workspace root directory of the cargo project.
     */
    workspaceRoot?: string;
    /**
     * The cargo command to run.
     */
    cargoArgs: string[];
    /**
     * Arguments to pass to the executable, these will be passed to the command after a `--` argument.
     */
    executableArgs: string[];
    /**
     * Command to execute instead of `cargo`.
     */
    overrideCargo?: string;
}
</code></pre>
<p>The args for <code>"shell"</code> look like this:</p>
<pre><code class="language-typescript">{
    /**
     * Environment variables to set before running the command.
     */
    environment?: Record&lt;string, string&gt;;
    /**
     * The working directory to run the command in.
     */
    cwd: string;
    kind: string;
    program: string;
    args: string[];
}
</code></pre>
<h2 id="test-explorer"><a class="header" href="#test-explorer">Test explorer</a></h2>
<p><strong>Experimental Client Capability:</strong> <code>{ "testExplorer": boolean }</code></p>
<p>If this capability is set, the <code>experimental/discoveredTests</code> notification will be sent from the
server to the client.</p>
<p><strong>Method:</strong> <code>experimental/discoverTest</code></p>
<p><strong>Request:</strong> <code>DiscoverTestParams</code></p>
<pre><code class="language-typescript">interface DiscoverTestParams {
    // The test that we need to resolve its children. If not present,
    // the response should return top level tests.
    testId?: string | undefined;
}
</code></pre>
<p><strong>Response:</strong> <code>DiscoverTestResults</code></p>
<pre><code class="language-typescript">interface TestItem {
    // A unique identifier for the test
    id: string;
    // The file containing this test
    textDocument?: lc.TextDocumentIdentifier | undefined;
    // The range in the file containing this test
    range?: lc.Range | undefined;
    // A human readable name for this test
    label: string;
    // The kind of this test item. Based on the kind,
    // an icon is chosen by the editor.
    kind: "package" | "module" | "test";
    // True if this test may have children not available eagerly
    canResolveChildren: boolean;
    // The id of the parent test in the test tree. If not present, this test
    // is a top level test.
    parent?: string | undefined;
    // The information useful for running the test. The client can use `runTest`
    // request for simple execution, but for more complex execution forms
    // like debugging, this field is useful.
    // Note that this field includes some information about label and location as well, but
    // those exist just for keeping things in sync with other methods of running runnables
    // (for example using one consistent name in the vscode's launch.json) so for any purpose
    // other than running tests this field should not be used.
    runnable?: Runnable | undefined;
};

interface DiscoverTestResults {
    // The discovered tests.
    tests: TestItem[];
    // For each test whose id is in this list, the response
    // contains all tests that are children of this test, and
    // client should remove old tests not included in the response.
    scope: string[] | undefined;
    // For each file whose uri is in this list, the response
    // contains all tests that are located in this file, and
    // client should remove old tests not included in the response.
    scopeFile: lc.TextDocumentIdentifier[] | undefined;
}
</code></pre>
<p><strong>Method:</strong> <code>experimental/discoveredTests</code></p>
<p><strong>Notification:</strong> <code>DiscoverTestResults</code></p>
<p>This notification is sent from the server to the client when the
server detects changes in the existing tests. The <code>DiscoverTestResults</code> is
the same as the one in <code>experimental/discoverTest</code> response.</p>
<p><strong>Method:</strong> <code>experimental/runTest</code></p>
<p><strong>Request:</strong> <code>RunTestParams</code></p>
<pre><code class="language-typescript">interface RunTestParams {
    // Id of the tests to be run. If a test is included, all of its children are included implicitly. If
    // this property is undefined, then the server should simply run all tests.
    include?: string[] | undefined;
    // An array of test ids the user has marked as excluded from the test included in this run; exclusions
    // should apply after inclusions.
    // May be omitted if no exclusions were requested. Server should not run excluded tests or
    // any children of excluded tests.
    exclude?: string[] | undefined;
}
</code></pre>
<p><strong>Response:</strong> <code>void</code></p>
<p><strong>Method:</strong> <code>experimental/endRunTest</code></p>
<p><strong>Notification:</strong></p>
<p>This notification is sent from the server to the client when the current running
session is finished. The server should not send any run notification
after this.</p>
<p><strong>Method:</strong> <code>experimental/abortRunTest</code></p>
<p><strong>Notification:</strong></p>
<p>This notification is sent from the client to the server when the user is no longer
interested in the test results. The server should clean up its resources and send
a <code>experimental/endRunTest</code> when it is done.</p>
<p><strong>Method:</strong> <code>experimental/changeTestState</code></p>
<p><strong>Notification:</strong> <code>ChangeTestStateParams</code></p>
<pre><code class="language-typescript">type TestState = { tag: "passed" }
    | {
        tag: "failed";
        // The standard error of the test, containing the panic message. Clients should
        // render it similar to a terminal, and e.g. handle ansi colors.
        message: string;
    }
    | { tag: "started" }
    | { tag: "enqueued" }
    | { tag: "skipped" };

interface ChangeTestStateParams {
    testId: string;
    state: TestState;
}
</code></pre>
<p><strong>Method:</strong> <code>experimental/appendOutputToRunTest</code></p>
<p><strong>Notification:</strong> <code>string</code></p>
<p>This notification is used for reporting messages independent of any single test and related to the run session
in general, e.g. cargo compiling progress messages or warnings.</p>
<h2 id="open-external-documentation"><a class="header" href="#open-external-documentation">Open External Documentation</a></h2>
<p>This request is sent from the client to the server to obtain web and local URL(s) for documentation related to the symbol under the cursor, if available.</p>
<p><strong>Method:</strong> <code>experimental/externalDocs</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>string | null</code></p>
<h2 id="local-documentation"><a class="header" href="#local-documentation">Local Documentation</a></h2>
<p><strong>Experimental Client Capability:</strong> <code>{ "localDocs": boolean }</code></p>
<p>If this capability is set, the <code>Open External Documentation</code> request returned from the server will have the following structure:</p>
<pre><code class="language-typescript">interface ExternalDocsResponse {
    web?: string;
    local?: string;
}
</code></pre>
<h2 id="analyzer-status"><a class="header" href="#analyzer-status">Analyzer Status</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/analyzerStatus</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface AnalyzerStatusParams {
    /// If specified, show dependencies of the current file.
    textDocument?: TextDocumentIdentifier;
}
</code></pre>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns internal status message, mostly for debugging purposes.</p>
<h2 id="reload-workspace"><a class="header" href="#reload-workspace">Reload Workspace</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/reloadWorkspace</code></p>
<p><strong>Request:</strong> <code>null</code></p>
<p><strong>Response:</strong> <code>null</code></p>
<p>Reloads project information (that is, re-executes <code>cargo metadata</code>).</p>
<h2 id="rebuild-proc-macros"><a class="header" href="#rebuild-proc-macros">Rebuild proc-macros</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/rebuildProcMacros</code></p>
<p><strong>Request:</strong> <code>null</code></p>
<p><strong>Response:</strong> <code>null</code></p>
<p>Rebuilds build scripts and proc-macros, and runs the build scripts to reseed the build data.</p>
<h2 id="server-status"><a class="header" href="#server-status">Server Status</a></h2>
<p><strong>Experimental Client Capability:</strong> <code>{ "serverStatusNotification": boolean }</code></p>
<p><strong>Method:</strong> <code>experimental/serverStatus</code></p>
<p><strong>Notification:</strong></p>
<pre><code class="language-typescript">interface ServerStatusParams {
    /// `ok` means that the server is completely functional.
    ///
    /// `warning` means that the server is partially functional.
    /// It can answer correctly to most requests, but some results
    /// might be wrong due to, for example, some missing dependencies.
    ///
    /// `error` means that the server is not functional. For example,
    /// there's a fatal build configuration problem. The server might
    /// still give correct answers to simple requests, but most results
    /// will be incomplete or wrong.
    health: "ok" | "warning" | "error",
    /// Is there any pending background work which might change the status?
    /// For example, are dependencies being downloaded?
    quiescent: boolean,
    /// Explanatory message to show on hover.
    message?: string,
}
</code></pre>
<p>This notification is sent from server to client.
The client can use it to display <em>persistent</em> status to the user (in the mode line).
It is similar to the <code>showMessage</code>, but is intended for status rather than point-in-time events.</p>
<p>Note that this functionality is intended primarily to inform the end user about the state of the server.
In particular, it's valid for the client to completely ignore this extension.
Clients are discouraged from but are allowed to use the <code>health</code> status to decide if it's worth sending a request to the server.</p>
<h3 id="controlling-flycheck"><a class="header" href="#controlling-flycheck">Controlling Flycheck</a></h3>
<p>The flycheck/checkOnSave feature can be controlled via notifications sent by the client to the server.</p>
<p><strong>Method:</strong> <code>rust-analyzer/runFlycheck</code></p>
<p><strong>Notification:</strong></p>
<pre><code class="language-typescript">interface RunFlycheckParams {
    /// The text document whose cargo workspace flycheck process should be started.
    /// If the document is null or does not belong to a cargo workspace all flycheck processes will be started.
    textDocument: lc.TextDocumentIdentifier | null;
}
</code></pre>
<p>Triggers the flycheck processes.</p>
<p><strong>Method:</strong> <code>rust-analyzer/clearFlycheck</code></p>
<p><strong>Notification:</strong></p>
<pre><code class="language-typescript">interface ClearFlycheckParams {}
</code></pre>
<p>Clears the flycheck diagnostics.</p>
<p><strong>Method:</strong> <code>rust-analyzer/cancelFlycheck</code></p>
<p><strong>Notification:</strong></p>
<pre><code class="language-typescript">interface CancelFlycheckParams {}
</code></pre>
<p>Cancels all running flycheck processes.</p>
<h2 id="view-syntax-tree"><a class="header" href="#view-syntax-tree">View Syntax Tree</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewSyntaxTree</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface ViewSyntaxTreeParams {
    textDocument: TextDocumentIdentifier,
}
</code></pre>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns json representation of the file's syntax tree.
Used to create a treeView for debugging and working on rust-analyzer itself.</p>
<h2 id="view-hir-1"><a class="header" href="#view-hir-1">View Hir</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewHir</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns a textual representation of the HIR of the function containing the cursor.
For debugging or when working on rust-analyzer itself.</p>
<h2 id="view-mir-1"><a class="header" href="#view-mir-1">View Mir</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewMir</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns a textual representation of the MIR of the function containing the cursor.
For debugging or when working on rust-analyzer itself.</p>
<h2 id="interpret-function"><a class="header" href="#interpret-function">Interpret Function</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/interpretFunction</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>string</code></p>
<p>Tries to evaluate the function using internal rust analyzer knowledge, without compiling
the code. Currently evaluates the function under cursor, but will give a runnable in
future. Highly experimental.</p>
<h2 id="view-file-text"><a class="header" href="#view-file-text">View File Text</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewFileText</code></p>
<p><strong>Request:</strong> <code>TextDocumentIdentifier</code></p>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns the text of a file as seen by the server.
This is for debugging file sync problems.</p>
<h2 id="view-itemtree"><a class="header" href="#view-itemtree">View ItemTree</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewItemTree</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface ViewItemTreeParams {
    textDocument: TextDocumentIdentifier,
}
</code></pre>
<p><strong>Response:</strong> <code>string</code></p>
<p>Returns a textual representation of the <code>ItemTree</code> of the currently open file, for debugging.</p>
<h2 id="view-crate-graph-1"><a class="header" href="#view-crate-graph-1">View Crate Graph</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewCrateGraph</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface ViewCrateGraphParams {
    full: boolean,
}
</code></pre>
<p><strong>Response:</strong> <code>string</code></p>
<p>Renders rust-analyzer's crate graph as an SVG image.</p>
<p>If <code>full</code> is <code>true</code>, the graph includes non-workspace crates (crates.io dependencies as well as sysroot crates).</p>
<h2 id="expand-macro"><a class="header" href="#expand-macro">Expand Macro</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/expandMacro</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">interface ExpandMacroParams {
    textDocument: TextDocumentIdentifier,
    position: Position,
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">interface ExpandedMacro {
    name: string,
    expansion: string,
}
</code></pre>
<p>Expands macro call at a given position.</p>
<h2 id="hover-actions"><a class="header" href="#hover-actions">Hover Actions</a></h2>
<p><strong>Experimental Client Capability:</strong> <code>{ "hoverActions": boolean }</code></p>
<p>If this capability is set, <code>Hover</code> request returned from the server might contain an additional field, <code>actions</code>:</p>
<pre><code class="language-typescript">interface Hover {
    ...
    actions?: CommandLinkGroup[];
}

interface CommandLink extends Command {
    /**
     * A tooltip for the command, when represented in the UI.
     */
    tooltip?: string;
}

interface CommandLinkGroup {
    title?: string;
    commands: CommandLink[];
}
</code></pre>
<p>Such actions on the client side are appended to a hover bottom as command links:</p>
<pre><code>  +-----------------------------+
  | Hover content               |
  |                             |
  +-----------------------------+
  | _Action1_ | _Action2_       |  &lt;- first group, no TITLE
  +-----------------------------+
  | TITLE _Action1_ | _Action2_ |  &lt;- second group
  +-----------------------------+
  ...
</code></pre>
<h2 id="open-cargotoml"><a class="header" href="#open-cargotoml">Open Cargo.toml</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/rust-lang/rust-analyzer/issues/6462</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "openCargoToml": boolean }</code></p>
<p>This request is sent from client to server to open the current project's Cargo.toml</p>
<p><strong>Method:</strong> <code>experimental/openCargoToml</code></p>
<p><strong>Request:</strong> <code>OpenCargoTomlParams</code></p>
<p><strong>Response:</strong> <code>Location | null</code></p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-rust">// Cargo.toml
[package]
// src/main.rs

/* cursor here*/</code></pre>
<p><code>experimental/openCargoToml</code> returns a single <code>Link</code> to the start of the <code>[package]</code> keyword.</p>
<h2 id="related-tests-1"><a class="header" href="#related-tests-1">Related tests</a></h2>
<p>This request is sent from client to server to get the list of tests for the specified position.</p>
<p><strong>Method:</strong> <code>rust-analyzer/relatedTests</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong> <code>TestInfo[]</code></p>
<pre><code class="language-typescript">interface TestInfo {
    runnable: Runnable;
}
</code></pre>
<h2 id="hover-range"><a class="header" href="#hover-range">Hover Range</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/377</p>
<p><strong>Experimental Server Capability:</strong> { "hoverRange": boolean }</p>
<p>This extension allows passing a <code>Range</code> as a <code>position</code> field of <code>HoverParams</code>.
The primary use-case is to use the hover request to show the type of the expression currently selected.</p>
<pre><code class="language-typescript">interface HoverParams extends WorkDoneProgressParams {
    textDocument: TextDocumentIdentifier;
    position: Range | Position;
}
</code></pre>
<p>Whenever the client sends a <code>Range</code>, it is understood as the current selection and any hover included in the range will show the type of the expression if possible.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-rust">fn main() {
    let expression = $01 + 2 * 3$0;
}</code></pre>
<p>Triggering a hover inside the selection above will show a result of <code>i32</code>.</p>
<h2 id="move-item-1"><a class="header" href="#move-item-1">Move Item</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/rust-lang/rust-analyzer/issues/6823</p>
<p>This request is sent from client to server to move item under cursor or selection in some direction.</p>
<p><strong>Method:</strong> <code>experimental/moveItem</code></p>
<p><strong>Request:</strong> <code>MoveItemParams</code></p>
<p><strong>Response:</strong> <code>SnippetTextEdit[]</code></p>
<pre><code class="language-typescript">export interface MoveItemParams {
    textDocument: TextDocumentIdentifier,
    range: Range,
    direction: Direction
}

export const enum Direction {
    Up = "Up",
    Down = "Down"
}
</code></pre>
<h2 id="workspace-symbols-filtering"><a class="header" href="#workspace-symbols-filtering">Workspace Symbols Filtering</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/941</p>
<p><strong>Experimental Server Capability:</strong> <code>{ "workspaceSymbolScopeKindFiltering": boolean }</code></p>
<p>Extends the existing <code>workspace/symbol</code> request with ability to filter symbols by broad scope and kind of symbol.
If this capability is set, <code>workspace/symbol</code> parameter gains two new optional fields:</p>
<pre><code class="language-typescript">interface WorkspaceSymbolParams {
    /**
     * Return only the symbols defined in the specified scope.
     */
    searchScope?: WorkspaceSymbolSearchScope;
    /**
     * Return only the symbols of specified kinds.
     */
    searchKind?: WorkspaceSymbolSearchKind;
    ...
}

const enum WorkspaceSymbolSearchScope {
    Workspace = "workspace",
    WorkspaceAndDependencies = "workspaceAndDependencies"
}

const enum WorkspaceSymbolSearchKind {
    OnlyTypes = "onlyTypes",
    AllSymbols = "allSymbols"
}
</code></pre>
<h2 id="client-commands"><a class="header" href="#client-commands">Client Commands</a></h2>
<p><strong>Upstream Issue:</strong> https://github.com/microsoft/language-server-protocol/issues/642</p>
<p><strong>Experimental Client Capability:</strong> <code>{ "commands?": ClientCommandOptions }</code></p>
<p>Certain LSP types originating on the server, notably code lenses, embed commands.
Commands can be serviced either by the server or by the client.
However, the server doesn't know which commands are available on the client.</p>
<p>This extensions allows the client to communicate this info.</p>
<pre><code class="language-typescript">export interface ClientCommandOptions {
    /**
     * The commands to be executed on the client
     */
    commands: string[];
}
</code></pre>
<h2 id="colored-diagnostic-output"><a class="header" href="#colored-diagnostic-output">Colored Diagnostic Output</a></h2>
<p><strong>Experimental Client Capability:</strong> <code>{ "colorDiagnosticOutput": boolean }</code></p>
<p>If this capability is set, the "full compiler diagnostics" provided by <code>checkOnSave</code>
will include ANSI color and style codes to render the diagnostic in a similar manner
as <code>cargo</code>. This is translated into <code>--message-format=json-diagnostic-rendered-ansi</code>
when flycheck is run, instead of the default <code>--message-format=json</code>.</p>
<p>The full compiler rendered diagnostics are included in the server response
regardless of this capability:</p>
<pre><code class="language-typescript">// https://microsoft.github.io/language-server-protocol/specifications/specification-current#diagnostic
export interface Diagnostic {
    ...
    data?: {
        /**
         * The human-readable compiler output as it would be printed to a terminal.
         * Includes ANSI color and style codes if the client has set the experimental
         * `colorDiagnosticOutput` capability.
         */
        rendered?: string;
    };
}
</code></pre>
<h2 id="dependency-tree"><a class="header" href="#dependency-tree">Dependency Tree</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/fetchDependencyList</code></p>
<p><strong>Request:</strong></p>
<pre><code class="language-typescript">export interface FetchDependencyListParams {}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">export interface FetchDependencyListResult {
    crates: {
        name: string;
        version: string;
        path: string;
    }[];
}
</code></pre>
<p>Returns all crates from this workspace, so it can be used create a viewTree to help navigate the dependency tree.</p>
<h2 id="view-recursive-memory-layout"><a class="header" href="#view-recursive-memory-layout">View Recursive Memory Layout</a></h2>
<p><strong>Method:</strong> <code>rust-analyzer/viewRecursiveMemoryLayout</code></p>
<p><strong>Request:</strong> <code>TextDocumentPositionParams</code></p>
<p><strong>Response:</strong></p>
<pre><code class="language-typescript">export interface RecursiveMemoryLayoutNode = {
    /// Name of the item, or [ROOT], `.n` for tuples
    item_name: string;
    /// Full name of the type (type aliases are ignored)
    typename: string;
    /// Size of the type in bytes
    size: number;
    /// Alignment of the type in bytes
    alignment: number;
    /// Offset of the type relative to its parent (or 0 if it's the root)
    offset: number;
    /// Index of the node's parent (or -1 if it's the root)
    parent_idx: number;
    /// Index of the node's children (or -1 if it does not have children)
    children_start: number;
    /// Number of child nodes (unspecified if it does not have children)
    children_len: number;
};

export interface RecursiveMemoryLayout = {
    nodes: RecursiveMemoryLayoutNode[];
};
</code></pre>
<p>Returns a vector of nodes representing items in the datatype as a tree, <code>RecursiveMemoryLayout::nodes[0]</code> is the root node.</p>
<p>If <code>RecursiveMemoryLayout::nodes::length == 0</code> we could not find a suitable type.</p>
<p>Generic Types do not give anything because they are incomplete. Fully specified generic types do not give anything if they are selected directly but do work when a child of other types <a href="https://github.com/rust-lang/rust-analyzer/issues/15010">this is consistent with other behavior</a>.</p>
<h3 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions:</a></h3>
<ul>
<li>How should enums/unions be represented? currently they do not produce any children because they have multiple distinct sets of children.</li>
<li>Should niches be represented? currently they are not reported.</li>
<li>A visual representation of the memory layout is not specified, see the provided implementation for an example, however it may not translate well to terminal based editors or other such things.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-guide"><a class="header" href="#setup-guide">Setup Guide</a></h1>
<p>This guide gives a simplified opinionated setup for developers contributing to rust-analyzer using Visual Studio Code to make changes and Visual Studio Code Insiders to test those changes. This guide will assume you have Visual Studio Code and Visual Studio Code Insiders installed.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Since rust-analyzer is a Rust project, you will need to install Rust. You can download and install the latest stable version of Rust <a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<h2 id="step-by-step-setup"><a class="header" href="#step-by-step-setup">Step-by-Step Setup</a></h2>
<p><strong>Step 01</strong>: Fork the rust-analyzer repository and clone the fork to your local machine.</p>
<p><strong>Step 02</strong>: Open the project in Visual Studio Code.</p>
<p><strong>Step 03</strong>: Open a terminal and run <code>cargo build</code> to build the project.</p>
<p><strong>Step 04</strong>: Install the language server locally by running the following command:</p>
<pre><code class="language-sh"># Install only the language server  
cargo xtask install --server \  
    --code-bin code-insiders \  # Target a specific editor (code, code-exploration, code-insiders, codium, or code-oss)  
    --dev-rel  # Build in release mode with debug info level 2  
</code></pre>
<p>In the output of this command, there should be a file path provided to the installed binary on your local machine.
It should look something like the following output below:</p>
<pre><code>Installing &lt;path-to-rust-analyzer-binary&gt;
Installed package `rust-analyzer v0.0.0 (&lt;path-to-rust-analyzer-binary&gt;)` (executable `rust-analyzer.exe`)
</code></pre>
<p>In Visual Studio Code Insiders, you will want to open your User Settings (JSON) from the Command Palette. From there you should ensure that the <code>rust-analyzer.server.path</code> key is set to the <code>&lt;path-to-rust-analyzer-binary&gt;</code>. This will tell Visual Studio Code Insiders to use the locally installed version that you can debug.</p>
<p>The User Settings (JSON) file should contain the following:</p>
<pre><code class="language-json">{
    "rust-analyzer.server.path": "&lt;path-to-rust-analyzer-binary&gt;"
}
</code></pre>
<p>Now you should be able to make changes to rust-analyzer in Visual Studio Code and then view the changes in Visual Studio Code Insiders.</p>
<h2 id="debugging-rust-analyzer"><a class="header" href="#debugging-rust-analyzer">Debugging rust-analyzer</a></h2>
<p>The simplest way to debug rust-analyzer is to use the <code>eprintln!</code> macro. The reason why we use <code>eprintln!</code> instead of <code>println!</code> is because the language server uses <code>stdout</code> to send messages. So instead we will debug using <code>stderr</code>.</p>
<p>An example debugging statement could go into the <code>main_loop.rs</code> file which can be found at <code>crates/rust-analyzer/src/main_loop.rs</code>. Inside the <code>main_loop</code> we will add the following <code>eprintln!</code> to test debugging rust-analyzer:</p>
<pre><code class="language-rs">eprintln!("Hello, world!");
</code></pre>
<p>Now, run the following commands to check the project and reinstall the server:</p>
<pre><code class="language-sh">cargo check  
cargo xtask install --server --code-bin code-insiders --dev-rel  
</code></pre>
<p>Now on Visual Studio Code Insiders, we should be able to open the Output tab on our terminal and switch to Rust Analyzer Language Server to see the <code>eprintln!</code> statement we just wrote.</p>
<p>If you are able to see your output, you now have a complete workflow for debugging rust-analyzer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style"><a class="header" href="#style">Style</a></h1>
<p>Our approach to "clean code" is two-fold:</p>
<ul>
<li>We generally don't block PRs on style changes.</li>
<li>At the same time, all code in rust-analyzer is constantly refactored.</li>
</ul>
<p>It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.
Sending small cleanup PRs (like renaming a single local variable) is encouraged.</p>
<p>When reviewing pull requests prefer extending this document to leaving
non-reusable comments on the pull request itself.</p>
<h1 id="general"><a class="header" href="#general">General</a></h1>
<h2 id="scale-of-changes"><a class="header" href="#scale-of-changes">Scale of Changes</a></h2>
<p>Everyone knows that it's better to send small &amp; focused pull requests.
The problem is, sometimes you <em>have</em> to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.</p>
<p>The main things to keep an eye on are the boundaries between various components.
There are three kinds of changes:</p>
<ol>
<li>
<p>Internals of a single component are changed.
Specifically, you don't change any <code>pub</code> items.
A good example here would be an addition of a new assist.</p>
</li>
<li>
<p>API of a component is expanded.
Specifically, you add a new <code>pub</code> function which wasn't there before.
A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.</p>
</li>
<li>
<p>A new dependency between components is introduced.
Specifically, you add a <code>pub use</code> reexport from another crate or you add a new line to the <code>[dependencies]</code> section of <code>Cargo.toml</code>.
A good example here would be adding reference search capability to the assists crates.</p>
</li>
</ol>
<p>For the first group, the change is generally merged as long as:</p>
<ul>
<li>it works for the happy case,</li>
<li>it has tests,</li>
<li>it doesn't panic for the unhappy case.</li>
</ul>
<p>For the second group, the change would be subjected to quite a bit of scrutiny and iteration.
The new API needs to be right (or at least easy to change later).
The actual implementation doesn't matter that much.
It's very important to minimize the amount of changed lines of code for changes of the second kind.
Often, you start doing a change of the first kind, only to realize that you need to elevate to a change of the second kind.
In this case, we'll probably ask you to split API changes into a separate PR.</p>
<p>Changes of the third group should be pretty rare, so we don't specify any specific process for them.
That said, adding an innocent-looking <code>pub use</code> is a very simple way to break encapsulation, keep an eye on it!</p>
<p>Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate <a href="https://www.tedinski.com/2018/02/06/system-boundaries.html">this post</a>.</p>
<h2 id="cratesio-dependencies"><a class="header" href="#cratesio-dependencies">Crates.io Dependencies</a></h2>
<p>We try to be very conservative with usage of crates.io dependencies.
Don't use small "helper" crates (exception: <code>itertools</code> and <code>either</code> are allowed).
If there's some general reusable bit of code you need, consider adding it to the <code>stdx</code> crate.
A useful exercise is to read Cargo.lock and see if some <em>transitive</em> dependencies do not make sense for rust-analyzer.</p>
<p><strong>Rationale:</strong> keep compile times low, create ecosystem pressure for faster compiles, reduce the number of things which might break.</p>
<h2 id="commit-style"><a class="header" href="#commit-style">Commit Style</a></h2>
<p>We don't have specific rules around git history hygiene.
Maintaining clean git history is strongly encouraged, but not enforced.
Use rebase workflow, it's OK to rewrite history during PR review process.
After you are happy with the state of the code, please use <a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">interactive rebase</a> to squash fixup commits.</p>
<p>Avoid @mentioning people in commit messages and pull request descriptions(they are added to commit message by bors).
Such messages create a lot of duplicate notification traffic during rebases.</p>
<p>If possible, write Pull Request titles and descriptions from the user's perspective:</p>
<pre><code># GOOD
Make goto definition work inside macros

# BAD
Use original span for FileId
</code></pre>
<p>This makes it easier to prepare a changelog.</p>
<p>If the change adds a new user-visible functionality, consider recording a GIF with <a href="https://github.com/phw/peek">peek</a> and pasting it into the PR description.</p>
<p>To make writing the release notes easier, you can mark a pull request as a feature, fix, internal change, or minor.
Minor changes are excluded from the release notes, while the other types are distributed in their corresponding sections.
There are two ways to mark this:</p>
<ul>
<li>use a <code>feat: </code>, <code>feature: </code>, <code>fix: </code>, <code>internal: </code> or <code>minor: </code> prefix in the PR title</li>
<li>write <code>changelog [feature|fix|internal|skip] [description]</code> in a comment or in the PR description; the description is optional, and will replace the title if included.</li>
</ul>
<p>These comments don't have to be added by the PR author.
Editing a comment or the PR description or title is also fine, as long as it happens before the release.</p>
<p><strong>Rationale:</strong> clean history is potentially useful, but rarely used.
But many users read changelogs.
Including a description and GIF suitable for the changelog means less work for the maintainers on the release day.</p>
<h2 id="clippy-1"><a class="header" href="#clippy-1">Clippy</a></h2>
<p>We use Clippy to improve the code, but if some lints annoy you, allow them in the <a href="https://github.com/rust-lang/rust-analyzer/blob/master/Cargo.toml">Cargo.toml</a> [workspace.lints.clippy] section.</p>
<h1 id="code"><a class="header" href="#code">Code</a></h1>
<h2 id="minimal-tests"><a class="header" href="#minimal-tests">Minimal Tests</a></h2>
<p>Most tests in rust-analyzer start with a snippet of Rust code.
These snippets should be minimal -- if you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.</p>
<p>It also makes sense to format snippets more compactly (for example, by placing enum definitions like <code>enum E { Foo, Bar }</code> on a single line),
as long as they are still readable.</p>
<p>When using multiline fixtures, use unindented raw string literals:</p>
<pre><code class="language-rust">    #[test]
    fn inline_field_shorthand() {
        check_assist(
            inline_local_variable,
            r#"
struct S { foo: i32}
fn main() {
    let $0foo = 92;
    S { foo }
}
"#,
            r#"
struct S { foo: i32}
fn main() {
    S { foo: 92 }
}
"#,
        );
    }</code></pre>
<p><strong>Rationale:</strong></p>
<p>There are many benefits to this:</p>
<ul>
<li>less to read or to scroll past</li>
<li>easier to understand what exactly is tested</li>
<li>less stuff printed during printf-debugging</li>
<li>less time to run test</li>
</ul>
<p>Formatting ensures that you can use your editor's "number of selected characters" feature to correlate offsets with test's source code.</p>
<h2 id="marked-tests"><a class="header" href="#marked-tests">Marked Tests</a></h2>
<p>Use
<a href="https://github.com/matklad/cov-mark"><code>cov_mark::hit! / cov_mark::check!</code></a>
when testing specific conditions.
Do not place several marks into a single test or condition.
Do not reuse marks between several tests.</p>
<p><strong>Rationale:</strong> marks provide an easy way to find the canonical test for each bit of code.
This makes it much easier to understand.
More than one mark per test / code branch doesn't add significantly to understanding.</p>
<h2 id="should_panic"><a class="header" href="#should_panic"><code>#[should_panic]</code></a></h2>
<p>Do not use <code>#[should_panic]</code> tests.
Instead, explicitly check for <code>None</code>, <code>Err</code>, etc.</p>
<p><strong>Rationale:</strong> <code>#[should_panic]</code> is a tool for library authors to make sure that the API does not fail silently when misused.
<code>rust-analyzer</code> is not a library, we don't need to test for API misuse, and we have to handle any user input without panics.
Panic messages in the logs from the <code>#[should_panic]</code> tests are confusing.</p>
<h2 id="ignore"><a class="header" href="#ignore"><code>#[ignore]</code></a></h2>
<p>Do not <code>#[ignore]</code> tests.
If the test currently does not work, assert the wrong behavior and add a fixme explaining why it is wrong.</p>
<p><strong>Rationale:</strong> noticing when the behavior is fixed, making sure that even the wrong behavior is acceptable (ie, not a panic).</p>
<h2 id="function-preconditions"><a class="header" href="#function-preconditions">Function Preconditions</a></h2>
<p>Express function preconditions in types and force the caller to provide them (rather than checking in callee):</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(walrus: Walrus) {
    ...
}

// BAD
fn frobnicate(walrus: Option&lt;Walrus&gt;) {
    let walrus = match walrus {
        Some(it) =&gt; it,
        None =&gt; return,
    };
    ...
}</code></pre>
<p><strong>Rationale:</strong> this makes control flow explicit at the call site.
Call-site has more context, it often happens that the precondition falls out naturally or can be bubbled up higher in the stack.</p>
<p>Avoid splitting precondition check and precondition use across functions:</p>
<pre><code class="language-rust">// GOOD
fn main() {
    let s: &amp;str = ...;
    if let Some(contents) = string_literal_contents(s) {

    }
}

fn string_literal_contents(s: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    if s.starts_with('"') &amp;&amp; s.ends_with('"') {
        Some(&amp;s[1..s.len() - 1])
    } else {
        None
    }
}

// BAD
fn main() {
    let s: &amp;str = ...;
    if is_string_literal(s) {
        let contents = &amp;s[1..s.len() - 1];
    }
}

fn is_string_literal(s: &amp;str) -&gt; bool {
    s.starts_with('"') &amp;&amp; s.ends_with('"')
}</code></pre>
<p>In the "Bad" version, the precondition that <code>1</code> and <code>s.len() - 1</code> are valid string literal boundaries is checked in <code>is_string_literal</code> but used in <code>main</code>.
In the "Good" version, the precondition check and usage are checked in the same block, and then encoded in the types.</p>
<p><strong>Rationale:</strong> non-local code properties degrade under change.</p>
<p>When checking a boolean precondition, prefer <code>if !invariant</code> to <code>if negated_invariant</code>:</p>
<pre><code class="language-rust">// GOOD
if !(idx &lt; len) {
    return None;
}

// BAD
if idx &gt;= len {
    return None;
}</code></pre>
<p><strong>Rationale:</strong> it's useful to see the invariant relied upon by the rest of the function clearly spelled out.</p>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>As a special case of the previous rule, do not hide control flow inside functions, push it to the caller:</p>
<pre><code class="language-rust">// GOOD
if cond {
    f()
}

// BAD
fn f() {
    if !cond {
        return;
    }
    ...
}</code></pre>
<p>See also <a href="https://matklad.github.io/2023/11/15/push-ifs-up-and-fors-down.html">this post</a></p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>Assert liberally.
Prefer <a href="https://docs.rs/always-assert/0.1.2/always_assert/macro.never.html"><code>stdx::never!</code></a> to standard <code>assert!</code>.</p>
<p><strong>Rationale:</strong> See <a href="https://github.com/rust-lang/rust-analyzer/blob/master/docs/book/src/contributing/architecture.md#error-handling">cross cutting concern: error handling</a>.</p>
<h2 id="getters--setters"><a class="header" href="#getters--setters">Getters &amp; Setters</a></h2>
<p>If a field can have any value without breaking invariants, make the field public.
Conversely, if there is an invariant, document it, enforce it in the "constructor" function, make the field private, and provide a getter.
Never provide setters.</p>
<p>Getters should return borrowed data:</p>
<pre><code class="language-rust">struct Person {
    // Invariant: never empty
    first_name: String,
    middle_name: Option&lt;String&gt;
}

// GOOD
impl Person {
    fn first_name(&amp;self) -&gt; &amp;str { self.first_name.as_str() }
    fn middle_name(&amp;self) -&gt; Option&lt;&amp;str&gt; { self.middle_name.as_ref() }
}

// BAD
impl Person {
    fn first_name(&amp;self) -&gt; String { self.first_name.clone() }
    fn middle_name(&amp;self) -&gt; &amp;Option&lt;String&gt; { &amp;self.middle_name }
}</code></pre>
<p><strong>Rationale:</strong> we don't provide public API, it's cheaper to refactor than to pay getters rent.
Non-local code properties degrade under change, privacy makes invariant local.
Borrowed owned types (<code>&amp;String</code>) disclose irrelevant details about internal representation.
Irrelevant (neither right nor wrong) things obscure correctness.</p>
<h2 id="useless-types"><a class="header" href="#useless-types">Useless Types</a></h2>
<p>More generally, always prefer types on the left</p>
<pre><code class="language-rust">// GOOD      BAD
&amp;[T]         &amp;Vec&lt;T&gt;
&amp;str         &amp;String
Option&lt;&amp;T&gt;   &amp;Option&lt;T&gt;
&amp;Path        &amp;PathBuf</code></pre>
<p><strong>Rationale:</strong> types on the left are strictly more general.
Even when generality is not required, consistency is important.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Prefer <code>Default</code> to zero-argument <code>new</code> function.</p>
<pre><code class="language-rust">// GOOD
#[derive(Default)]
struct Foo {
    bar: Option&lt;Bar&gt;
}

// BAD
struct Foo {
    bar: Option&lt;Bar&gt;
}

impl Foo {
    fn new() -&gt; Foo {
        Foo { bar: None }
    }
}</code></pre>
<p>Prefer <code>Default</code> even if it has to be implemented manually.</p>
<p><strong>Rationale:</strong> less typing in the common case, uniformity.</p>
<p>Use <code>Vec::new</code> rather than <code>vec![]</code>.</p>
<p><strong>Rationale:</strong> uniformity, strength reduction.</p>
<p>Avoid using "dummy" states to implement a <code>Default</code>.
If a type doesn't have a sensible default, empty value, don't hide it.
Let the caller explicitly decide what the right initial state is.</p>
<h2 id="functions-over-objects"><a class="header" href="#functions-over-objects">Functions Over Objects</a></h2>
<p>Avoid creating "doer" objects.
That is, objects which are created only to execute a single action.</p>
<pre><code class="language-rust">// GOOD
do_thing(arg1, arg2);

// BAD
ThingDoer::new(arg1, arg2).do();</code></pre>
<p>Note that this concerns only outward API.
When implementing <code>do_thing</code>, it might be very useful to create a context object.</p>
<pre><code class="language-rust">pub fn do_thing(arg1: Arg1, arg2: Arg2) -&gt; Res {
    let mut ctx = Ctx { arg1, arg2 };
    ctx.run()
}

struct Ctx {
    arg1: Arg1, arg2: Arg2
}

impl Ctx {
    fn run(self) -&gt; Res {
        ...
    }
}</code></pre>
<p>The difference is that <code>Ctx</code> is an impl detail here.</p>
<p>Sometimes a middle ground is acceptable if this can save some busywork:</p>
<pre><code class="language-rust">ThingDoer::do(arg1, arg2);

pub struct ThingDoer {
    arg1: Arg1, arg2: Arg2,
}

impl ThingDoer {
    pub fn do(arg1: Arg1, arg2: Arg2) -&gt; Res {
        ThingDoer { arg1, arg2 }.run()
    }
    fn run(self) -&gt; Res {
        ...
    }
}</code></pre>
<p><strong>Rationale:</strong> not bothering the caller with irrelevant details, not mixing user API with implementor API.</p>
<h2 id="functions-with-many-parameters"><a class="header" href="#functions-with-many-parameters">Functions with many parameters</a></h2>
<p>Avoid creating functions with many optional or boolean parameters.
Introduce a <code>Config</code> struct instead.</p>
<pre><code class="language-rust">// GOOD
pub struct AnnotationConfig {
    pub binary_target: bool,
    pub annotate_runnables: bool,
    pub annotate_impls: bool,
}

pub fn annotations(
    db: &amp;RootDatabase,
    file_id: FileId,
    config: AnnotationConfig
) -&gt; Vec&lt;Annotation&gt; {
    ...
}

// BAD
pub fn annotations(
    db: &amp;RootDatabase,
    file_id: FileId,
    binary_target: bool,
    annotate_runnables: bool,
    annotate_impls: bool,
) -&gt; Vec&lt;Annotation&gt; {
    ...
}</code></pre>
<p><strong>Rationale:</strong> reducing churn.
If the function has many parameters, they most likely change frequently.
By packing them into a struct we protect all intermediary functions from changes.</p>
<p>Do not implement <code>Default</code> for the <code>Config</code> struct, the caller has more context to determine better defaults.
Do not store <code>Config</code> as a part of the <code>state</code>, pass it explicitly.
This gives more flexibility for the caller.</p>
<p>If there is variation not only in the input parameters, but in the return type as well, consider introducing a <code>Command</code> type.</p>
<pre><code class="language-rust">// MAYBE GOOD
pub struct Query {
    pub name: String,
    pub case_sensitive: bool,
}

impl Query {
    pub fn all(self) -&gt; Vec&lt;Item&gt; { ... }
    pub fn first(self) -&gt; Option&lt;Item&gt; { ... }
}

// MAYBE BAD
fn query_all(name: String, case_sensitive: bool) -&gt; Vec&lt;Item&gt; { ... }
fn query_first(name: String, case_sensitive: bool) -&gt; Option&lt;Item&gt; { ... }</code></pre>
<h2 id="prefer-separate-functions-over-parameters"><a class="header" href="#prefer-separate-functions-over-parameters">Prefer Separate Functions Over Parameters</a></h2>
<p>If a function has a <code>bool</code> or an <code>Option</code> parameter, and it is always called with <code>true</code>, <code>false</code>, <code>Some</code> and <code>None</code> literals, split the function in two.</p>
<pre><code class="language-rust">// GOOD
fn caller_a() {
    foo()
}

fn caller_b() {
    foo_with_bar(Bar::new())
}

fn foo() { ... }
fn foo_with_bar(bar: Bar) { ... }

// BAD
fn caller_a() {
    foo(None)
}

fn caller_b() {
    foo(Some(Bar::new()))
}

fn foo(bar: Option&lt;Bar&gt;) { ... }</code></pre>
<p><strong>Rationale:</strong> more often than not, such functions display "<code>false sharing</code>" -- they have additional <code>if</code> branching inside for two different cases.
Splitting the two different control flows into two functions simplifies each path, and remove cross-dependencies between the two paths.
If there's common code between <code>foo</code> and <code>foo_with_bar</code>, extract <em>that</em> into a common helper.</p>
<h2 id="appropriate-string-types"><a class="header" href="#appropriate-string-types">Appropriate String Types</a></h2>
<p>When interfacing with OS APIs, use <code>OsString</code>, even if the original source of data is utf-8 encoded.
<strong>Rationale:</strong> cleanly delineates the boundary when the data goes into the OS-land.</p>
<p>Use <code>AbsPathBuf</code> and <code>AbsPath</code> over <code>std::Path</code>.
<strong>Rationale:</strong> rust-analyzer is a long-lived process which handles several projects at the same time.
It is important not to leak cwd by accident.</p>
<h1 id="premature-pessimization"><a class="header" href="#premature-pessimization">Premature Pessimization</a></h1>
<h2 id="avoid-allocations"><a class="header" href="#avoid-allocations">Avoid Allocations</a></h2>
<p>Avoid writing code which is slower than it needs to be.
Don't allocate a <code>Vec</code> where an iterator would do, don't allocate strings needlessly.</p>
<pre><code class="language-rust">// GOOD
use itertools::Itertools;

let (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {
    Some(it) =&gt; it,
    None =&gt; return,
}

// BAD
let words = text.split_ascii_whitespace().collect::&lt;Vec&lt;_&gt;&gt;();
if words.len() != 2 {
    return
}</code></pre>
<p><strong>Rationale:</strong> not allocating is almost always faster.</p>
<h2 id="push-allocations-to-the-call-site"><a class="header" href="#push-allocations-to-the-call-site">Push Allocations to the Call Site</a></h2>
<p>If allocation is inevitable, let the caller allocate the resource:</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(s: String) {
    ...
}

// BAD
fn frobnicate(s: &amp;str) {
    let s = s.to_string();
    ...
}</code></pre>
<p><strong>Rationale:</strong> reveals the costs.
It is also more efficient when the caller already owns the allocation.</p>
<h2 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h2>
<p>Prefer <code>rustc_hash::FxHashMap</code> and <code>rustc_hash::FxHashSet</code> instead of the ones in <code>std::collections</code>.</p>
<p><strong>Rationale:</strong> they use a hasher that's significantly faster and using them consistently will reduce code size by some small amount.</p>
<h2 id="avoid-intermediate-collections"><a class="header" href="#avoid-intermediate-collections">Avoid Intermediate Collections</a></h2>
<p>When writing a recursive function to compute a sets of things, use an accumulator parameter instead of returning a fresh collection.
Accumulator goes first in the list of arguments.</p>
<pre><code class="language-rust">// GOOD
pub fn reachable_nodes(node: Node) -&gt; FxHashSet&lt;Node&gt; {
    let mut res = FxHashSet::default();
    go(&amp;mut res, node);
    res
}
fn go(acc: &amp;mut FxHashSet&lt;Node&gt;, node: Node) {
    acc.insert(node);
    for n in node.neighbors() {
        go(acc, n);
    }
}

// BAD
pub fn reachable_nodes(node: Node) -&gt; FxHashSet&lt;Node&gt; {
    let mut res = FxHashSet::default();
    res.insert(node);
    for n in node.neighbors() {
        res.extend(reachable_nodes(n));
    }
    res
}</code></pre>
<p><strong>Rationale:</strong> re-use allocations, accumulator style is more concise for complex cases.</p>
<h2 id="avoid-monomorphization"><a class="header" href="#avoid-monomorphization">Avoid Monomorphization</a></h2>
<p>Avoid making a lot of code type parametric, <em>especially</em> on the boundaries between crates.</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(mut f: impl FnMut()) {
    frobnicate_impl(&amp;mut f)
}
fn frobnicate_impl(f: &amp;mut dyn FnMut()) {
    // lots of code
}

// BAD
fn frobnicate(mut f: impl FnMut()) {
    // lots of code
}</code></pre>
<p>Avoid <code>AsRef</code> polymorphism, it pays back only for widely used libraries:</p>
<pre><code class="language-rust">// GOOD
fn frobnicate(f: &amp;Path) {
}

// BAD
fn frobnicate(f: impl AsRef&lt;Path&gt;) {
}</code></pre>
<p><strong>Rationale:</strong> Rust uses monomorphization to compile generic code, meaning that for each instantiation of a generic functions with concrete types, the function is compiled afresh, <em>per crate</em>.
This allows for exceptionally good performance, but leads to increased compile times.
Runtime performance obeys 80%/20% rule -- only a small fraction of code is hot.
Compile time <strong>does not</strong> obey this rule -- all code has to be compiled.</p>
<h1 id="style-1"><a class="header" href="#style-1">Style</a></h1>
<h2 id="order-of-imports"><a class="header" href="#order-of-imports">Order of Imports</a></h2>
<p>Separate import groups with blank lines.
Use one <code>use</code> per crate.</p>
<p>Module declarations come before the imports.
Order them in "suggested reading order" for a person new to the code base.</p>
<pre><code class="language-rust">mod x;
mod y;

// First std.
use std::{ ... }

// Second, external crates (both crates.io crates and other rust-analyzer crates).
use crate_foo::{ ... }
use crate_bar::{ ... }

// Then current crate.
use crate::{}

// Finally, parent and child modules, but prefer `use crate::`.
use super::{}

// Re-exports are treated as item definitions rather than imports, so they go
// after imports and modules. Use them sparingly.
pub use crate::x::Z;</code></pre>
<p><strong>Rationale:</strong> consistency.
Reading order is important for new contributors.
Grouping by crate allows spotting unwanted dependencies easier.</p>
<h2 id="import-style"><a class="header" href="#import-style">Import Style</a></h2>
<p>Qualify items from <code>hir</code> and <code>ast</code>.</p>
<pre><code class="language-rust">// GOOD
use syntax::ast;

fn frobnicate(func: hir::Function, strukt: ast::Struct) {}

// BAD
use hir::Function;
use syntax::ast::Struct;

fn frobnicate(func: Function, strukt: Struct) {}</code></pre>
<p><strong>Rationale:</strong> avoids name clashes, makes the layer clear at a glance.</p>
<p>When implementing traits from <code>std::fmt</code> or <code>std::ops</code>, import the module:</p>
<pre><code class="language-rust">// GOOD
use std::fmt;

impl fmt::Display for RenameError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { .. }
}

// BAD
impl std::fmt::Display for RenameError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { .. }
}

// BAD
use std::ops::Deref;

impl Deref for Widget {
    type Target = str;
    fn deref(&amp;self) -&gt; &amp;str { .. }
}</code></pre>
<p><strong>Rationale:</strong> overall, less typing.
Makes it clear that a trait is implemented, rather than used.</p>
<p>Avoid local <code>use MyEnum::*</code> imports.
<strong>Rationale:</strong> consistency.</p>
<p>Prefer <code>use crate::foo::bar</code> to <code>use super::bar</code> or <code>use self::bar::baz</code>.
<strong>Rationale:</strong> consistency, this is the style which works in all cases.</p>
<p>By default, avoid re-exports.
<strong>Rationale:</strong> for non-library code, re-exports introduce two ways to use something and allow for inconsistency.</p>
<h2 id="order-of-items"><a class="header" href="#order-of-items">Order of Items</a></h2>
<p>Optimize for the reader who sees the file for the first time, and wants to get a general idea about what's going on.
People read things from top to bottom, so place most important things first.</p>
<p>Specifically, if all items except one are private, always put the non-private item on top.</p>
<pre><code class="language-rust">// GOOD
pub(crate) fn frobnicate() {
    Helper::act()
}

#[derive(Default)]
struct Helper { stuff: i32 }

impl Helper {
    fn act(&amp;self) {

    }
}

// BAD
#[derive(Default)]
struct Helper { stuff: i32 }

pub(crate) fn frobnicate() {
    Helper::act()
}

impl Helper {
    fn act(&amp;self) {

    }
}</code></pre>
<p>If there's a mixture of private and public items, put public items first.</p>
<p>Put <code>struct</code>s and <code>enum</code>s first, functions and impls last. Order type declarations in top-down manner.</p>
<pre><code class="language-rust">// GOOD
struct Parent {
    children: Vec&lt;Child&gt;
}

struct Child;

impl Parent {
}

impl Child {
}

// BAD
struct Child;

impl Child {
}

struct Parent {
    children: Vec&lt;Child&gt;
}

impl Parent {
}</code></pre>
<p><strong>Rationale:</strong> easier to get the sense of the API by visually scanning the file.
If function bodies are folded in the editor, the source code should read as documentation for the public API.</p>
<h2 id="context-parameters"><a class="header" href="#context-parameters">Context Parameters</a></h2>
<p>Some parameters are threaded unchanged through many function calls.
They determine the "context" of the operation.
Pass such parameters first, not last.
If there are several context parameters, consider packing them into a <code>struct Ctx</code> and passing it as <code>&amp;self</code>.</p>
<pre><code class="language-rust">// GOOD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    let mut visited = FxHashSet::default();
    return go(graph, &amp;mut visited, v);

    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }
}

// BAD
fn dfs(v: Vertex, graph: &amp;Graph) -&gt; usize {
    fn go(v: usize, graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;) -&gt; usize {
        ...
    }

    let mut visited = FxHashSet::default();
    go(v, graph, &amp;mut visited)
}</code></pre>
<p><strong>Rationale:</strong> consistency.
Context-first works better when non-context parameter is a lambda.</p>
<h2 id="variable-naming"><a class="header" href="#variable-naming">Variable Naming</a></h2>
<p>Use boring and long names for local variables (<a href="https://github.com/rust-lang/rust-analyzer/pull/4162#discussion_r417130973">yay code completion</a>).
The default name is a lowercased name of the type: <code>global_state: GlobalState</code>.
Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (<code>db</code>, <code>ctx</code>, <code>acc</code>).
Prefer American spelling (color, behavior).</p>
<p>Default names:</p>
<ul>
<li><code>res</code> -- "result of the function" local variable</li>
<li><code>it</code> -- I don't really care about the name</li>
<li><code>n_foos</code> -- number of foos (prefer this to <code>foo_count</code>)</li>
<li><code>foo_idx</code> -- index of <code>foo</code></li>
</ul>
<p>Many names in rust-analyzer conflict with keywords.
We use mangled names instead of <code>r#ident</code> syntax:</p>
<pre><code>crate  -&gt; krate
enum   -&gt; enum_
fn     -&gt; func
impl   -&gt; imp
macro  -&gt; mac
mod    -&gt; module
struct -&gt; strukt
trait  -&gt; trait_
type   -&gt; ty
</code></pre>
<p><strong>Rationale:</strong> consistency.</p>
<h2 id="error-handling-trivia"><a class="header" href="#error-handling-trivia">Error Handling Trivia</a></h2>
<p>Use <code>anyhow::Result</code> rather than just <code>Result</code>.</p>
<p><strong>Rationale:</strong> makes it immediately clear what result that is.</p>
<p>Use <code>anyhow::format_err!</code> rather than <code>anyhow::anyhow</code>.</p>
<p><strong>Rationale:</strong> consistent, boring, avoids stuttering.</p>
<p>There's no specific guidance on the formatting of error messages, see <a href="https://github.com/dtolnay/anyhow/issues/209">anyhow/#209</a>.
Do not end error and context messages with <code>.</code> though.</p>
<h2 id="early-returns"><a class="header" href="#early-returns">Early Returns</a></h2>
<p>Do use early returns</p>
<pre><code class="language-rust">// GOOD
fn foo() -&gt; Option&lt;Bar&gt; {
    if !condition() {
        return None;
    }

    Some(...)
}

// BAD
fn foo() -&gt; Option&lt;Bar&gt; {
    if condition() {
        Some(...)
    } else {
        None
    }
}</code></pre>
<p><strong>Rationale:</strong> reduce cognitive stack usage.</p>
<p>Use <code>return Err(err)</code> to throw an error:</p>
<pre><code class="language-rust">// GOOD
fn f() -&gt; Result&lt;(), ()&gt; {
    if condition {
        return Err(());
    }
    Ok(())
}

// BAD
fn f() -&gt; Result&lt;(), ()&gt; {
    if condition {
        Err(())?;
    }
    Ok(())
}</code></pre>
<p><strong>Rationale:</strong> <code>return</code> has type <code>!</code>, which allows the compiler to flag dead
code (<code>Err(...)?</code> is of unconstrained generic type <code>T</code>).</p>
<h2 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h2>
<p>When doing multiple comparisons use <code>&lt;</code>/<code>&lt;=</code>, avoid <code>&gt;</code>/<code>&gt;=</code>.</p>
<pre><code class="language-rust">// GOOD
assert!(lo &lt;= x &amp;&amp; x &lt;= hi);
assert!(r1 &lt; l2 || r2 &lt; l1);
assert!(x &lt; y);
assert!(0 &lt; x);

// BAD
assert!(x &gt;= lo &amp;&amp; x &lt;= hi);
assert!(r1 &lt; l2 || l1 &gt; r2);
assert!(y &gt; x);
assert!(x &gt; 0);</code></pre>
<p><strong>Rationale:</strong> Less-then comparisons are more intuitive, they correspond spatially to <a href="https://en.wikipedia.org/wiki/Real_line">real line</a>.</p>
<h2 id="if-let"><a class="header" href="#if-let">If-let</a></h2>
<p>Avoid <code>if let ... { } else { }</code> construct, use <code>match</code> instead.</p>
<pre><code class="language-rust">// GOOD
match ctx.expected_type.as_ref() {
    Some(expected_type) =&gt; completion_ty == expected_type &amp;&amp; !expected_type.is_unit(),
    None =&gt; false,
}

// BAD
if let Some(expected_type) = ctx.expected_type.as_ref() {
    completion_ty == expected_type &amp;&amp; !expected_type.is_unit()
} else {
    false
}</code></pre>
<p><strong>Rationale:</strong> <code>match</code> is almost always more compact.
The <code>else</code> branch can get a more precise pattern: <code>None</code> or <code>Err(_)</code> instead of <code>_</code>.</p>
<h2 id="match-ergonomics"><a class="header" href="#match-ergonomics">Match Ergonomics</a></h2>
<p>Don't use the <code>ref</code> keyword.</p>
<p><strong>Rationale:</strong> consistency &amp; simplicity.
<code>ref</code> was required before <a href="https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md">match ergonomics</a>.
Today, it is redundant.
Between <code>ref</code> and match ergonomics, the latter is more ergonomic in most cases, and is simpler (does not require a keyword).</p>
<h2 id="empty-match-arms"><a class="header" href="#empty-match-arms">Empty Match Arms</a></h2>
<p>Use <code>=&gt; (),</code> when a match arm is intentionally empty:</p>
<pre><code class="language-rust">// GOOD
match result {
    Ok(_) =&gt; (),
    Err(err) =&gt; error!("{}", err),
}

// BAD
match result {
    Ok(_) =&gt; {}
    Err(err) =&gt; error!("{}", err),
}</code></pre>
<p><strong>Rationale:</strong> consistency.</p>
<h2 id="functional-combinators"><a class="header" href="#functional-combinators">Functional Combinators</a></h2>
<p>Use high order monadic combinators like <code>map</code>, <code>then</code> when they are a natural choice; don't bend the code to fit into some combinator.
If writing a chain of combinators creates friction, replace them with control flow constructs: <code>for</code>, <code>if</code>, <code>match</code>.
Mostly avoid <code>bool::then</code> and <code>Option::filter</code>.</p>
<pre><code class="language-rust">// GOOD
if !x.cond() {
    return None;
}
Some(x)

// BAD
Some(x).filter(|it| it.cond())</code></pre>
<p>This rule is more "soft" then others, and boils down mostly to taste.
The guiding principle behind this rule is that code should be dense in computation, and sparse in the number of expressions per line.
The second example contains <em>less</em> computation -- the <code>filter</code> function is an indirection for <code>if</code>, it doesn't do any useful work by itself.
At the same time, it is more crowded -- it takes more time to visually scan it.</p>
<p><strong>Rationale:</strong> consistency, playing to language's strengths.
Rust has first-class support for imperative control flow constructs like <code>for</code> and <code>if</code>, while functions are less first-class due to lack of universal function type, currying, and non-first-class effects (<code>?</code>, <code>.await</code>).</p>
<h2 id="turbofish"><a class="header" href="#turbofish">Turbofish</a></h2>
<p>Prefer type ascription over the turbofish.
When ascribing types, avoid <code>_</code></p>
<pre><code class="language-rust">// GOOD
let mutable: Vec&lt;T&gt; = old.into_iter().map(|it| builder.make_mut(it)).collect();

// BAD
let mutable: Vec&lt;_&gt; = old.into_iter().map(|it| builder.make_mut(it)).collect();

// BAD
let mutable = old.into_iter().map(|it| builder.make_mut(it)).collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<p><strong>Rationale:</strong> consistency, readability.
If compiler struggles to infer the type, the human would as well.
Having the result type specified up-front helps with understanding what the chain of iterator methods is doing.</p>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h2>
<p>Avoid creating single-use helper functions:</p>
<pre><code class="language-rust">// GOOD
let buf = {
    let mut buf = get_empty_buf(&amp;mut arena);
    buf.add_item(item);
    buf
};

// BAD
let buf = prepare_buf(&amp;mut arena, item);

...

fn prepare_buf(arena: &amp;mut Arena, item: Item) -&gt; ItemBuf {
    let mut res = get_empty_buf(&amp;mut arena);
    res.add_item(item);
    res
}</code></pre>
<p>Exception: if you want to make use of <code>return</code> or <code>?</code>.</p>
<p><strong>Rationale:</strong> single-use functions change frequently, adding or removing parameters adds churn.
A block serves just as well to delineate a bit of logic, but has access to all the context.
Re-using originally single-purpose function often leads to bad coupling.</p>
<h2 id="local-helper-functions"><a class="header" href="#local-helper-functions">Local Helper Functions</a></h2>
<p>Put nested helper functions at the end of the enclosing functions
(this requires using return statement).
Don't nest more than one level deep.</p>
<pre><code class="language-rust">// GOOD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    let mut visited = FxHashSet::default();
    return go(graph, &amp;mut visited, v);

    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }
}

// BAD
fn dfs(graph: &amp;Graph, v: Vertex) -&gt; usize {
    fn go(graph: &amp;Graph, visited: &amp;mut FxHashSet&lt;Vertex&gt;, v: usize) -&gt; usize {
        ...
    }

    let mut visited = FxHashSet::default();
    go(graph, &amp;mut visited, v)
}</code></pre>
<p><strong>Rationale:</strong> consistency, improved top-down readability.</p>
<h2 id="helper-variables"><a class="header" href="#helper-variables">Helper Variables</a></h2>
<p>Introduce helper variables freely, especially for multiline conditions:</p>
<pre><code class="language-rust">// GOOD
let rustfmt_not_installed =
    captured_stderr.contains("not installed") || captured_stderr.contains("not available");

match output.status.code() {
    Some(1) if !rustfmt_not_installed =&gt; Ok(None),
    _ =&gt; Err(format_err!("rustfmt failed:\n{}", captured_stderr)),
};

// BAD
match output.status.code() {
    Some(1)
        if !captured_stderr.contains("not installed")
           &amp;&amp; !captured_stderr.contains("not available") =&gt; Ok(None),
    _ =&gt; Err(format_err!("rustfmt failed:\n{}", captured_stderr)),
};</code></pre>
<p><strong>Rationale:</strong> Like blocks, single-use variables are a cognitively cheap abstraction, as they have access to all the context.
Extra variables help during debugging, they make it easy to print/view important intermediate results.
Giving a name to a condition inside an <code>if</code> expression often improves clarity and leads to nicely formatted code.</p>
<h2 id="token-names"><a class="header" href="#token-names">Token names</a></h2>
<p>Use <code>T![foo]</code> instead of <code>SyntaxKind::FOO_KW</code>.</p>
<pre><code class="language-rust">// GOOD
match p.current() {
    T![true] | T![false] =&gt; true,
    _ =&gt; false,
}

// BAD

match p.current() {
    SyntaxKind::TRUE_KW | SyntaxKind::FALSE_KW =&gt; true,
    _ =&gt; false,
}</code></pre>
<p><strong>Rationale:</strong> The macro uses the familiar Rust syntax, avoiding ambiguities like "is this a brace or bracket?".</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Style inline code comments as proper sentences.
Start with a capital letter, end with a dot.</p>
<pre><code class="language-rust">// GOOD

// Only simple single segment paths are allowed.
MergeBehavior::Last =&gt; {
    tree.use_tree_list().is_none() &amp;&amp; tree.path().map(path_len) &lt;= Some(1)
}

// BAD

// only simple single segment paths are allowed
MergeBehavior::Last =&gt; {
    tree.use_tree_list().is_none() &amp;&amp; tree.path().map(path_len) &lt;= Some(1)
}</code></pre>
<p><strong>Rationale:</strong> writing a sentence (or maybe even a paragraph) rather just "a comment" creates a more appropriate frame of mind.
It tricks you into writing down more of the context you keep in your head while coding.</p>
<p>For <code>.md</code> files prefer a sentence-per-line format, don't wrap lines.
If the line is too long, you want to split the sentence in two :-)</p>
<p><strong>Rationale:</strong> much easier to edit the text and read the diff, see <a href="https://asciidoctor.org/docs/asciidoc-recommended-practices/#one-sentence-per-line">this link</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-in-rust-analyzer"><a class="header" href="#syntax-in-rust-analyzer">Syntax in rust-analyzer</a></h1>
<h2 id="about-the-guide-1"><a class="header" href="#about-the-guide-1">About the guide</a></h2>
<p>This guide describes the current state of syntax trees and parsing in rust-analyzer as of 2020-01-09 (<a href="https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6">link to commit</a>).</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The things described are implemented in three places</p>
<ul>
<li><a href="https://github.com/rust-analyzer/rowan/tree/v0.15.10">rowan</a> -- a generic library for rowan syntax trees.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/syntax">syntax</a> crate inside rust-analyzer which wraps <code>rowan</code> into rust-analyzer specific API.
Nothing in rust-analyzer except this crate knows about <code>rowan</code>.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/parser">parser</a> crate parses input tokens into a <code>syntax</code> tree</li>
</ul>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<ul>
<li>Syntax trees are lossless, or full fidelity. All comments and whitespace get preserved.</li>
<li>Syntax trees are semantic-less. They describe <em>strictly</em> the structure of a sequence of characters, they don't have hygiene, name resolution or type information attached.</li>
<li>Syntax trees are simple value types. It is possible to create trees for a syntax without any external context.</li>
<li>Syntax trees have intuitive traversal API (parent, children, siblings, etc).</li>
<li>Parsing is lossless (even if the input is invalid, the tree produced by the parser represents it exactly).</li>
<li>Parsing is resilient (even if the input is invalid, parser tries to see as much syntax tree fragments in the input as it can).</li>
<li>Performance is important, it's OK to use <code>unsafe</code> if it means better memory/cpu usage.</li>
<li>Keep the parser and the syntax tree isolated from each other, such that they can vary independently.</li>
</ul>
<h2 id="trees"><a class="header" href="#trees">Trees</a></h2>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The syntax tree consists of three layers:</p>
<ul>
<li>GreenNodes</li>
<li>SyntaxNodes (aka RedNode)</li>
<li>AST</li>
</ul>
<p>Of these, only GreenNodes store the actual data, the other two layers are (non-trivial) views into green tree.
Red-green terminology comes from Roslyn (<a href="https://ericlippert.com/2012/06/08/red-green-trees/">link</a>) and gives the name to the <code>rowan</code> library. Green and syntax nodes are defined in rowan, ast is defined in rust-analyzer.</p>
<p>Syntax trees are a semi-transient data structure.
In general, frontend does not keep syntax trees for all files in memory.
Instead, it <em>lowers</em> syntax trees to more compact and rigid representation, which is not full-fidelity, but which can be mapped back to a syntax tree if so desired.</p>
<h3 id="greennode"><a class="header" href="#greennode">GreenNode</a></h3>
<p>GreenNode is a purely-functional tree with arbitrary arity. Conceptually, it is equivalent to the following run of the mill struct:</p>
<pre><code class="language-rust">#[derive(PartialEq, Eq, Clone, Copy)]
struct SyntaxKind(u16);

#[derive(PartialEq, Eq, Clone)]
struct Node {
    kind: SyntaxKind,
    text_len: usize,
    children: Vec&lt;Arc&lt;Either&lt;Node, Token&gt;&gt;&gt;,
}

#[derive(PartialEq, Eq, Clone)]
struct Token {
    kind: SyntaxKind,
    text: String,
}</code></pre>
<p>All the difference between the above sketch and the real implementation are strictly due to optimizations.</p>
<p>Points of note:</p>
<ul>
<li>The tree is untyped. Each node has a "type tag", <code>SyntaxKind</code>.</li>
<li>Interior and leaf nodes are distinguished on the type level.</li>
<li>Trivia and non-trivia tokens are not distinguished on the type level.</li>
<li>Each token carries its full text.</li>
<li>The original text can be recovered by concatenating the texts of all tokens in order.</li>
<li>Accessing a child of particular type (for example, parameter list of a function) generally involves linearly traversing the children, looking for a specific <code>kind</code>.</li>
<li>Modifying the tree is roughly <code>O(depth)</code>.
We don't make special efforts to guarantee that the depth is not linear, but, in practice, syntax trees are branchy and shallow.</li>
<li>If mandatory (grammar wise) node is missing from the input, it's just missing from the tree.</li>
<li>If an extra erroneous input is present, it is wrapped into a node with <code>ERROR</code> kind, and treated just like any other node.</li>
<li>Parser errors are not a part of syntax tree.</li>
</ul>
<p>An input like <code>fn f() { 90 + 2 }</code> might be parsed as</p>
<pre><code>FN@0..17
  FN_KW@0..2 "fn"
  WHITESPACE@2..3 " "
  NAME@3..4
    IDENT@3..4 "f"
  PARAM_LIST@4..6
    L_PAREN@4..5 "("
    R_PAREN@5..6 ")"
  WHITESPACE@6..7 " "
  BLOCK_EXPR@7..17
    L_CURLY@7..8 "{"
    WHITESPACE@8..9 " "
    BIN_EXPR@9..15
      LITERAL@9..11
        INT_NUMBER@9..11 "90"
      WHITESPACE@11..12 " "
      PLUS@12..13 "+"
      WHITESPACE@13..14 " "
      LITERAL@14..15
        INT_NUMBER@14..15 "2"
    WHITESPACE@15..16 " "
    R_CURLY@16..17 "}"
</code></pre>
<h4 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h4>
<p>(significant amount of implementation work here was done by <a href="https://github.com/cad97">CAD97</a>).</p>
<p>To reduce the amount of allocations, the GreenNode is a <a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html">DST</a>, which uses a single allocation for header and children. Thus, it is only usable behind a pointer.</p>
<pre><code>*-----------+------+----------+------------+--------+--------+-----+--------*
| ref_count | kind | text_len | n_children | child1 | child2 | ... | childn |
*-----------+------+----------+------------+--------+--------+-----+--------*
</code></pre>
<p>To more compactly store the children, we box <em>both</em> interior nodes and tokens, and represent
<code>Either&lt;Arc&lt;Node&gt;, Arc&lt;Token&gt;&gt;</code> as a single pointer with a tag in the last bit.</p>
<p>To avoid allocating EVERY SINGLE TOKEN on the heap, syntax trees use interning.
Because the tree is fully immutable, it's valid to structurally share subtrees.
For example, in <code>1 + 1</code>, there will be a <em>single</em> token for <code>1</code> with ref count 2; the same goes for the <code> </code> whitespace token.
Interior nodes are shared as well (for example in <code>(1 + 1) * (1 + 1)</code>).</p>
<p>Note that, the result of the interning is an <code>Arc&lt;Node&gt;</code>.
That is, it's not an index into interning table, so you don't have to have the table around to do anything with the tree.
Each tree is fully self-contained (although different trees might share parts).
Currently, the interner is created per-file, but it will be easy to use a per-thread or per-some-context one.</p>
<p>We use a <code>TextSize</code>, a newtyped <code>u32</code>, to store the length of the text.</p>
<p>We currently use <code>SmolStr</code>, a small object optimized string to store text.
This was mostly relevant <em>before</em> we implemented tree interning, to avoid allocating common keywords and identifiers. We should switch to storing text data alongside the interned tokens.</p>
<h4 id="alternative-designs"><a class="header" href="#alternative-designs">Alternative designs</a></h4>
<h5 id="dealing-with-trivia"><a class="header" href="#dealing-with-trivia">Dealing with trivia</a></h5>
<p>In the above model, whitespace is not treated specially.
Another alternative (used by swift and roslyn) is to explicitly divide the set of tokens into trivia and non-trivia tokens, and represent non-trivia tokens as</p>
<pre><code class="language-rust">struct Token {
    kind: NonTriviaTokenKind,
    text: String,
    leading_trivia: Vec&lt;TriviaToken&gt;,
    trailing_trivia: Vec&lt;TriviaToken&gt;,
}</code></pre>
<p>The tree then contains only non-trivia tokens.</p>
<p>Another approach (from Dart) is to, in addition to a syntax tree, link all the tokens into a bidirectional link list.
That way, the tree again contains only non-trivia tokens.</p>
<p>Explicit trivia nodes, like in <code>rowan</code>, are used by IntelliJ.</p>
<h5 id="accessing-children"><a class="header" href="#accessing-children">Accessing Children</a></h5>
<p>As noted before, accessing a specific child in the node requires a linear traversal of the children (though we can skip tokens, because the tag is encoded in the pointer itself).
It is possible to recover O(1) access with another representation.
We explicitly store optional and missing (required by the grammar, but not present) nodes.
That is, we use <code>Option&lt;Node&gt;</code> for children.
We also remove trivia tokens from the tree.
This way, each child kind generally occupies a fixed position in a parent, and we can use index access to fetch it.
The cost is that we now need to allocate space for all not-present optional nodes.
So, <code>fn foo() {}</code> will have slots for visibility, unsafeness, attributes, abi and return type.</p>
<p>IntelliJ uses linear traversal.
Roslyn and Swift do <code>O(1)</code> access.</p>
<h5 id="mutable-trees"><a class="header" href="#mutable-trees">Mutable Trees</a></h5>
<p>IntelliJ uses mutable trees.
Overall, it creates a lot of additional complexity.
However, the API for <em>editing</em> syntax trees is nice.</p>
<p>For example the assist to move generic bounds to where clause has this code:</p>
<pre><code class="language-kotlin"> for typeBound in typeBounds {
     typeBound.typeParamBounds?.delete()
}
</code></pre>
<p>Modeling this with immutable trees is possible, but annoying.</p>
<h3 id="syntax-nodes"><a class="header" href="#syntax-nodes">Syntax Nodes</a></h3>
<p>A function green tree is not super-convenient to use.
The biggest problem is accessing parents (there are no parent pointers!).
But there are also "identity" issues.
Let's say you want to write a code which builds a list of expressions in a file: <code>fn collect_expressions(file: GreenNode) -&gt; HashSet&lt;GreenNode&gt;</code>.
For the input like</p>
<pre><code class="language-rust">fn main() {
    let x = 90i8;
    let x = x + 2;
    let x = 90i64;
    let x = x + 2;
}</code></pre>
<p>both copies of the <code>x + 2</code> expression are representing by equal (and, with interning in mind, actually the same) green nodes.
Green trees just can't differentiate between the two.</p>
<p><code>SyntaxNode</code> adds parent pointers and identify semantics to green nodes.
They can be called cursors or <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)">zippers</a> (fun fact: zipper is a derivative (as in ′) of a data structure).</p>
<p>Conceptually, a <code>SyntaxNode</code> looks like this:</p>
<pre><code class="language-rust">type SyntaxNode = Arc&lt;SyntaxData&gt;;

struct SyntaxData {
    offset: usize,
    parent: Option&lt;SyntaxNode&gt;,
    green: Arc&lt;GreenNode&gt;,
}

impl SyntaxNode {
    fn new_root(root: Arc&lt;GreenNode&gt;) -&gt; SyntaxNode {
        Arc::new(SyntaxData {
            offset: 0,
            parent: None,
            green: root,
        })
    }
    fn parent(&amp;self) -&gt; Option&lt;SyntaxNode&gt; {
        self.parent.clone()
    }
    fn children(&amp;self) -&gt; impl Iterator&lt;Item = SyntaxNode&gt; {
        let mut offset = self.offset;
        self.green.children().map(|green_child| {
            let child_offset = offset;
            offset += green_child.text_len;
            Arc::new(SyntaxData {
                offset: child_offset,
                parent: Some(Arc::clone(self)),
                green: Arc::clone(green_child),
            })
        })
    }
}

impl PartialEq for SyntaxNode {
    fn eq(&amp;self, other: &amp;SyntaxNode) -&gt; bool {
        self.offset == other.offset
            &amp;&amp; Arc::ptr_eq(&amp;self.green, &amp;other.green)
    }
}</code></pre>
<p>Points of note:</p>
<ul>
<li>SyntaxNode remembers its parent node (and, transitively, the path to the root of the tree)</li>
<li>SyntaxNode knows its <em>absolute</em> text offset in the whole file</li>
<li>Equality is based on identity. Comparing nodes from different trees does not make sense.</li>
</ul>
<h4 id="optimization"><a class="header" href="#optimization">Optimization</a></h4>
<p>The reality is different though :-)
Traversal of trees is a common operation, and it makes sense to optimize it.
In particular, the above code allocates and does atomic operations during a traversal.</p>
<p>To get rid of atomics, <code>rowan</code> uses non thread-safe <code>Rc</code>.
This is OK because trees traversals mostly (always, in case of rust-analyzer) run on a single thread. If you need to send a <code>SyntaxNode</code> to another thread, you can send a pair of <strong>root</strong><code>GreenNode</code> (which is thread safe) and a <code>Range&lt;usize&gt;</code>.
The other thread can restore the <code>SyntaxNode</code> by traversing from the root green node and looking for a node with specified range.
You can also use the similar trick to store a <code>SyntaxNode</code>.
That is, a data structure that holds a <code>(GreenNode, Range&lt;usize&gt;)</code> will be <code>Sync</code>.
However, rust-analyzer goes even further.
It treats trees as semi-transient and instead of storing a <code>GreenNode</code>, it generally stores just the id of the file from which the tree originated: <code>(FileId, Range&lt;usize&gt;)</code>.
The <code>SyntaxNode</code> is the restored by reparsing the file and traversing it from root.
With this trick, rust-analyzer holds only a small amount of trees in memory at the same time, which reduces memory usage.</p>
<p>Additionally, only the root <code>SyntaxNode</code> owns an <code>Arc</code> to the (root) <code>GreenNode</code>.
All other <code>SyntaxNode</code>s point to corresponding <code>GreenNode</code>s with a raw pointer.
They also point to the parent (and, consequently, to the root) with an owning <code>Rc</code>, so this is sound.
In other words, one needs <em>one</em> arc bump when initiating a traversal.</p>
<p>To get rid of allocations, <code>rowan</code> takes advantage of <code>SyntaxNode: !Sync</code> and uses a thread-local free list of <code>SyntaxNode</code>s.
In a typical traversal, you only directly hold a few <code>SyntaxNode</code>s at a time (and their ancestors indirectly), so a free list proportional to the depth of the tree removes all allocations in a typical case.</p>
<p>So, while traversal is not exactly incrementing a pointer, it's still pretty cheap: TLS + rc bump!</p>
<p>Traversal also yields (cheap) owned nodes, which improves ergonomics quite a bit.</p>
<h4 id="alternative-designs-1"><a class="header" href="#alternative-designs-1">Alternative Designs</a></h4>
<h5 id="memoized-rednodes"><a class="header" href="#memoized-rednodes">Memoized RedNodes</a></h5>
<p>C# and Swift follow the design where the red nodes are memoized, which would look roughly like this in Rust:</p>
<pre><code class="language-rust">type SyntaxNode = Arc&lt;SyntaxData&gt;;

struct SyntaxData {
    offset: usize,
    parent: Option&lt;SyntaxNode&gt;,
    green: Arc&lt;GreenNode&gt;,
    children: Vec&lt;OnceCell&lt;SyntaxNode&gt;&gt;,
}</code></pre>
<p>This allows using true pointer equality for comparison of identities of <code>SyntaxNodes</code>.
rust-analyzer used to have this design as well, but we've since switched to cursors.
The main problem with memoizing the red nodes is that it more than doubles the memory requirements for fully realized syntax trees.
In contrast, cursors generally retain only a path to the root.
C# combats increased memory usage by using weak references.</p>
<h3 id="ast"><a class="header" href="#ast">AST</a></h3>
<p><code>GreenTree</code>s are untyped and homogeneous, because it makes accommodating error nodes, arbitrary whitespace and comments natural, and because it makes possible to write generic tree traversals.
However, when working with a specific node, like a function definition, one would want a strongly typed API.</p>
<p>This is what is provided by the AST layer. AST nodes are transparent wrappers over untyped syntax nodes:</p>
<pre><code class="language-rust">pub trait AstNode {
    fn cast(syntax: SyntaxNode) -&gt; Option&lt;Self&gt;
    where
        Self: Sized;

    fn syntax(&amp;self) -&gt; &amp;SyntaxNode;
}</code></pre>
<p>Concrete nodes are generated (there are 117 of them), and look roughly like this:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn cast(syntax: SyntaxNode) -&gt; Option&lt;Self&gt; {
        match kind {
            FN =&gt; Some(FnDef { syntax }),
            _ =&gt; None,
        }
    }
    fn syntax(&amp;self) -&gt; &amp;SyntaxNode {
        &amp;self.syntax
    }
}

impl FnDef {
    pub fn param_list(&amp;self) -&gt; Option&lt;ParamList&gt; {
        self.syntax.children().find_map(ParamList::cast)
    }
    pub fn ret_type(&amp;self) -&gt; Option&lt;RetType&gt; {
        self.syntax.children().find_map(RetType::cast)
    }
    pub fn body(&amp;self) -&gt; Option&lt;BlockExpr&gt; {
        self.syntax.children().find_map(BlockExpr::cast)
    }
    // ...
}</code></pre>
<p>Variants like expressions, patterns or items are modeled with <code>enum</code>s, which also implement <code>AstNode</code>:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    FnDef(FnDef),
    TypeAliasDef(TypeAliasDef),
    ConstDef(ConstDef),
}

impl AstNode for AssocItem {
    ...
}</code></pre>
<p>Shared AST substructures are modeled via (dynamically compatible) traits:</p>
<pre><code class="language-rust">trait HasVisibility: AstNode {
    fn visibility(&amp;self) -&gt; Option&lt;Visibility&gt;;
}

impl HasVisibility for FnDef {
    fn visibility(&amp;self) -&gt; Option&lt;Visibility&gt; {
        self.syntax.children().find_map(Visibility::cast)
    }
}</code></pre>
<p>Points of note:</p>
<ul>
<li>Like <code>SyntaxNode</code>s, AST nodes are cheap to clone pointer-sized owned values.</li>
<li>All "fields" are optional, to accommodate incomplete and/or erroneous source code.</li>
<li>It's always possible to go from an ast node to an untyped <code>SyntaxNode</code>.</li>
<li>It's possible to go in the opposite direction with a checked cast.</li>
<li><code>enum</code>s allow modeling of arbitrary intersecting subsets of AST types.</li>
<li>Most of rust-analyzer works with the ast layer, with notable exceptions of:
<ul>
<li>macro expansion, which needs access to raw tokens and works with <code>SyntaxNode</code>s</li>
<li>some IDE-specific features like syntax highlighting are more conveniently implemented over a homogeneous <code>SyntaxNode</code> tree</li>
</ul>
</li>
</ul>
<h4 id="alternative-designs-2"><a class="header" href="#alternative-designs-2">Alternative Designs</a></h4>
<h5 id="semantic-full-ast"><a class="header" href="#semantic-full-ast">Semantic Full AST</a></h5>
<p>In IntelliJ the AST layer (dubbed <strong>P</strong>rogram <strong>S</strong>tructure <strong>I</strong>nterface) can have semantics attached, and is usually backed by either syntax tree, indices, or metadata from compiled libraries.
The backend for PSI can change dynamically.</p>
<h3 id="syntax-tree-recap"><a class="header" href="#syntax-tree-recap">Syntax Tree Recap</a></h3>
<p>At its core, the syntax tree is a purely functional n-ary tree, which stores text at the leaf nodes and node "kinds" at all nodes.
A cursor layer is added on top, which gives owned, cheap to clone nodes with identity semantics, parent links and absolute offsets.
An AST layer is added on top, which reifies each node <code>Kind</code> as a separate Rust type with the corresponding API.</p>
<h2 id="parsing"><a class="header" href="#parsing">Parsing</a></h2>
<p>The (green) tree is constructed by a DFS "traversal" of the desired tree structure:</p>
<pre><code class="language-rust">pub struct GreenNodeBuilder { ... }

impl GreenNodeBuilder {
    pub fn new() -&gt; GreenNodeBuilder { ... }

    pub fn token(&amp;mut self, kind: SyntaxKind, text: &amp;str) { ... }

    pub fn start_node(&amp;mut self, kind: SyntaxKind) { ... }
    pub fn finish_node(&amp;mut self) { ... }

    pub fn finish(self) -&gt; GreenNode { ... }
}</code></pre>
<p>The parser, ultimately, needs to invoke the <code>GreenNodeBuilder</code>.
There are two principal sources of inputs for the parser:</p>
<ul>
<li>source text, which contains trivia tokens (whitespace and comments)</li>
<li>token trees from macros, which lack trivia</li>
</ul>
<p>Additionally, input tokens do not correspond 1-to-1 with output tokens.
For example, two consecutive <code>&gt;</code> tokens might be glued, by the parser, into a single <code>&gt;&gt;</code>.</p>
<p>For these reasons, the parser crate defines a callback interfaces for both input tokens and output trees.
The explicit glue layer then bridges various gaps.</p>
<p>The parser interface looks like this:</p>
<pre><code class="language-rust">pub struct Token {
    pub kind: SyntaxKind,
    pub is_joined_to_next: bool,
}

pub trait TokenSource {
    fn current(&amp;self) -&gt; Token;
    fn lookahead_nth(&amp;self, n: usize) -&gt; Token;
    fn is_keyword(&amp;self, kw: &amp;str) -&gt; bool;

    fn bump(&amp;mut self);
}

pub trait TreeSink {
    fn token(&amp;mut self, kind: SyntaxKind, n_tokens: u8);

    fn start_node(&amp;mut self, kind: SyntaxKind);
    fn finish_node(&amp;mut self);

    fn error(&amp;mut self, error: ParseError);
}

pub fn parse(
    token_source: &amp;mut dyn TokenSource,
    tree_sink: &amp;mut dyn TreeSink,
) { ... }</code></pre>
<p>Points of note:</p>
<ul>
<li>The parser and the syntax tree are independent, they live in different crates neither of which depends on the other.</li>
<li>The parser doesn't know anything about textual contents of the tokens, with an isolated hack for checking contextual keywords.</li>
<li>For gluing tokens, the <code>TreeSink::token</code> might advance further than one atomic token ahead.</li>
</ul>
<h3 id="reporting-syntax-errors"><a class="header" href="#reporting-syntax-errors">Reporting Syntax Errors</a></h3>
<p>Syntax errors are not stored directly in the tree.
The primary motivation for this is that syntax tree is not necessary produced by the parser, it may also be assembled manually from pieces (which happens all the time in refactorings).
Instead, parser reports errors to an error sink, which stores them in a <code>Vec</code>.
If possible, errors are not reported during parsing and are postponed for a separate validation step.
For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilities as erroneous.</p>
<h3 id="macros"><a class="header" href="#macros">Macros</a></h3>
<p>The primary difficulty with macros is that individual tokens have identities, which need to be preserved in the syntax tree for hygiene purposes.
This is handled by the <code>TreeSink</code> layer.
Specifically, <code>TreeSink</code> constructs the tree in lockstep with draining the original token stream.
In the process, it records which tokens of the tree correspond to which tokens of the input, by using text ranges to identify syntax tokens.
The end result is that parsing an expanded code yields a syntax tree and a mapping of text-ranges of the tree to original tokens.</p>
<p>To deal with precedence in cases like <code>$expr * 1</code>, we use special invisible parenthesis, which are explicitly handled by the parser.</p>
<h3 id="whitespace--comments"><a class="header" href="#whitespace--comments">Whitespace &amp; Comments</a></h3>
<p>Parser does not see whitespace nodes.
Instead, they are attached to the tree in the <code>TreeSink</code> layer.</p>
<p>For example, in</p>
<pre><code class="language-rust">// non doc comment
fn foo() {}</code></pre>
<p>the comment will be (heuristically) made a child of function node.</p>
<h3 id="incremental-reparse"><a class="header" href="#incremental-reparse">Incremental Reparse</a></h3>
<p>Green trees are cheap to modify, so incremental reparse works by patching a previous tree, without maintaining any additional state.
The reparse is based on heuristic: we try to contain a change to a single <code>{}</code> block, and reparse only this block.
To do this, we maintain the invariant that, even for invalid code, curly braces are always paired correctly.</p>
<p>In practice, incremental reparsing doesn't actually matter much for IDE use-cases, parsing from scratch seems to be fast enough.</p>
<h3 id="parsing-algorithm"><a class="header" href="#parsing-algorithm">Parsing Algorithm</a></h3>
<p>We use a boring hand-crafted recursive descent + pratt combination, with a special effort of continuing the parsing if an error is detected.</p>
<h3 id="parser-recap"><a class="header" href="#parser-recap">Parser Recap</a></h3>
<p>Parser itself defines traits for token sequence input and syntax tree output.
It doesn't care about where the tokens come from, and how the resulting syntax tree looks like.</p>
<div style="break-before: page; page-break-before: always;"></div><p>rust-analyzer's testing is based on <em>snapshot tests</em>: a test is a piece of input text, usually a Rust code, and some output text. There is then some testing helper that runs the feature on the input text and compares the result to the output text.</p>
<p>rust-analyzer uses a combination of the crate <a href="https://docs.rs/expect-test"><code>expect-test</code></a> and a custom testing framework.</p>
<p>This all may sound too abstract, so let's demonstrate with an example.</p>
<p>Type inference tests are located at <code>crates/hir-ty/src/tests</code>. There are various test helpers you can use. One of the simplest is <code>check_no_mismatches()</code>: it is given a piece of Rust code (we'll talk more about Rust code in tests later) and asserts that there are no type mismatches in it, that is, one type was expected but another was found (for example, <code>let x: () = 1</code> is a type mismatch). Note that we determine type mismatches via rust-analyzer's own analysis, not via the compiler (this is what we are testing, after all), which means there are often missed mismatches and sometimes bogus ones as well.</p>
<p>For example, the following test will fail:</p>
<pre><code class="language-rust">#[test]
fn this_will_fail() {
    check_no_mismatches(
        r#"
fn main() {
    let x: () = 1;
}
    "#,
    );
}</code></pre>
<p>Sometimes we want to check more that there are no type mismatches. For that we use other helpers. For example, often we want to assert that the type of some expression is some specific type. For that we use the <code>check_types()</code> function. It takes a Rust code string with custom annotation, that are common in our test suite. The general scheme of annotation is:</p>
<ul>
<li>
<p><code>$0</code> marks a position. What to do with it is determined by the testing helper. Commonly it denotes the cursor position in IDE tests (for example, hover).</p>
</li>
<li>
<p><code>$0...$0</code> marks a range, commonly a selection in IDE tests.</p>
</li>
<li>
<p><code>^...^</code>, commonly seen in a comment (<code>// ^^^^</code>), labels the line above. For example, the following will attach the label <code>hey</code> to the range of the variable name <code>cool</code>:</p>
<pre><code class="language-rust">let cool;
 // ^^^^ hey</code></pre>
</li>
</ul>
<p><code>check_types()</code> uses labels to assert type: when you attach a label to a range, <code>check_types()</code> assert that the type of this range will be what written in the label.</p>
<p>It's all too abstract without an example:</p>
<pre><code class="language-rust">#[test]
fn my_test() {
    check_types(
        r#"
fn main() {
    let x = 1;
     // ^ i32
}
    "#,
    );
}</code></pre>
<p>Here, we assert that the type of the variable <code>x</code> is <code>i32</code>. Which is true, of course, so the test will pass.</p>
<p>Oftentimes it is convenient to assert the types of all of the expressions at once, and that brings us to the last kind of test. It uses <code>expect-test</code> to match an output text:</p>
<pre><code class="language-rust">#[test]
fn my_test() {
    check_infer(
        r#"
fn main() {
    let x = 1;
}
    "#,
        expect![[r#"
            10..28 '{     ...= 1; }': ()
            20..21 'x': i32
            24..25 '1': i32
        "#]],
    );
}</code></pre>
<p>The text inside the <code>expect![[]]</code> is determined by the helper, <code>check_infer()</code> in this case. For <code>check_infer()</code>, each line is a range in the source code (the range is counted in bytes and the source is trimmed, indentation is stripped), next to it there is the text in that range, or some part of it with <code>...</code> if it's too long, and finally comes the type of that range.</p>
<p>The important feature of <code>expect-test</code> is that it allows easy update of the expectation. Say you changed something in the code, maybe fixed a bug, and the output in <code>expect![[]]</code> needs to change. Or maybe you are writing it from scratch. Writing it by hand is very tedious and prone to mistakes. But <code>expect-trait</code> has a magic. You can set the environment variable <code>UPDATE_EXPECT=1</code>, then run the test, and it will update automatically! Some editors (e.g. VSCode) make it even more convenient: on them, on the top of every test that uses <code>expect-test</code>, next to the usual <code>Run | Debug</code> buttons, rust-analyzer also shows an <code>Update Expect</code> button. Clicking it will run that test in updating mode.</p>
<h2 id="rust-code-in-the-tests"><a class="header" href="#rust-code-in-the-tests">Rust code in the tests</a></h2>
<p>The first thing that you probably already noticed is that the Rust code in the tests is syntax highlighted! In fact, it even uses semantic highlighting. rust-analyzer highlights strings "as if" they contain Rust code if they are passed to a parameter marked <code>#[rust_analyzer::rust_fixture]</code>, and rust-analyzer test helpers do that (in fact, this was designed for them).</p>
<p>The syntax highlighting is very important, not just because it's nice to the eye: it's very easy to make mistakes in test code, and debugging that can be very hard. Often the test will just fail, printing an <code>{unknown}</code> type, and you'll have no clue what's going wrong. The syntax is the clue; if something isn't highlighted correctly, that probably means there is an error (there is one exception to this, which we'll discuss later). You can even set the semantic highlighting tag <code>unresolved_reference</code> to e.g. red, so you will see such things clearly.</p>
<p>Still, often you won't know what's going wrong. Why you can't fix the test, or worse, you expect it to fail but it doesn't. You can try the code on a real IDE to be sure it works. Later we'll give some tips to fix the test.</p>
<h3 id="the-fixture"><a class="header" href="#the-fixture">The fixture</a></h3>
<p>The Rust code in a test is not, a fact, a single Rust file. It has a mini-language that allows you to express multiple files, multiple crates, different configs, and more. All options are documented in <code>crates/test-utils/src/fixture.rs</code>, but here are some of the common ones:</p>
<ul>
<li><code>//- minicore: flag1, flag2, ...</code>. This is by far the most common flag. Tests in rust-analyzer don't have access by default to any other type - not <code>Option</code>, not <code>Iterator</code>, not even <code>Sized</code>. This flag allows you to include parts of the <code>crates/test-utils/src/minicore.rs</code> file, which mimics <code>core</code>. All possible flags are listed at the top of <code>minicore</code> along with the flags they imply, then later you can see by <code>// region:flag</code> and <code>// endregion:flag</code> what code each flag enables.</li>
<li><code>// /path/to/file.rs crate:crate deps:dep_a,dep_b</code>. The first component is the filename of the code that follows (until the next file). It is required, but only if you supply this line. Other components in this line are optional. They include <code>crate:crate_name</code>, to start a new crate, or <code>deps:dep_a,dep_b</code>, to declare dependencies between crates. You can also declare modules as usual in Rust - just name your paths <code>/foo.rs</code> or <code>/foo/mod.rs</code>, declare <code>mod foo</code> and that's it!</li>
</ul>
<p>So the following snippet:</p>
<pre><code class="language-rust">//- minicore: sized, fn
// /lib.rs crate:foo
pub mod bar;
// /bar.rs
pub struct Bar;
// /main.rs crate:main deps:foo
use foo::Bar;</code></pre>
<p>Declares two crates <code>foo</code> and <code>main</code> where <code>main</code> depends on <code>foo</code>, with dependency in <code>Sized</code> and the <code>FnX</code> traits from <code>core</code>, and a module of <code>foo</code> called <code>bar</code>.</p>
<p>And as promised, here are some tips to make your test work:</p>
<ul>
<li>If you use some type/trait, you must <em>always</em> include it in <code>minicore</code>. Note - not all types from core/std are available there, you can add new (under flags) if you need. And import them if they are not in the prelude.</li>
<li>If you use unsized types (<code>dyn Trait</code>/slices), you may want to include some or all of the following <code>minicore</code> flags: <code>sized</code>, <code>unsize</code>, <code>coerce_unsized</code>, <code>dispatch_from_dyn</code>.</li>
<li>If you use closures, consider including the <code>fn</code> minicore flag. Async closures need the <code>async_fn</code> flag.</li>
<li><code>sized</code> is commonly needed, consider adding it if you're stuck.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
