<!DOCTYPE html>
<html lang="en-US">

<head>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Measuring Memory Usage in Rust</title>
  <meta name="description"
    content="rust-analyzer is a new "IDE backend" for the Rust programming language.Support rust-analyzer on Open Collective or GitHub Sponsors.">

  <link rel="stylesheet" href="/css/asciidoctor.css">
  <link rel="stylesheet" href="/css/rouge-github.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <!-- dark mode -->
  <script type="module" src="/js/nightowl.js"></script>

  <link rel="canonical" href="https://rust-analyzer.github.io//blog/2020/12/04/measuring-memory-usage-in-rust.html">
  <link rel="alternate" type="application/rss+xml" title="rust-analyzer"
    href="https://rust-analyzer.github.io//feed.xml">

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/fav/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/fav/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/fav/favicon-16x16.png">
  <link rel="manifest" href="/assets/site.webmanifest">
  <link rel="mask-icon" href="/assets/fav/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="theme-color" content="#ffffff">
</head>

<body>
  
  <header>
    <div id="header-inner">
      <div class="nightowl-daylight" id="header-left">
        <a class="site-title" href="/">
          <img src="/assets/rust-analyzer.svg" alt="rust analyzer" id="header-logo">
        </a>
      </div>
      <div id="header-right">
        <a class="nav-link" href="https://opencollective.com/rust-analyzer/">Sponsor</a>
        <a class="nav-link" href="/manual.html">Docs</a>
        <a class="nav-link" href="/blog">Blog</a>
        <a class="nav-link" href="/thisweek">Changelog</a>
      </div>
    </div>
  </header>
  

  <main>
    <article>
<h1>Measuring Memory Usage in Rust</h1>
<div class="post-meta sect1">
  @matklad, Dec 4, 2020
</div>
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>rust-analyzer is a new "IDE backend" for the <a href="https://www.rust-lang.org/">Rust</a> programming language.
Support rust-analyzer on <a href="https://opencollective.com/rust-analyzer/">Open Collective</a> or <a href="https://github.com/sponsors/rust-analyzer">GitHub Sponsors</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This post documents a couple of fun tricks we use in rust-analyzer for measuring memory consumption.</p>
</div>
<div class="paragraph">
<p>In general, there are two broad approaches to profiling the memory usage of a program.</p>
</div>
<div class="paragraph">
<p><em>The first approach</em> is based on &#8220;heap parsing&#8221;.
At a particular point in time, the profiler looks at all the memory currently occupied by the program (the heap).
In its raw form, the memory is just a bag of bytes, <code>Vec&lt;u8&gt;</code>.
However the profiler, using some help from the language&#8217;s runtime, is able to re-interpret these bytes as collections of object (&#8220;parse the heap&#8221;).
It then traverses the graph of objects and computes how many instances of each object are there and how much memory they occupy.
The profiler also tracks the ownership relations, to ferret out facts like &#8220;90% of strings in this program are owned by the <code>Config</code> struct&#8221;.
This is the approach I am familiar with from the JVM ecosystem.
Java&#8217;s garbage collector needs to understand the heap to search for unreachable objects, and the same information is used to analyze heap snapshots.</p>
</div>
<div class="paragraph">
<p><em>The second approach</em> is based on instrumenting the calls to allocation and deallocation routines.
The profiler captures backtraces when the program calls <code>malloc</code> and <code>free</code> and constructs a flamegraph displaying &#8220;hot&#8221; functions which allocate a lot.
This is how, for example, <a href="https://github.com/KDE/heaptrack">heaptrack</a> works (see also <a href="https://github.com/cuviper/alloc_geiger">alloc geiger</a>).</p>
</div>
<div class="paragraph">
<p>The two approaches are complementary.
If the problem is that the application does too many short-lived allocations (instead of re-using the buffers), it would be invisible for the first approach, but very clear in the second one.
If the problem is that, in a steady state, the application uses too much memory, the first approach would work better for pointing out which data structures need most attention.</p>
</div>
<div class="paragraph">
<p>In rust-analyzer, we are generally interested in keeping the overall memory usage small, and can make better use of heap parsing approach.
Specifically, most of the rust-analyzer&#8217;s data is stored in the incremental computation tables, and we want to know which table is the heaviest.</p>
</div>
<div class="paragraph">
<p>Unfortunately, Rust does not use garbage collection, so just parsing the heap bytes at runtime is impossible.
The best available alternative is instrumenting data structures for the purposes of measuring memory size.
That is, writing a proc-macro which adds <code>fn total_size(&amp;self) &#8594; usize</code> method to annotated types, and calling that manually from the root of the data.
There is Servo&#8217;s <a href="https://github.com/servo/servo/tree/2d3811c21bf1c02911d5002f9670349c5cf4f500/components/malloc_size_of"><code>malloc_size_of</code></a> crate for doing that, but it is not published to crates.io.</p>
</div>
<div class="paragraph">
<p>Another alternative is running the program under valgrind to gain runtime introspectability.
<a href="https://www.valgrind.org/docs/manual/ms-manual.html">Massif</a> and and <a href="https://www.valgrind.org/docs/manual/dh-manual.html">DHAT</a> work that way.
Running with valgrind is pretty slow, and still doesn&#8217;t give Java-level fidelity.</p>
</div>
<div class="paragraph">
<p>Instead, rust-analyzer mainly relies on a much simpler approach for figuring out which things are heavy.
This is the first trick of this article:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="archimedes-method"><a class="anchor" href="#archimedes-method"></a>Archimedes' Method</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s relatively easy to find out the total memory allocated at any given point in time.
For glibc, there&#8217;s <a href="https://man7.org/linux/man-pages/man3/mallinfo.3.html">mallinfo</a> function, a <a href="https://docs.rs/jemalloc-ctl/0.3.3/jemalloc_ctl/stats/struct.allocated.html">similar API</a> exists for jemalloc.
It&#8217;s even possible to implement a <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> which tracks this number.</p>
</div>
<div class="paragraph">
<p>And, if you can measure total memory usage, you can measure memory usage of any specific data structure by:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>measuring the current memory usage</p>
</li>
<li>
<p>dropping the data structure</p>
</li>
<li>
<p>measuring the current memory usage again</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The difference between the two values is the size of the data structure.
And this is exactly what rust-analyzer does to find the largest caches: <a href="https://github.com/rust-analyzer/rust-analyzer/blob/b988c6f84e06bdc5562c70f28586b9eeaae3a39c/crates/ide_db/src/apply_change.rs#L104-L238">source</a>.</p>
</div>
<div class="paragraph">
<p>Two small notes about this method:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s important to ask the allocator about the available memory, and not the operating system.
OS can only tell how many pages the program consumes.
Only the allocator knows which of those pages are free and which hold allocated objects.</p>
</li>
<li>
<p>When measuring relative sizes, it&#8217;s important to note the unaccounted-for amount in the end, such that the total adds up to 100%.
It might be the case that the bottleneck lies in the dark matter outside of explicit measurements!</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="amdahls-estimator"><a class="anchor" href="#amdahls-estimator"></a>Amdahl&#8217;s Estimator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The second trick is related to the <a href="https://en.wikipedia.org/wiki/Amdahl&#8217;s_law">Amdahl&#8217;s law</a>.
When optimizing a specific component, it&#8217;s important to note not only how much more efficient it becomes, but also overall contribution of the component to the system.
Making an algorithm twice as fast can improve the overall performance only by 5%, if the algorithm is only 10% of the whole task.</p>
</div>
<div class="paragraph">
<p>In rust-analyzer&#8217;s case, the optimization we are considering is adding interning to <code>Name</code>.
At the moment, a <code>Name</code> is represented with a small sized optimized string (24 bytes inline + maybe some heap storage):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">SmolStr</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, we can use an interned index (4 bytes):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="nb">u32</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, just trying out this optimization is not easy, as an interner is a thorny piece of global state.
Is it worth it?</p>
</div>
<div class="paragraph">
<p>If we look at the <code>Name</code> itself, it&#8217;s pretty clear that the optimization is valuable: it reduces memory usage by 6x!
But how important is it in the grand scheme of things?
How to measure the impact of <code>Name</code>s on overall memory usage?</p>
</div>
<div class="paragraph">
<p>One approach is to just apply the optimization and measure the improvement after the fact.
But there&#8217;s a lazier way: instead of making the <code>Name</code> smaller and measuring the improvement, we make it <strong>bigger</strong> and measure the worsening.
Specifically, its easy to change the <code>Name</code> to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span>
    <span class="n">text</span><span class="p">:</span> <span class="n">SmolStr</span><span class="p">,</span>
    <span class="c">// Copy of `text`</span>
    <span class="mi">_</span><span class="n">ballast</span><span class="p">:</span> <span class="n">SmolStr</span><span class="p">,</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if the new <code>Name</code> increases the overall memory consumption by <code>N</code>, we can estimate the total size of old <code>Name</code>s as <code>N</code> as well, as they are twice as small.</p>
</div>
<div class="paragraph">
<p>Sometimes, quick and simple hacks works better than the finest instruments :).</p>
</div>
</div>
</div>
</article>

  </main>

  <footer>
    <div id="footer-inner">
      <div class="footer-by">
        <a href="https://ferrous-systems.com/">
          <img class="ferrous-logo" src="/assets/ferrous-logo.png">Ferrous Systems</a>
        &
        <a href="https://github.com/rust-analyzer/rust-analyzer/graphs/contributors">contributors</a>
      </div>

      <div id="footer-links">
        <a href="/feed.xml" class="footer-link">
          <i class="fa fa-rss"></i> rss
        </a>
        <a href="https://github.com/rust-analyzer/rust-analyzer.github.io" class="footer-link">
          <i class="fa fa-github"></i> src
        </a>
        <a href="https://opencollective.com/rust-analyzer/" class="footer-link">
          <i class="fa fa-github"></i> sponsor
        </a>
      </div>
    </div>
  </footer>
</body>

</html>
